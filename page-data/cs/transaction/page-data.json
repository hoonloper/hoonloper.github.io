{"componentChunkName":"component---src-templates-blog-template-js","path":"/cs/transaction/","result":{"data":{"cur":{"id":"41c752e0-b625-5b1f-8c43-5394bea5e4ae","html":"<p><strong>안녕하세요! 이번 포스트는 트랜잭션에 대해 알아보고 Dead lock이 무엇인지, 어떻게 하면 피할 수 있는지를 알아보겠습니다!</strong></p>\n<h2 id=\"트랜잭션이란\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%B4%EB%9E%80\" aria-label=\"트랜잭션이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션이란?</h2>\n<p>트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미합니다.</p>\n<h2 id=\"트랜잭션-사용-목적\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81\" aria-label=\"트랜잭션 사용 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 사용 목적</h2>\n<ul>\n<li>데이터 부정합 방지<br>\n데이터베이스 서버에 여러 개의 클라이언트가 동시에 액세스하는 경우<br>\n응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우</li>\n<li>데이터베이스의 완전성(integrity) 유지 확신<br>\n데이터베이스가 수행한 일부 쿼리가 남으면 안 됨<br>\nex) 송금시 한 계좌에서 인출 → 다른 계좌에서 입금 확인<br>\n트랜잭션은 서로 간섭하면 안 됨<br>\nex) 쿼리 하나 실패 → 데이터베이스 시스템이 전체 트랜잭션 또는 실패한 쿼리 롤백</li>\n<li>거래의 안정성 확보\n테이블에서 데이터를 읽어옴<br>\n→ 다른 테이블에 데이터 입력/갱신/삭제 도중 오류 발생<br>\n→ 모든 작업 원상태로 되돌림<br>\n처리 과정이 모두 성공했을 때만 최종적으로 데이터베이스에 반영</li>\n</ul>\n<h2 id=\"트랜잭션-특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%ED%8A%B9%EC%A7%95\" aria-label=\"트랜잭션 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 특징</h2>\n<ol>\n<li>트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위입니다.</li>\n<li>사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위입니다.</li>\n<li>하나의 트랜잭션은 Commit되거나 Rollback 됩니다.</li>\n</ol>\n<h2 id=\"트랜잭션의-4가지-성질\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%EC%84%B1%EC%A7%88\" aria-label=\"트랜잭션의 4가지 성질 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션의 4가지 성질</h2>\n<h3 id=\"atomicity원자성\" style=\"position:relative;\"><a href=\"#atomicity%EC%9B%90%EC%9E%90%EC%84%B1\" aria-label=\"atomicity원자성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Atomicity(원자성)</h3>\n<ol>\n<li>트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 합니다.</li>\n<li>트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 합니다.</li>\n</ol>\n<h3 id=\"consistency일관성\" style=\"position:relative;\"><a href=\"#consistency%EC%9D%BC%EA%B4%80%EC%84%B1\" aria-label=\"consistency일관성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Consistency(일관성)</h3>\n<ol>\n<li>트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환합니다.</li>\n<li>시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 합니다.</li>\n</ol>\n<h3 id=\"isolation독립성격리성\" style=\"position:relative;\"><a href=\"#isolation%EB%8F%85%EB%A6%BD%EC%84%B1%EA%B2%A9%EB%A6%AC%EC%84%B1\" aria-label=\"isolation독립성격리성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Isolation(독립성,격리성)</h3>\n<ol>\n<li>둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없습니다.</li>\n<li>수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없습니다.</li>\n</ol>\n<h3 id=\"durablility영속성지속성\" style=\"position:relative;\"><a href=\"#durablility%EC%98%81%EC%86%8D%EC%84%B1%EC%A7%80%EC%86%8D%EC%84%B1\" aria-label=\"durablility영속성지속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Durablility(영속성,지속성)</h3>\n<ol>\n<li>성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 합니다.</li>\n</ol>\n<p><a href=\"https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation\">격리 수준에 대해 정리된 블로그 글</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">💡 트랜잭션 격리수준(Transaction Isolation Level)\n특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지 결정하는 것\n\nREAD UNCOMMITTED\n어떤 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여짐\nREAD COMMITED\n어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회 가능\nREPEATABLE READ\n트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회 가능\nSERIALIZABLE\n트랜잭션이 특정 테이블을 조회하면 다른 트랜잭션은 그 테이블의 데이터를 추가/변경/삭제 불가능\n\n→ 아래로 갈수록 트랜잭션 간 고립 정도가 높아지고 성능이 떨어짐</code></pre></div>\n<h2 id=\"commit-rollback\" style=\"position:relative;\"><a href=\"#commit-rollback\" aria-label=\"commit rollback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit? Rollback?</h2>\n<h3 id=\"commit연산\" style=\"position:relative;\"><a href=\"#commit%EC%97%B0%EC%82%B0\" aria-label=\"commit연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit연산</h3>\n<ol>\n<li>Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산입니다.</li>\n</ol>\n<h3 id=\"rollback연산\" style=\"position:relative;\"><a href=\"#rollback%EC%97%B0%EC%82%B0\" aria-label=\"rollback연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rollback연산</h3>\n<ol>\n<li>Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산입니다.</li>\n<li>Rollback시에는 해당 트랜잭션을 재시작하거나 폐기합니다.</li>\n</ol>\n<h2 id=\"️-트랜잭션-사용시-주의사항\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"️ 트랜잭션 사용시 주의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⚠️ 트랜잭션 사용시 주의사항</h2>\n<ul>\n<li>트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋습니다. 즉 트랜잭션의 범위를 최소화하라는 의미입니다.</li>\n<li>일반적으로 데이터베이스 커넥션은 개수가 제한적입니다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 됩니다.</li>\n<li>그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있습니다.</li>\n</ul>","excerpt":"안녕하세요! 이번 포스트는 트랜잭션에 대해 알아보고 Dead lock이 무엇인지, 어떻게 하면 피할 수 있는지를 알아보겠습니다! 트랜잭션이란? 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미합니다. 트랜잭션 사용 목적 데이터 부정합 방지 데이터베이스 서버에 여러 개의 클라이언트가 동시에 액세스하는 경우 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 데이터베이스의 완전성(integrity) 유지 확신 데이터베이스가 수행한 일부 쿼리가 남으면 안 됨 ex) 송금시 한 계좌에서 인출 → 다른 계좌에서 입금 확인 트랜잭션은 서로 간섭하면 안 됨 ex) 쿼리 하나 실패 → 데이터베이스 시스템이 전체 트랜잭션 또는 실패한 쿼리 롤백 거래의 안정성 확보\n테이블에서 데이터를 읽어옴 → 다른 테이블에 데이터 입력/갱신/삭제 도중 오류 발생 → 모든 작업 원상태로 …","frontmatter":{"date":"September 17, 2022","title":"[CS] 트랜잭션(transaction)","categories":"CS","author":"hoonloper","emoji":"💾"},"fields":{"slug":"/cs/transaction/"}},"next":{"id":"bb3116a1-79dc-59bc-af4c-8b1c91990ddd","html":"<h3 id=\"안녕하세요-이번-포스트는-완전-탐색에-대해-알아보겠습니다-\" style=\"position:relative;\"><a href=\"#%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-%EC%9D%B4%EB%B2%88-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B2%A0%EC%8A%B5%EB%8B%88%EB%8B%A4-\" aria-label=\"안녕하세요 이번 포스트는 완전 탐색에 대해 알아보겠습니다  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>안녕하세요. 이번 포스트는 완전 탐색에 대해 알아보겠습니다 :)</h3>\n<h2 id=\"완전탐색brute-force이란\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84%ED%83%90%EC%83%89brute-force%EC%9D%B4%EB%9E%80\" aria-label=\"완전탐색brute force이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전탐색(brute force)이란?</h2>\n<p>우선 영어 단어 해석부터 살펴보겠습니다. brute force는 무식한? 힘으로 해석이 되는데요. 즉, 가능한 모든 경우의 수를 모두 탐색하면서 요구조건에 충족되는 결과만을 가져오기에 붙은 이름이지 않을까 생각이 들어요!</p>\n<p>완전 탐색 알고리즘이 주는 강점은 예외 없이 정답만을 출력한다는 것입니다.</p>\n<ul>\n<li>\n<p>일반적 방법으로 문제를 해결하기 위해서는 모든 자료를 탐색해야 하기 때문에 특정한 구조를 전체적으로 탐색할 수 있는 방법을 필요로 합니다.</p>\n</li>\n<li>\n<p>알고리즘 설계의 가장 기본적인 접근 방법은 해가 존재할 것으로 예상되는 모든 영역을 전체 탐색하는 방법입니다.</p>\n</li>\n<li>\n<p>선형 구조를 전체적으로 탐색하는 순차 탐색, 비선형 구조를 전체적으로 탐색하는 깊이 우선 탐색(DFS, Depth First Search)과 너비 우선 탐색(BFS, breadth first search)이 가장 기본적인 도구입니다.</p>\n</li>\n</ul>\n<h2 id=\"100-정답만을-출력한다면-완전-탐색-알고리즘만-사용해야-하나\" style=\"position:relative;\"><a href=\"#100-%EC%A0%95%EB%8B%B5%EB%A7%8C%EC%9D%84-%EC%B6%9C%EB%A0%A5%ED%95%9C%EB%8B%A4%EB%A9%B4-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98\" aria-label=\"100 정답만을 출력한다면 완전 탐색 알고리즘만 사용해야 하나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>100% 정답만을 출력한다면 완전 탐색 알고리즘만 사용해야 하나?</h2>\n<p>결론을 우선으로 말하면 아닙니다.</p>\n<p>문제 해결 알고리즘을 사용할 때 기본적으로 <strong>2가지 규칙</strong>이 존재합니다.</p>\n<ul>\n<li>사용된 알고리즘이 문제를 해결할 수 있는가?</li>\n<li>효율적으로 동작하는가?</li>\n</ul>\n<p>첫번째 규칙인 문제를 해결할 수 있는가에는 너무나 적합한 알고리즘이겠지만 두번째인 효율적으로 동작하는가에 대해서 의문을 가질 수 밖에 없습니다.\n만약 주어진 경우가 백만번, 천만번 이런식으로 늘어난다면 결코 효율적인 알고리즘이라고 할 수 없습니다.</p>\n<h2 id=\"완전-탐색-기법을-활용하기\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-%EA%B8%B0%EB%B2%95%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"완전 탐색 기법을 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전 탐색 기법을 활용하기!</h2>\n<p>완전 탐색 알고리즘을 사용하기 위해서 다음을 고려해야 합니다.</p>\n<ul>\n<li>해결하고자 하는 문제의 경우의 수를 대략적으로 계산합니다.</li>\n<li>가능한 모든 방법을 다 고려합니다.</li>\n<li>실제 답을 구할 수 있는지 적용해봅니다.</li>\n</ul>\n<h2 id=\"각-방식에-대한-설명\" style=\"position:relative;\"><a href=\"#%EA%B0%81-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85\" aria-label=\"각 방식에 대한 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각 방식에 대한 설명</h2>\n<h3 id=\"-brute-force-기법\" style=\"position:relative;\"><a href=\"#-brute-force-%EA%B8%B0%EB%B2%95\" aria-label=\" brute force 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>① Brute Force 기법</h3>\n<p>이 방법은 반복 / 조건문을 통해 가능한 모든 방법을 단순히 찾는 경우를 의미합니다.</p>\n<p>예를 들어, 0000~9999 경우의 수 자물쇠 암호를 찾는 경우처럼 모든 경우의 수를 따지는 경우입니다.</p>\n<h3 id=\"-순열permutation\" style=\"position:relative;\"><a href=\"#-%EC%88%9C%EC%97%B4permutation\" aria-label=\" 순열permutation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>② 순열(Permutation)</h3>\n<p>우선 순열이 무엇인지 이해하자. 순열은 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법을 의미한다.</p>\n<p>즉, 순서가 중요함! 만약, 수열에서 숫자 [1, 2, 3]이 있다면, 이것을 [1, 2, 3]으로 보는 순서와 [3, 2, 1]로 보는 순서가 차이가 있음이 중요한 경우를 의미한다.</p>\n<p>같은 데이터가 입력된 수열이지만, 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전 / 다음 수열을 찾아낼 수 있는 경우를 계산할 수 있다.</p>\n<p>그래서, 만약 N개의 서로 다른 데이터가 있고 이를 순열로 나타낸다면 전체 순열의 가지 수는 N!개가 된다. 최초에 N개 중 1개가 올 수 있고 그 이후에는 각각 N-1, N-2, … , 1개가 올 수 있어 이를 모두 곱하면 N!이 되기 때문이다.</p>\n<p>[1, 2, 3]을 사전 순으로 나열하는 순열이 있다고 가정해보자. 그러면 아래와 같이 나열될 수 있을 것이다.</p>\n<p>위 내용과 같이 순열을 나열할 수 있는데, 최초 / 최종 순열을 보면 숫자가 오름 / 내림차순인 것을 알 수 있다. (중복된 숫자가 있다면 비내림 / 비오름차순으로 된다.)</p>\n<p>여기서 사전 순 순열의 규칙을 알아낼 수 있는데 N개의 데이터가 있고 1~i번째 데이터를 설정했을 때, i번째 데이터 기준 최종 순열은 i+1부터 N까지가 모두 내림차순이라는 것이다.(반대로 최초 순열이면 i+1부터 N이 오름차순!)</p>\n<p>예를 들어, 1 3 2를 보자. 이는 0번째 숫자가 1일 때의 최종 순열이다. 왜냐하면 3 2는 내림차순이기 때문이다. 그렇다면 이 다음 순열은 어떻게 구할 수 있을까?</p>\n<p>i번째가 고정이었고 i+1부터 내림차순인 경우가 최종 순열이므로 다음은 i번째부터 모두 오름차순이 되는 최초 순열이 된다. 즉, i-1까지는 변동이 없고 i는 i+1 ~ N까지의 숫자 중 자신보다 크지만 가장 작은 숫자와 교환이 되고 그 i+1~N은 다시 오름차순이 되어야 한다.</p>\n<p>그래서 1 3 2의 다음 순열은 2 1 3이다. 1 3 2에서 1은 2와 교체되었고 1 3은 오름차순으로 정렬되었다.</p>\n<p>이러한 규칙을 통해 이전 / 다음 순열을 구하거나 모든 순열을 완전 탐색으로 구하는 로직을 구현할 수 있게 된다.</p>\n<h3 id=\"-재귀recursive\" style=\"position:relative;\"><a href=\"#-%EC%9E%AC%EA%B7%80recursive\" aria-label=\" 재귀recursive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>③ 재귀(Recursive)</h3>\n<p>재귀는 말 그대로 자기 자신을 호출한다는 의미이다. 왜 자기 자신을 호출할 필요가 있을까?</p>\n<p>예를 들어, 총 4개의 숫자 중에 2개를 선택하는 경우를 모두 출력한다고 가정해보자. 1~4까지 숫자가 있고 2개를 중복 없이 선택하는 모든 경우의 수를 출력하고자 한다고 가정하자.</p>\n<p>이를 반복문으로 표현한다면 다음과 같을 것이다.</p>\n<p>for i from 1 to 4..\nchose i\nfor j from i+1 to 4..\nchose j\nprint i j</p>\n<p>손 쉽게 2중 반복문으로 해결하였다. 그런데.. 만약 숫자 N개의 숫자 중 M개를 고르는 경우라고 할 때, N과 M이 매우 큰 숫자라면 어떨까? 반복문을 수백, 수천 개를 써 내려갈 수는 없다!</p>\n<p>이를 재귀 함수를 활용한다면 자기 자신을 호출함으로써 다음 숫자를 선택할 수 있도록 이동시켜 전체 코드를 매우 짧게 줄일 수 있다!</p>\n<p>여기서 중요한 점!</p>\n<p>⑴ 재귀를 탈출하기 위한 탈출 조건이 필요!\n▶ 이것이 없으면 n개를 모두 골랐음에도 더 숫자를 선택하고자 하여 선택된 숫자를 저장하는 배열에 범위 초과 오류가 나거나, 다른 자료구조를 쓴 경우 잘못된 출력이 나올 수 있고, 혹은 무한 루프가 발생할 수 있다!</p>\n<p>⑵ 현재 함수의 상태를 저장하는 Parameter가 필요!\n▶ 위에서 우리는 curr, cnt를 통해 어떤 숫자까지 선택했는지, 몇 개를 선택했는지 전달하였다. 이것이 없다면 현재 함수의 상태를 저장할 수 없어 재귀 탈출 조건을 만들 수 없게 되거나 잘못된 결과를 출력하게 된다!</p>\n<p>⑶ Return문을 신경 쓸 것!\n▶ 위의 함수는 단순 출력이기에 void로 함수를 작성했다. 그런데, 재귀를 통해 이후의 연산 결과를 반환 후 이전 결과에 추가 연산을 수행하는 경우도 있을 수 있다. 즉, 문제 해결을 위한 정확한 정의를 수행하여야 이것을 완벽히 풀 수 있다.</p>\n<p>잘 생각해보면 Dynamic Programming과도 매우 흡사해 보인다. 그 또한 Top-Down을 사용 시 재귀를 통해 수행하는데, 기저 사례를 통해 탈출 조건을 만들고, 현재 함수의 상태를 전달하는 Parameter를 전달한다.</p>\n<p>또한 Return을 통해 필요한 값을 반환하여 정답을 구하는 연산 시에 사용하게 된다.</p>\n<p>완전 탐색의 재귀와 DP의 차이점은, DP는 작은 문제가 큰 문제와 동일한 구조를 가져 큰 문제의 답을 구할 시에 작은 문제의 결과를 기억한 뒤 그대로 사용하여 수행 속도를 빠르게 한다는 것이다.</p>\n<p>그에 반해 완전 탐색은 크고 작은 문제의 구조가 다를 수 있고, 이전 결과를 반드시 기억하는 것이 아니라 해결 가능한 방법을 모두 탐색한다는 차이가 있다.\n(즉, DP는 일반적인 재귀 중 조건을 만족하는 경우에 적용 가능!)</p>\n<h3 id=\"-비트마스크bitmask\" style=\"position:relative;\"><a href=\"#-%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%ACbitmask\" aria-label=\" 비트마스크bitmask permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>④ 비트마스크(Bitmask)</h3>\n<p>비트마스크란 비트(bit) 연산을 통해서 부분 집합을 표현하는 방법을 의미한다.</p>\n<p>비트 연산이란 다음과 같은 것들이 있다.</p>\n<ul>\n<li>And 연산(&#x26;) : 둘 다 1이면 1</li>\n<li>OR 연산(|) : 둘 중 1개만 1이면 1</li>\n<li>NOT 연산(~) : 1이면 0, 0이면 1</li>\n<li>XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0</li>\n<li>Shift 연산(&#x3C;&#x3C;, >>) : A &#x3C;&#x3C; B라고 한다면 A를 좌측으로 B 비트만큼 미는 것이다.</li>\n</ul>\n<p>① 집합 포함 여부 검사</p>\n<p>② 숫자 추가하기</p>\n<p>③ 특정 숫자 제거하기</p>\n<p>④ 토글 연산하기</p>\n<p>⑤ 전체 집합, 공집합 표현하기</p>\n<h3 id=\"-bfs-dfs-사용하기\" style=\"position:relative;\"><a href=\"#-bfs-dfs-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\" bfs dfs 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⑤ BFS, DFS 사용하기</h3>\n<p>이는 그래프 자료 구조에서 모든 정점을 탐색하기 위한 방법이다.</p>\n<p>BFS는 너비 우선 탐색으로 현재 정점과 인접한 정점을 우선으로 탐색하고 DFS는 깊이 우선 탐색으로 현재 인접한 정점을 탐색 후 그 다음 인접한 정점을 탐색하여 끝까지 탐색하는 방식이다.</p>\n<p>이 내용은 그래프 관련 포스팅(여기)과 BFS 포스팅(여기), DFS 포스팅(여기)를 참고</p>","frontmatter":{"date":"September 01, 2022","title":"[알고리즘] 완전 탐색 - brute force","categories":"알고리즘","author":"hoonloper","emoji":"🧠"},"fields":{"slug":"/algorithm/bruteforce/"}},"prev":{"id":"9c3f3a71-ad7c-5f99-8d95-14b528e0b078","html":"<p><img src=\"https://user-images.githubusercontent.com/78959175/190888255-f601e5a6-41b1-4c5c-bf09-62db4e25ccda.png\" alt=\"111\"></p>\n<p>소규모 프로젝트의 Back-End 개발을 시작했습니다.</p>\n<p>Nest X TypeORM 조합만 사용해왔던 저는 새로운 기술을 배워보고 싶어 평소 흥미롭게 바라보던 Prisma를 적용해보기로 결정합니다.</p>\n<p>공식 문서에서 설명하는 Prisma는 이렇습니다.</p>\n<h2 id=\"프리즈마란\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EB%9E%80\" aria-label=\"프리즈마란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마란?</h2>\n<p>Prisma는 오픈 소스 차세대 ORM입니다. 다음 부분으로 구성됩니다.</p>\n<ul>\n<li>Prisma Client : Node.js 및 TypeScript를 위한 자동 생성 및 유형 안전 쿼리 빌더</li>\n<li>Prisma Migrate : 마이그레이션 시스템</li>\n<li>Prisma Studio : 데이터베이스의 데이터를 보고 편집하는 GUI</li>\n<li>Prisma Client는 모든 Node.js(지원 버전) 또는 TypeScript 백엔드 애플리케이션(서버리스 애플리케이션 및 마이크로서비스 포함)에서 사용할 수 있습니다.</li>\n</ul>\n<h2 id=\"프리즈마의-작동-방식\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\" aria-label=\"프리즈마의 작동 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마의 작동 방식</h2>\n<p><strong>RDBMS</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">datasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel Post {\n  id        Int     @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean @default(false)\n  author    User?   @relation(fields: [authorId], references: [id])\n  authorId  Int?\n}\n\nmodel User {\n  id    Int     @id @default(autoincrement())\n  email String  @unique\n  name  String?\n  posts Post[]\n}</code></pre></div>\n<p><strong>NoSQL</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">datasource db {\n  provider = \"mongodb\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel Post {\n  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n  title     String\n  content   String?\n  published Boolean @default(false)\n  author    User?   @relation(fields: [authorId], references: [id])\n  authorId  String  @db.ObjectId\n}\n\nmodel User {\n  id    String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n  email String  @unique\n  name  String?\n  posts Post[]\n}</code></pre></div>\n<p>이 스키마에서는 세 가지를 구성합니다.</p>\n<ul>\n<li>Data source : 데이터베이스 연결을 지정합니다(환경 변수를 통해).</li>\n<li>Generator : Prisma Client를 생성하고자 함을 나타냅니다.</li>\n<li>Data model : 애플리케이션 모델을 정의합니다.</li>\n</ul>\n<h3 id=\"prisma-client로-데이터베이스에-접근하기\" style=\"position:relative;\"><a href=\"#prisma-client%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0\" aria-label=\"prisma client로 데이터베이스에 접근하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prisma Client로 데이터베이스에 접근하기</h3>\n<p>Prisma Client를 사용하는 첫 번째 단계는 @prisma/clientnpm 패키지를 설치하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install @prisma/client</code></pre></div>\n<p>@prisma/client패키지를 설치하면 prisma generatePrisma 스키마를 읽고 Prisma Client 코드를 생성 하는 명령이 호출됩니다.</p>\n<p>데이터 모델을 변경한 후 내부 코드가 DB에 업데이트 되도록 Prisma Client를 수동으로 다시 생성해야 합니다 .</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">prisma generate</code></pre></div>\n<p>Prisma Client가 생성되면 코드로 가져와서 데이터베이스에 쿼리를 보낼 수 있습니다.</p>","frontmatter":{"date":"September 18, 2022","title":"[Skill] Prisma Proj-1","categories":"SKILL","author":"hoonloper","emoji":"🛠"},"fields":{"slug":"/skills/prisma/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/cs/transaction/","nextSlug":"/algorithm/bruteforce/","prevSlug":"/skills/prisma/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}