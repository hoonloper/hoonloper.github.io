{"componentChunkName":"component---src-templates-blog-template-js","path":"/retrospective/modernagile/","result":{"data":{"cur":{"id":"891672f5-3be6-571a-a7cc-3aac6de179b7","html":"","excerpt":"","frontmatter":{"date":"September 01, 2022","title":"[회고] Modern-Agile Team 3Term 최종 회고","categories":"회고","author":"hoonloper","emoji":"💬"},"fields":{"slug":"/retrospective/modernagile/"}},"next":{"id":"734cd2b6-4d3a-5161-8ae2-6f5ba6fe20c0","html":"<p>Hello</p>","frontmatter":{"date":"August 31, 2022","title":"[프로젝트] Mohae(모두의 해결사) - 재능 나눔 플랫폼","categories":"프로젝트","author":"hoonloper","emoji":"🌈"},"fields":{"slug":"/modern-agile-team/mohae/"}},"prev":{"id":"bb3116a1-79dc-59bc-af4c-8b1c91990ddd","html":"<h3 id=\"안녕하세요-이번-포스트는-완전-탐색에-대해-알아보겠습니다-\" style=\"position:relative;\"><a href=\"#%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-%EC%9D%B4%EB%B2%88-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B2%A0%EC%8A%B5%EB%8B%88%EB%8B%A4-\" aria-label=\"안녕하세요 이번 포스트는 완전 탐색에 대해 알아보겠습니다  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>안녕하세요. 이번 포스트는 완전 탐색에 대해 알아보겠습니다 :)</h3>\n<h2 id=\"완전탐색brute-force이란\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84%ED%83%90%EC%83%89brute-force%EC%9D%B4%EB%9E%80\" aria-label=\"완전탐색brute force이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전탐색(brute force)이란?</h2>\n<p>우선 영어 단어 해석부터 살펴보겠습니다. brute force는 무식한? 힘으로 해석이 되는데요. 즉, 가능한 모든 경우의 수를 모두 탐색하면서 요구조건에 충족되는 결과만을 가져오기에 붙은 이름이지 않을까 생각이 들어요!</p>\n<p>완전 탐색 알고리즘이 주는 강점은 예외 없이 정답만을 출력한다는 것입니다.</p>\n<ul>\n<li>\n<p>일반적 방법으로 문제를 해결하기 위해서는 모든 자료를 탐색해야 하기 때문에 특정한 구조를 전체적으로 탐색할 수 있는 방법을 필요로 합니다.</p>\n</li>\n<li>\n<p>알고리즘 설계의 가장 기본적인 접근 방법은 해가 존재할 것으로 예상되는 모든 영역을 전체 탐색하는 방법입니다.</p>\n</li>\n<li>\n<p>선형 구조를 전체적으로 탐색하는 순차 탐색, 비선형 구조를 전체적으로 탐색하는 깊이 우선 탐색(DFS, Depth First Search)과 너비 우선 탐색(BFS, breadth first search)이 가장 기본적인 도구입니다.</p>\n</li>\n</ul>\n<h2 id=\"100-정답만을-출력한다면-완전-탐색-알고리즘만-사용해야-하나\" style=\"position:relative;\"><a href=\"#100-%EC%A0%95%EB%8B%B5%EB%A7%8C%EC%9D%84-%EC%B6%9C%EB%A0%A5%ED%95%9C%EB%8B%A4%EB%A9%B4-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98\" aria-label=\"100 정답만을 출력한다면 완전 탐색 알고리즘만 사용해야 하나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>100% 정답만을 출력한다면 완전 탐색 알고리즘만 사용해야 하나?</h2>\n<p>결론을 우선으로 말하면 아닙니다.</p>\n<p>문제 해결 알고리즘을 사용할 때 기본적으로 <strong>2가지 규칙</strong>이 존재합니다.</p>\n<ul>\n<li>사용된 알고리즘이 문제를 해결할 수 있는가?</li>\n<li>효율적으로 동작하는가?</li>\n</ul>\n<p>첫번째 규칙인 문제를 해결할 수 있는가에는 너무나 적합한 알고리즘이겠지만 두번째인 효율적으로 동작하는가에 대해서 의문을 가질 수 밖에 없습니다.\n만약 주어진 경우가 백만번, 천만번 이런식으로 늘어난다면 결코 효율적인 알고리즘이라고 할 수 없습니다.</p>\n<h2 id=\"완전-탐색-기법을-활용하기\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-%EA%B8%B0%EB%B2%95%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"완전 탐색 기법을 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전 탐색 기법을 활용하기!</h2>\n<p>완전 탐색 알고리즘을 사용하기 위해서 다음을 고려해야 합니다.</p>\n<ul>\n<li>해결하고자 하는 문제의 경우의 수를 대략적으로 계산합니다.</li>\n<li>가능한 모든 방법을 다 고려합니다.</li>\n<li>실제 답을 구할 수 있는지 적용해봅니다.</li>\n</ul>\n<h2 id=\"각-방식에-대한-설명\" style=\"position:relative;\"><a href=\"#%EA%B0%81-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85\" aria-label=\"각 방식에 대한 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각 방식에 대한 설명</h2>\n<h3 id=\"-brute-force-기법\" style=\"position:relative;\"><a href=\"#-brute-force-%EA%B8%B0%EB%B2%95\" aria-label=\" brute force 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>① Brute Force 기법</h3>\n<p>이 방법은 반복 / 조건문을 통해 가능한 모든 방법을 단순히 찾는 경우를 의미합니다.</p>\n<p>예를 들어, 0000~9999 경우의 수 자물쇠 암호를 찾는 경우처럼 모든 경우의 수를 따지는 경우입니다.</p>\n<h3 id=\"-순열permutation\" style=\"position:relative;\"><a href=\"#-%EC%88%9C%EC%97%B4permutation\" aria-label=\" 순열permutation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>② 순열(Permutation)</h3>\n<p>우선 순열이 무엇인지 이해하자. 순열은 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법을 의미한다.</p>\n<p>즉, 순서가 중요함! 만약, 수열에서 숫자 [1, 2, 3]이 있다면, 이것을 [1, 2, 3]으로 보는 순서와 [3, 2, 1]로 보는 순서가 차이가 있음이 중요한 경우를 의미한다.</p>\n<p>같은 데이터가 입력된 수열이지만, 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전 / 다음 수열을 찾아낼 수 있는 경우를 계산할 수 있다.</p>\n<p>그래서, 만약 N개의 서로 다른 데이터가 있고 이를 순열로 나타낸다면 전체 순열의 가지 수는 N!개가 된다. 최초에 N개 중 1개가 올 수 있고 그 이후에는 각각 N-1, N-2, … , 1개가 올 수 있어 이를 모두 곱하면 N!이 되기 때문이다.</p>\n<p>[1, 2, 3]을 사전 순으로 나열하는 순열이 있다고 가정해보자. 그러면 아래와 같이 나열될 수 있을 것이다.</p>\n<p>위 내용과 같이 순열을 나열할 수 있는데, 최초 / 최종 순열을 보면 숫자가 오름 / 내림차순인 것을 알 수 있다. (중복된 숫자가 있다면 비내림 / 비오름차순으로 된다.)</p>\n<p>여기서 사전 순 순열의 규칙을 알아낼 수 있는데 N개의 데이터가 있고 1~i번째 데이터를 설정했을 때, i번째 데이터 기준 최종 순열은 i+1부터 N까지가 모두 내림차순이라는 것이다.(반대로 최초 순열이면 i+1부터 N이 오름차순!)</p>\n<p>예를 들어, 1 3 2를 보자. 이는 0번째 숫자가 1일 때의 최종 순열이다. 왜냐하면 3 2는 내림차순이기 때문이다. 그렇다면 이 다음 순열은 어떻게 구할 수 있을까?</p>\n<p>i번째가 고정이었고 i+1부터 내림차순인 경우가 최종 순열이므로 다음은 i번째부터 모두 오름차순이 되는 최초 순열이 된다. 즉, i-1까지는 변동이 없고 i는 i+1 ~ N까지의 숫자 중 자신보다 크지만 가장 작은 숫자와 교환이 되고 그 i+1~N은 다시 오름차순이 되어야 한다.</p>\n<p>그래서 1 3 2의 다음 순열은 2 1 3이다. 1 3 2에서 1은 2와 교체되었고 1 3은 오름차순으로 정렬되었다.</p>\n<p>이러한 규칙을 통해 이전 / 다음 순열을 구하거나 모든 순열을 완전 탐색으로 구하는 로직을 구현할 수 있게 된다.</p>\n<h3 id=\"-재귀recursive\" style=\"position:relative;\"><a href=\"#-%EC%9E%AC%EA%B7%80recursive\" aria-label=\" 재귀recursive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>③ 재귀(Recursive)</h3>\n<p>재귀는 말 그대로 자기 자신을 호출한다는 의미이다. 왜 자기 자신을 호출할 필요가 있을까?</p>\n<p>예를 들어, 총 4개의 숫자 중에 2개를 선택하는 경우를 모두 출력한다고 가정해보자. 1~4까지 숫자가 있고 2개를 중복 없이 선택하는 모든 경우의 수를 출력하고자 한다고 가정하자.</p>\n<p>이를 반복문으로 표현한다면 다음과 같을 것이다.</p>\n<p>for i from 1 to 4..\nchose i\nfor j from i+1 to 4..\nchose j\nprint i j</p>\n<p>손 쉽게 2중 반복문으로 해결하였다. 그런데.. 만약 숫자 N개의 숫자 중 M개를 고르는 경우라고 할 때, N과 M이 매우 큰 숫자라면 어떨까? 반복문을 수백, 수천 개를 써 내려갈 수는 없다!</p>\n<p>이를 재귀 함수를 활용한다면 자기 자신을 호출함으로써 다음 숫자를 선택할 수 있도록 이동시켜 전체 코드를 매우 짧게 줄일 수 있다!</p>\n<p>여기서 중요한 점!</p>\n<p>⑴ 재귀를 탈출하기 위한 탈출 조건이 필요!\n▶ 이것이 없으면 n개를 모두 골랐음에도 더 숫자를 선택하고자 하여 선택된 숫자를 저장하는 배열에 범위 초과 오류가 나거나, 다른 자료구조를 쓴 경우 잘못된 출력이 나올 수 있고, 혹은 무한 루프가 발생할 수 있다!</p>\n<p>⑵ 현재 함수의 상태를 저장하는 Parameter가 필요!\n▶ 위에서 우리는 curr, cnt를 통해 어떤 숫자까지 선택했는지, 몇 개를 선택했는지 전달하였다. 이것이 없다면 현재 함수의 상태를 저장할 수 없어 재귀 탈출 조건을 만들 수 없게 되거나 잘못된 결과를 출력하게 된다!</p>\n<p>⑶ Return문을 신경 쓸 것!\n▶ 위의 함수는 단순 출력이기에 void로 함수를 작성했다. 그런데, 재귀를 통해 이후의 연산 결과를 반환 후 이전 결과에 추가 연산을 수행하는 경우도 있을 수 있다. 즉, 문제 해결을 위한 정확한 정의를 수행하여야 이것을 완벽히 풀 수 있다.</p>\n<p>잘 생각해보면 Dynamic Programming과도 매우 흡사해 보인다. 그 또한 Top-Down을 사용 시 재귀를 통해 수행하는데, 기저 사례를 통해 탈출 조건을 만들고, 현재 함수의 상태를 전달하는 Parameter를 전달한다.</p>\n<p>또한 Return을 통해 필요한 값을 반환하여 정답을 구하는 연산 시에 사용하게 된다.</p>\n<p>완전 탐색의 재귀와 DP의 차이점은, DP는 작은 문제가 큰 문제와 동일한 구조를 가져 큰 문제의 답을 구할 시에 작은 문제의 결과를 기억한 뒤 그대로 사용하여 수행 속도를 빠르게 한다는 것이다.</p>\n<p>그에 반해 완전 탐색은 크고 작은 문제의 구조가 다를 수 있고, 이전 결과를 반드시 기억하는 것이 아니라 해결 가능한 방법을 모두 탐색한다는 차이가 있다.\n(즉, DP는 일반적인 재귀 중 조건을 만족하는 경우에 적용 가능!)</p>\n<h3 id=\"-비트마스크bitmask\" style=\"position:relative;\"><a href=\"#-%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%ACbitmask\" aria-label=\" 비트마스크bitmask permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>④ 비트마스크(Bitmask)</h3>\n<p>비트마스크란 비트(bit) 연산을 통해서 부분 집합을 표현하는 방법을 의미한다.</p>\n<p>비트 연산이란 다음과 같은 것들이 있다.</p>\n<ul>\n<li>And 연산(&#x26;) : 둘 다 1이면 1</li>\n<li>OR 연산(|) : 둘 중 1개만 1이면 1</li>\n<li>NOT 연산(~) : 1이면 0, 0이면 1</li>\n<li>XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0</li>\n<li>Shift 연산(&#x3C;&#x3C;, >>) : A &#x3C;&#x3C; B라고 한다면 A를 좌측으로 B 비트만큼 미는 것이다.</li>\n</ul>\n<p>① 집합 포함 여부 검사</p>\n<p>② 숫자 추가하기</p>\n<p>③ 특정 숫자 제거하기</p>\n<p>④ 토글 연산하기</p>\n<p>⑤ 전체 집합, 공집합 표현하기</p>\n<h3 id=\"-bfs-dfs-사용하기\" style=\"position:relative;\"><a href=\"#-bfs-dfs-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\" bfs dfs 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⑤ BFS, DFS 사용하기</h3>\n<p>이는 그래프 자료 구조에서 모든 정점을 탐색하기 위한 방법이다.</p>\n<p>BFS는 너비 우선 탐색으로 현재 정점과 인접한 정점을 우선으로 탐색하고 DFS는 깊이 우선 탐색으로 현재 인접한 정점을 탐색 후 그 다음 인접한 정점을 탐색하여 끝까지 탐색하는 방식이다.</p>\n<p>이 내용은 그래프 관련 포스팅(여기)과 BFS 포스팅(여기), DFS 포스팅(여기)를 참고</p>","frontmatter":{"date":"September 01, 2022","title":"[자료구조] 완전 탐색 - brute force","categories":"자료구조","author":"hoonloper","emoji":"🧠"},"fields":{"slug":"/algorithm/bruteforce/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/retrospective/modernagile/","nextSlug":"/modern-agile-team/mohae/","prevSlug":"/algorithm/bruteforce/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}