{"componentChunkName":"component---src-templates-blog-template-js","path":"/books/core-javascript-3/","result":{"data":{"cur":{"id":"f1a72c63-1c6c-515f-a84d-cb07110b913b","html":"<h3 id=\"this\" style=\"position:relative;\"><a href=\"#this\" aria-label=\"this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>this</h3>\n<p>자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정됩니다. 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 <strong>this는 함수를 호출할 때 결정</strong>된다고 할 수 있습니다.</p>\n<p><strong>전역 공간에서의 this</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span> <span class=\"token operator\">===</span> window<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token keyword\">this</span> <span class=\"token operator\">===</span> global<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>전역 공간에 변수를 할당하면 window.변수(or global)와 this.변수 모두 동일한 값이 출력되는데 그 이유는 <strong>자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티</strong>로서 동작하기 때문입니다.</p>\n<blockquote>\n<p>전역 변수를 선언하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당한다.</p>\n</blockquote>\n<p><strong>메서드로서 호출할 때 그 메서드 내부에서의 this</strong>\n프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 <strong>독립성</strong>에 있습니다.</p>\n<p><strong>함수는 그 자체로 독립적인 기능을 수행</strong>하는 반면, <strong>메서드는 자신을 호출한 대상 객체에 관한 동작을 수행</strong>합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Window { ... } 1</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">method</span><span class=\"token operator\">:</span> func<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { method: f } 2</span></code></pre></div>\n<p>메서드 내부에서의 this는 점 표기법 마지막 점 앞에 명시된 객체가 곧 this가 됩니다.</p>\n<h3 id=\"함수로서-호출할-때-그-함수-내부에서의-this\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98%EB%A1%9C%EC%84%9C-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C-%EA%B7%B8-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EC%9D%98-this\" aria-label=\"함수로서 호출할 때 그 함수 내부에서의 this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수로서 호출할 때 그 함수 내부에서의 this</h3>\n<p>어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않습니다. 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라보기 때문에 함수에서의 this는 전역 객체를 가리킵니다.</p>\n<p>변수를 사용하면 this를 우회할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">outer</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">innerFunc1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Window { ... }</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">innerFunc1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">var</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">innerFunc2</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">innerFunc2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>this를 바인딩하지 않는 함수</strong>\nES6에서는 함수 내부에서 **this가 전역 객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수(arrow function)**을 도입했습니다.</p>\n<p>화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어 상위 스코프의 this를 그대로 활용할 수 있습니다. 즉 우회법이 필요 없어집니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">outer</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">innerFunc</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">innerFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"콜백-함수-호출-시-그-함수-내부에서의-this\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EC%8B%9C-%EA%B7%B8-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EC%9D%98-this\" aria-label=\"콜백 함수 호출 시 그 함수 내부에서의 this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백 함수 호출 시 그 함수 내부에서의 this</h3>\n<p>콜백 함수에서의 this는 ‘무조건 이거다!’라고 정의할 수 없습니다. 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, <strong>특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역 객체를 바라봅니다.</strong></p>\n<h3 id=\"생성자-함수-내부에서의-this\" style=\"position:relative;\"><a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EC%9D%98-this\" aria-label=\"생성자 함수 내부에서의 this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생성자 함수 내부에서의 this</h3>\n<p>생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수입니다. 객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라고 합니다.</p>\n<p>프로그래밍적으로 ‘생성자’는 구체적인 인스턴스를 만들기 위한 일종의 틀입니다.</p>\n<h3 id=\"명시적으로-this를-바인딩하는-방법\" style=\"position:relative;\"><a href=\"#%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-this%EB%A5%BC-%EB%B0%94%EC%9D%B8%EB%94%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"명시적으로 this를 바인딩하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명시적으로 this를 바인딩하는 방법</h3>\n<ul>\n<li>func.call(): 객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있습니다.</li>\n<li>func.apply(): call 메서드와 동일하지만 apply는 두번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있습니다.</li>\n</ul>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<ul>\n<li>전역 공간에서의 this는 전역객체(브라우저 window, Node.js global)를 참조합니다.</li>\n<li>어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 주체(메서드명 앞의 객체)를 참조합니다.</li>\n<li>어떤 함수를 함수로서 호출한 경우 this는 전역 객체를 참조합니다. 메서드의 내부 함수에서도 같습니다.</li>\n<li>콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역 객체를 참조합니다.</li>\n<li>생성자 함수에서의 this는 생성될 인스턴스를 참조합니다.</li>\n</ul>","excerpt":"this 자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정됩니다. 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 this는 함수를 호출할 때 결정된다고 할 수 있습니다. 전역 공간에서의 this 전역 공간에 변수를 할당하면 window.변수(or global)와 this.변수 모두 동일한 값이 출력되는데 그 이유는 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작하기 때문입니다. 전역 변수를 선언하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당한다. 메서드로서 호출할 때 그 메서드 내부에서의 this\n프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 독립성에 있습니다. 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행합니다. 메서드 내부에서의 this는 점 표기법 마지막 점 앞에 명시된 객체가 곧 this가 됩…","frontmatter":{"date":"November 26, 2022","title":"[Core-Javascript] 세번째 팁 모음","categories":"BOOKS","author":"hoonloper","emoji":"📖"},"fields":{"slug":"/books/core-javascript-3/"}},"next":{"id":"a17c867d-9747-5c46-a9fd-e5a167480863","html":"<h3 id=\"실행-컨텍스트\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8\" aria-label=\"실행 컨텍스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행 컨텍스트</h3>\n<p>실행 컨텍스트?\n<strong>실행할 코드에 제공할 환경 정보들을 모아놓은 객체</strong></p>\n<blockquote>\n<p>스택(stack), 큐(queue)의 개념</p>\n</blockquote>\n<p>스택 - FILO 구조, 바구니와 비슷한 데이터 구조\n큐 - FIFO 구조, 파이프와 비슷한 데이터 구조</p>\n<p>동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장합니다. 여기서 동일한 환경 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval() 함수, 함수 등이 있습니다. 자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것뿐입니다.</p>\n<p><em>Node.js 실행 환경에 대해서는 새롭게 포스트를 정리할게요 😉</em></p>\n<h3 id=\"실행-컨텍스트-객체-데이터\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B0%9D%EC%B2%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"실행 컨텍스트 객체 데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행 컨텍스트 객체 데이터</h3>\n<ul>\n<li>VariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항은 반영되지 않음</li>\n<li>LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨</li>\n<li>ThisBinding: this 식별자가 바라봐야 할 대상 객체</li>\n</ul>\n<h3 id=\"variableenvironment\" style=\"position:relative;\"><a href=\"#variableenvironment\" aria-label=\"variableenvironment permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VariableEnvironment</h3>\n<p>VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고 이후네는 LexicalEnvironment를 주로 활용하게 됩니다.</p>\n<p>VariableEnvironment와 LexicalEnvironment의 내부는 environmentRecord와 outer-EnvironmentReference로 구성돼 있습니다. 초기화 과정 중에는 사실상 완전히 동일합니다.</p>\n<h3 id=\"lexicalenvironment\" style=\"position:relative;\"><a href=\"#lexicalenvironment\" aria-label=\"lexicalenvironment permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LexicalEnvironment</h3>\n<p>LexicalEnvironment에 대한 한국어 번역은 문서마다 제각각 다른데 <strong>어휘적 환경</strong>, <strong>정젹 환경</strong>이라는 단어가 가장 많이 등장합니다.</p>\n<p><strong>environmentRecord</strong>\nenvironmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됩니다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당합니다. 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 <strong>순서대로</strong> 수집합니다.</p>\n<blockquote>\n<p>전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 객체, 즉 전역 객체를 활용합니다. 전역 객체에는 브라우저의 window, Node.js의 global 객체 등이 있습니다. 이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류됩니다.</p>\n</blockquote>\n<p><em>호이스팅 관련한 포스팅도 따로 다루겠습니다 😉</em></p>\n<h3 id=\"스코프-스코프-체인-outerenvironmentreference\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BD%94%ED%94%84-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8-outerenvironmentreference\" aria-label=\"스코프 스코프 체인 outerenvironmentreference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스코프, 스코프 체인, outerEnvironmentReference</h3>\n<blockquote>\n<p>스코프란 <strong>식별자에 대한 유효 범위</strong>입니다.</p>\n</blockquote>\n<p>ES5까지의 자바스크립트는 전역공간을 제외하면 오직 함수에 의해서만 스코프가 생성됩니다. ES6에서는 블록에 의해서도 스코프 경계가 발생하게 함으로써 다른 언어와 훨씬 비슷해졌습니다. 다만 이러한 블록은 var로 선언한 변수에 대해서는 작용하지 않고 오직 새로 생긴 let과 const, class, strict mode에서의 함수 선언 등에 대해서만 범위로서의 역할을 수행합니다.</p>\n<p>함수 스코프, 블록 스코프로 분리해 사용합니다.</p>\n<p><strong>스코프 체인</strong>\nouterEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조합니다. 여러 스코프에서 동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하게 됩니다.</p>\n<p><strong>전역 변수와 지역 변수</strong>\n지역 변수 - 함수나 블록 내부에서 선언한 변수\n전역 변수 - 전여 공간에 선언한 변수</p>","frontmatter":{"date":"November 19, 2022","title":"[Core-Javascript] 두번째 팁 모음","categories":"BOOKS","author":"hoonloper","emoji":"📖"},"fields":{"slug":"/books/core-javascript-2/"}},"prev":{"id":"b40ce09b-cf0e-515f-834a-509512e42b7a","html":"<p>안녕하세요. 어느덧 개발 공부를 시작한지 1년이 채워졌고 개발자로 총 5개월쯤 업무를 봤네요. 이제부터 들려드릴 이야기는 흔하고 특색은 떨어지지만 담백한 개발자의 1년 이야기입니다.</p>\n<blockquote>\n<p>~ 2022년 12월 21일</p>\n</blockquote>\n<h2 id=\"-어느새\" style=\"position:relative;\"><a href=\"#-%EC%96%B4%EB%8A%90%EC%83%88\" aria-label=\" 어느새 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🫢 어느새?!</h2>\n<p>2021년 12월 6일 동아리 활동을 시작으로 제 개발 커리어가 시작됐습니다. 처음 막 공부를 시작할 때는 정말 개발자로 취직할 수 있을지 걱정이 태산같았어요. 이런 걱정들을 잊으려고 자신감을 불어 넣으며 힘차게 달렸더니 어느순간 개발자로 현업에서 일을 하고 있군요.</p>\n<p>물론 지금까지 힘차게 달렸던 것만은 아닙니다. 흔히 말하는 개발 권태기를 저도 한번 겪었었고 더 높은 곳을 향해 달려가고 싶은 욕망은 크지만 한참 모자란 것 같은 기분에 우울했던 적도 있지요. 이런 다양한 스토리들을 간략하게 풀어볼까 해요!</p>\n<h2 id=\"-개발-시작\" style=\"position:relative;\"><a href=\"#-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91\" aria-label=\" 개발 시작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🏃🏻 개발 시작!</h2>\n<p>위에서 말했듯 작년 12월에 공부를 시작했습니다. 모던 애자일이라는 동아리에 가입해 개발에 ‘개’자도 모르는 상태로 프로젝트 리더 직책을 맡아 개발을 시작했습니다. 프로그래밍 언어, 각종 CS 지식 등 개발 관련한 내용에 전무했기에 프로젝트 성사에 큰 부담을 느꼈었죠. 당시에 긴장감이 지금의 개발자 정용훈이 있을 수 있는 원동력이지 않나 싶어요 😂</p>\n<p>처음 시작한 프로젝트는 모해(Mohae) 플랫폼이에요! 모해는 ‘모두의 해결사’의 줄임말로 사회 초년생, 대학생을 타겟으로 도움을 필요로하는 모든 사람들에게 재능을 기부할 수 있는 오작교?같은 연결 다리 역할입니다. 사실 모해 플랫폼 이전에 미니 프로젝트로 ‘에브리타임’ 클론 코딩을 진행했으나 연습용 토이 프로젝트이기에 비중이 높지 않았습니다. 각설하고 모해 플랫폼을 진행하면서 정말 다양한 사건들이 있었어요.</p>\n<p>단편적인 예시로 Nest.js 프레임워크를 사용하게 된 스토리가 있어요. 모던 애자일 동아리는 기수제로 운영되는데 저는 3기 회장이었습니다. 어느 날 윗 기수(1기, 2기)분들과 저녁 식사 자리를 갖게 되었어요. 당시 모해 프로젝트 기획 단계였던지라 정말 아무것도 모르는 상태였죠. 그때 윗 기수분들 중 한분이 Nest.js를 사용해보라고 적극 권유해줬죠. 저는 Node의 프레임워크 역할을 한다는 Nest.js에 매력을 느꼈고 메모를 해둔 뒤 다음 날 조사를 시작했어요. <em>조사에 대한 내용은 생략하겠습니다 🤪</em> 조사 내용을 정리해서 같은 Back-End 팀원들에게 공유와 함께 모해 프로제트에서 Nest.js 프레임워크를 사용하자고 적극 어필했어요. 다행이 팀원들은 설득이 됐고 Nest.js를 사용하게 됐습니다 👏🏻👏🏻👏🏻 하지만 시간이 흘러 팀원이 얘기해 주기를 Node에 대해서도 아직 모르는데 Nest.js는 너무 성급한 느낌이 들어 반대 입장이었다고 하더라고요. 프로젝트 리더인 저를 믿고 밑져야 본전으로 시작했다고 하는데 결과론적으로 Nest.js를 사용한 게 도움이 너무나 많이 됐다고 고맙다는 인사를 전하는 것을 보고 많이 뿌듯했습니다. 사실 저도 불안함은 좀처럼 쉽게 사라지지 않았거든요. 저를 믿어준 팀원에게 고맙고 팀원도 함께 극복해나가 도움이 됐다고 하니 완전 윈윈이네요?!🥳 이런 비하인드 스토리가 숨어있었답니다~</p>\n<p>다음은 모던 애자일 4기 모집과 관련된 제 스토리가 하나 있습니다. 저는 첫 직장을 2022년 7월 중순에 출근을 했어요. 모던 애자일 4기 모집 기간은 6월이었고 함께 활동을 시작한 일은 7월 초에요. 네 2주만 함께 활동하고 회장은 직장으로 런을…은 아니고 합격 발표시 팀원들에게 의견을 구하고 모두 혼쾌히 보내줘서 안심하고 취업을 할 수 있었어요. 이때 제가 회장의 역할을 못하진 않았다는 느낌을 받아 보람찼습니다. 취업을 해서도 관리는 멈추지 않았고 3기 인원들은 무사히 프로젝트 배포를 마쳐 8월 말에 활동이 종료됐습니다. 현재도 지속적으로 유지보수를 진행중이고요!</p>\n<h2 id=\"-첫-직장\" style=\"position:relative;\"><a href=\"#-%EC%B2%AB-%EC%A7%81%EC%9E%A5\" aria-label=\" 첫 직장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💼 첫 직장..!</h2>\n<p>여름에 합격한 제 첫 직장은 조금 특별했어요. 서류를 넣은 곳들 중 유일하게 서류 합격, 그리고 첫 면접에 최종 합격을 통보 받고 업계 평균 이상의 처우를 받게 되어 당시에 너무 행복했습니다. 현재는 이직 후 업무를 보고 있지만 첫 직장의 경험으로 많은 것을 깨달아서 만족합니다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>제 체감상으로 3년은 지난 것 같은데 이제 1년이 지나네요. 2023년에는 어떤 일들이 펼쳐질지 누구도 알 수 없지만 지금까지 지켜왔던 신념 그대로 밀고 나가서 원하는 목표에 도달할 때까지 우직하게 보내려고 합니다. 저뿐만 아니라 모든 분들 2022년 고생했고 2023년에는 원하는 모든 게 이뤄지길 바랍니다 🙏🏼</p>\n<p><strong>감사합니다 🙇</strong></p>","frontmatter":{"date":"December 21, 2022","title":"[회고] 2022년을 돌아보며","categories":"회고","author":"hoonloper","emoji":"👣"},"fields":{"slug":"/retrospect/2022-마지막-회고/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/books/core-javascript-3/","nextSlug":"/books/core-javascript-2/","prevSlug":"/retrospect/2022-마지막-회고/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}