{"componentChunkName":"component---src-templates-blog-template-js","path":"/books/core-javascript-1/","result":{"data":{"cur":{"id":"fe776cf8-40ec-5493-8447-d0b3c483b0cc","html":"<p>코어 자바스크립트 책을 정독하면서 얻은 팁들을 소소하게 정리하는 게시글입니다.</p>\n<h3 id=\"데이터-타입의-종류\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"데이터 타입의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 타입의 종류</h3>\n<p>자바스크립트의 데이터 타입에는 크게 두 가지가 있는데 <strong>기본형</strong>과 <strong>참조형</strong>입니다.</p>\n<p>기본형</p>\n<ul>\n<li>number(숫자)</li>\n<li>string(문자열)</li>\n<li>boolean(불리언)</li>\n<li>null</li>\n<li>undefined</li>\n<li>symbol(심볼)</li>\n</ul>\n<p>참조형</p>\n<ul>\n<li>object(객체)\n<ul>\n<li>Map</li>\n<li>WeakMap</li>\n<li>Set</li>\n<li>WeakSet</li>\n</ul>\n</li>\n<li>array(배열)</li>\n<li>function(함수)</li>\n<li>date(날짜)</li>\n<li>regexp(정규표현식)</li>\n</ul>\n<p>기본형과 참조형의 차이점은 무엇일까요?</p>\n<p>기본형은 값이 담긴 주솟값을 바로 복제하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다는 점입니다.</p>\n<p>그리고 기본형은 불변성을 띕니다.\n한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않습니다.</p>\n<h3 id=\"메모리와-데이터\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"메모리와 데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리와 데이터</h3>\n<p>자바스크립트는 메모리 용량이 과거보다 월등히 커진 시점에서 등장했기에 다른 저급 언어들과 상대적으로 메모리 관리에 대한 압박에서 자유로워졌습니다. 그래서 메모리 공간을 좀 더 넉넉하게 할당했습니다.</p>\n<p>숫자의 경우 정수형, 부동소수형을 구분하지 않고 64비트, 즉 8바이트를 확보합니다. 그래서 개발자가 형변환에 대한 걱정을 훨씬 줄였습니다.</p>\n<h3 id=\"변수와-식별자\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98%EC%99%80-%EC%8B%9D%EB%B3%84%EC%9E%90\" aria-label=\"변수와 식별자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수와 식별자</h3>\n<p>변수 - 변할 수 있는 데이터\n식별자 - 어떤 데이터를 식별하는 데 사용하는 이름, 변수명</p>\n<h3 id=\"얕은-복사와-깊은-복사\" style=\"position:relative;\"><a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"얕은 복사와 깊은 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>얕은 복사와 깊은 복사</h3>\n<p>얕은 복사 - 바로 아래 단계의 값만 복사하는 방법\n깊은 복사 - 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법</p>\n<p>얕은 복사를 할 경우 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미입니다. 이렇게 되면 원본과 사본 모두 동일한 참조형 데이터의 주소를 가리키게 되며 사본이 바뀌면 원본도 바뀌게 됩니다.</p>\n<p>깊은 복사를 할 경우 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 합니다.</p>\n<h3 id=\"undefined\" style=\"position:relative;\"><a href=\"#undefined\" aria-label=\"undefined permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>undefined</h3>\n<p>undefined는 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 있습니다. 자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환합니다.</p>\n<ul>\n<li>값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때</li>\n<li>객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때</li>\n<li>return 문이 없거나 호출되지 않는 함수의 실행 결과</li>\n</ul>","excerpt":"코어 자바스크립트 책을 정독하면서 얻은 팁들을 소소하게 정리하는 게시글입니다. 데이터 타입의 종류 자바스크립트의 데이터 타입에는 크게 두 가지가 있는데 기본형과 참조형입니다. 기본형 number(숫자) string(문자열) boolean(불리언) null undefined symbol(심볼) 참조형 object(객체) Map WeakMap Set WeakSet array(배열) function(함수) date(날짜) regexp(정규표현식) 기본형과 참조형의 차이점은 무엇일까요? 기본형은 값이 담긴 주솟값을 바로 복제하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다는 점입니다. 그리고 기본형은 불변성을 띕니다.\n한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않습니다. 메모리와 데이터 자바스크립트는 메모리 용량이 과거보다 월등히 커진 시점에서 등장했기에 다른 저급 언어들과 상대적으로 메모리 관리에 대한 압박에서 자유로워졌습니다. …","frontmatter":{"date":"November 05, 2022","title":"[Core-Javascript] 첫 번째 팁 모음","categories":"서적","author":"hoonloper","emoji":"📖"},"fields":{"slug":"/books/core-javascript-1/"}},"next":{"id":"f1cfcb7c-db6a-5e27-aba8-1d63408568ff","html":"<p><del>사내에서 몽고DB를 다루기 때문에 좀 더 깊게 공부하려고 정리한 글입니다.</del></p>\n<h2 id=\"nosql이란\" style=\"position:relative;\"><a href=\"#nosql%EC%9D%B4%EB%9E%80\" aria-label=\"nosql이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL이란?</h2>\n<p>NoSQL은 Not Only SQL, SQL 뿐만 아니다라는 의미를 지니고 있습니다. 즉, SQL을 사용하는 관계형 데이터베이스가 아닌 데이터베이스를 의미합니다.</p>\n<blockquote>\n<p>대표적인 관계형 데이터베이스로는 MySQL, Oracle, PostgreSQL이 있고, NoSQL 진영에는 이 포스트에서 다루는 MongoDB와 Redis, HBase 등이 있습니다.</p>\n</blockquote>\n<p>그래서 NoSQL은 왜 탄생하게 됐을까요? RDBMS만으로 충분하지 않을까?라는 의문이 있습니다. 하지만 RDBMS은 은총알이 아니었고 분명한 한계점이 있죠. NoSQL은 다음과 같이 RDBMS에선 하기 힘든 일을 쉽게 지원합니다.</p>\n<ul>\n<li>수평 확장 가능한 분산 시스템</li>\n<li>Schema-less</li>\n<li>완화된 ACID</li>\n</ul>\n<h2 id=\"rdbms-vs-nosql\" style=\"position:relative;\"><a href=\"#rdbms-vs-nosql\" aria-label=\"rdbms vs nosql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RDBMS vs NoSQL</h2>\n<ul>\n<li>적합한 사용례 데이터 정합성이 보장되어야 하는 은행 시스템 낮은 지연 시간, 가용성이 중요한 SNS 시스템</li>\n<li>데이터 모델 정규화와 참조 무결성이 보장된 스키마 스키마가 없는 자유로운 데이터 모델</li>\n<li>트랜젝션 강력한 ACID 지원 완화된 ACID(BASE)</li>\n<li>확장 하드웨어 강화(Scale up) 수평 확장 가능한 분산 아키텍처(Scale out)</li>\n<li>API SQL 쿼리 객체 기반 API 제공</li>\n</ul>\n<p>마치 RDBMS에 수평 확장이 불가능한 것 처럼 써놨지만 MySQL Replication이나 MySQL Cluster가 존재하여 수평 확장이 불가능한 것은 아닙니다. 그리고 NoSQL에서도 ACID가 불가능하지 않습니다. MongoDB의 경우 분산 트랜젝션까지도 지원하고 있다. 단, NoSQL 데이터베이스는 대게 분산 아키텍처를 염두하고 출시된 제품이 많아 더 편리하다는 장점이 있고 BASE 기반이기 때문에 완전한 ACID가 아닙니다. 그래도 점점 서로의 장점을 흡수하고 있습니다.</p>\n<blockquote>\n<p>그래서 MongoDB가 뭔데?\nMongoDB는 앞서 설명한 것 처럼 NoSQL 데이터베이스고 다음 세 가지 특징을 가지고있습니다.</p>\n</blockquote>\n<ul>\n<li>Document</li>\n<li>BASE</li>\n<li>Open Source</li>\n</ul>\n<p>데이터는 Document 기반으로 구성되어있고, ACID 대신 BASE를 택하여 성능과 가용성을 우선시합니다. 그리고 오픈 소스라는 점 덕분에 무료로 이용이 가능합니다.</p>\n<h3 id=\"document\" style=\"position:relative;\"><a href=\"#document\" aria-label=\"document permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Document</h3>\n<p>MongoDB는 Document 기반 데이터베이스입니다. Database > Collection > Document > Field 계층으로 이루어져 있으며 Document는 RDBMS의 Row에 해당합니다. 계층은 RDBMS와 유사합니다.</p>\n<h3 id=\"rdmbs와-mongodb-데이터-계층-구조\" style=\"position:relative;\"><a href=\"#rdmbs%EC%99%80-mongodb-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\"rdmbs와 mongodb 데이터 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RDMBS와 MongoDB 데이터 계층 구조</h3>\n<p>흥미로운 점은 Document 기반 데이터베이스은 RDBMS와 다르게 자유로이 데이터 구조를 잡을 수 있다는 점입니다. MongoDB는 BSON으로 데이터가 쌓이기 때문에 Array 데이터나 Nested한 데이터를 쉽게 넣을 수 있습니다.</p>\n<h3 id=\"jsonbson의-형태\" style=\"position:relative;\"><a href=\"#jsonbson%EC%9D%98-%ED%98%95%ED%83%9C\" aria-label=\"jsonbson의 형태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSON(BSON)의 형태</h3>\n<p>위 데이터 구조에서 ObjectId라는 생소한 타입을 볼 수 있습니다. ObjectId는 RDBMS의 Primary Key와 같이 고유한 키를 의미하는데 차이점은 Primary Key는 DBMS가 직접 부여한다면 ObjectId는 클라이언트에서 생성한다는 점입니다. 이는 MongoDB 클러스터에서 Sharding된 데이터를 빠르게 가져오기 위함인데 Router(mongos)는 ObjectId를 보고 데이터가 존재하는 Shard에서 데이터를 요청할 수 있습니다. 의아하게도 MongoDB 서버에서 알아서 ObjectId를 부여해서 저장해도 될 것 같은데 딱히 지원해주지 않습니다. 참고로 ObjectId를 넣지않고 저장한다면 데이터가 그대로 저장됩니다.</p>\n<p><a href=\"https://developer.mongodb.com/quickstart/bson-data-types-objectid/\">https://developer.mongodb.com/quickstart/bson-data-types-objectid/</a>\nObjectId는 세 영역으로 나눠져 있습니다. 각각 첫 4 byte는 UNIX Timestamp 정보를 담고있고 다음 5 byte는 랜덤한 값으로 이루어져 있는데 3 byte와 2 byte로 나뉩니다. 첫 3 byte는 클라이언트의 머신별로 고유한 키(mac 주소나 ip 주소)를 이용하여 랜덤 값을 만들어 사용한다. 다음 2 byte는 process id를 이용합니다. 5 byte를 채운 후 마지막 2 byte는 Auto Increment되는 값으로 구성됩니다.</p>\n<p>이쯤되면 ObjectId가 충돌날 가능성이 어느 정도일지 궁금할 수 있습니다. 충돌이 발생하려면 같은 시간, 기기에서 만들어낸 해시 값이 일치하고 우연히 같은 process id를 가지고 있으며 정말 우연히 increase된 count가 일치해야 합니다. 확률은 계산해보지 않았지만 거의 충돌날 일은 없을 것으로 보입니다.</p>\n<p>다음으로 MongoDB 데이터 조작에 대해서 알아보면, MongoDB와 같은 NoSQL은 이름처럼 SQL을 사용하지 않고 별도로 제공하는 API를 통해 데이터를 건들 수 있습니다. MongoDB의 경우 자바스크립트 엔진 SpiderMonkey를 사용하여 API를 제공합니다. 따라서 자바스크립트를 조금은 알아야 합니다.</p>\n<h3 id=\"insert-query\" style=\"position:relative;\"><a href=\"#insert-query\" aria-label=\"insert query permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Insert Query</h3>\n<p>데이터를 삽입하는 쿼리를 보면 SQL과는 모습이 많이 다른 것을 알 수 있습니다. 마치 클래스에서 메서드를 통해 실행하는 모습인데, 이처럼 MongoDB는 객체 조작을 통해 데이터를 관리할 수 있습니다.</p>\n<h3 id=\"base\" style=\"position:relative;\"><a href=\"#base\" aria-label=\"base permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BASE</h3>\n<p>BASE는 ACID와 대립되는 개념으로 다음 세 가지로 이뤄져 있습니다.</p>\n<ul>\n<li>Basically Avaliable\n기본적으로 언제든지 사용할 수 있다는 의미를 가지고 있습니다.\n즉, 가용성이 필요하다는 뜻을 가집니다.</li>\n<li>Soft state\n외부의 개입이 없어도 정보가 변경될 수 있다는 의미를 가지고 있습니다.\n네트워크 파티션 등 문제가 발생되어 일관성(Consistency)이 유지되지 않는 경우 일관성을 위해 데이터를 자동으로 수정합니다.</li>\n<li>Eventually consistent\n일시적으로 일관적이지 않은 상태가 되어도 일정 시간 후 일관적인 상태가 되어야 한다는 의미를 가지고 있습니다.\n장애 발생시 일관성을 유지하기 위한 이벤트를 발생시킵니다.\n이처럼 BASE는 ACID와는 다르게 일관성을 어느정도 포기하고 가용성을 우선시합니다. 즉, 데이터가 조금 맞지 않더라도 일단 내려준다는 뜻입니다.</li>\n</ul>\n<h3 id=\"acid\" style=\"position:relative;\"><a href=\"#acid\" aria-label=\"acid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ACID?</h3>\n<p>마치 MongoDB는 전혀 ACID하지 않다는 식으로 글을 썼지만 사실 MongoDB는 트랜젝션을 제공합니다. 아직 ACID하지 않을 때도 Single-Document Transaction을 제공하고 MongoDB 4.0부터는 Multi-Document Transaction을 제공함으로서 ACID를 충족했습니다. 이후 MongoDB 4.2에서 Shard Cluster Transacion을 제공하면서 분산 트랜젝션까지 가능해졌습니다.</p>\n<blockquote>\n<p>MongoDB는 분산 시스템이 핵심이다.</p>\n</blockquote>\n<p>이번엔 MongoDB의 분산 시스템에 대해서 다뤄보면, MongoDB에서 분산 시스템은 기본으로 깔리고 들어가는만큼 반드시 알고 넘어가야 합니다.</p>\n<p>Thinking face가 생각한 것 처럼 웹 서비스가 발전하면서 데이터 무결성을 버리면서까지 더 많은 데이터, 빠른 성능, 수평 확장이 필요한 데이터베이스가 필요해졌습니다. 그런 요구 사항으로 인해 MongoDB가 탄생했습니다.</p>","frontmatter":{"date":"November 02, 2022","title":"[CS] MongoDB","categories":"CS","author":"hoonloper","emoji":"💾"},"fields":{"slug":"/cs/mongodb/"}},"prev":{"id":"73f71655-e393-59d5-9492-7e5f7b5b1290","html":"<p>DFS와 BFS의 개념을 잡기 위해 풀어봤습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> readline <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'readline'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">createInterface</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> input <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nreadline\n  <span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'line'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">line</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> input<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'close'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">N</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">V</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>arr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> el<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 그래프 배열을 생성한다.</span>\n    <span class=\"token keyword\">const</span> graph <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// input으로 주어진 좌표값에 1을 지정해 그래프를 그려준다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      graph<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// DFS를 순회할 때 방문 여부를 저장한다.</span>\n    <span class=\"token keyword\">const</span> dfsVisited <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> <span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// DFS 결과가 담길 배열이다.</span>\n    <span class=\"token keyword\">const</span> dfsResult <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">DFS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 방문한 이력이 있으면 return한다.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dfsVisited<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 방문한 이력이 없으면 방문 이력을 남기고 결과에 node값을 저장한다.</span>\n      dfsVisited<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      dfsResult<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// graph에 위치하고 방문하지 않았으면 순회를 돈다.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>dfsVisited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token constant\">DFS</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token constant\">DFS</span><span class=\"token punctuation\">(</span><span class=\"token constant\">V</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// BFS 방문 여부가 담길 배열이다.</span>\n    <span class=\"token keyword\">const</span> bfsVisited <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> <span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> bfsResult <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">V</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// queue에 초기 정점을 넣어준다.</span>\n    <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">V</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// queue에서 첫번째 노드를 꺼내 저장한다.</span>\n      <span class=\"token keyword\">const</span> node <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 방문 이력을 저장한다.</span>\n      bfsVisited<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// graph에 위치하고 방문하지 않았으면 순회를 돈다.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>bfsVisited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          bfsVisited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n          bfsResult<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 결과값 출력</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dfsResult<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bfsResult<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"November 12, 2022","title":"[알고리즘] DFS와 BFS(백준1260) - DFS, BFS","categories":"알고리즘","author":"hoonloper","emoji":"🧠"},"fields":{"slug":"/algorithm/dfs-bfs/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/books/core-javascript-1/","nextSlug":"/cs/mongodb/","prevSlug":"/algorithm/dfs-bfs/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}