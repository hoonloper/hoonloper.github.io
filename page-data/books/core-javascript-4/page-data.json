{"componentChunkName":"component---src-templates-blog-template-js","path":"/books/core-javascript-4/","result":{"data":{"cur":{"id":"2c7a522e-748a-5847-aa12-6c16bda14de2","html":"<h3 id=\"콜백함수\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98\" aria-label=\"콜백함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백함수</h3>\n<p>콜백함수는 다른 코드의 인자로 넘겨주는 함수이며, 제어권과 관련이 깊습니다.</p>\n<p>콜백함수의 this도 전역공간을 가리킵니다.</p>\n<p>그리고 당연한 말이지만 콜백함수도 함수입니다. 객체의 메서드를 전달하더라도 함수로서 호출됩니다.</p>\n<p><strong>콜백지옥</strong>은 콜백ㄷ 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상으로, 자바스크립트에서 흔히 발생하는 문제입니다.</p>\n<p>동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식이며, 비동기적인 코드는 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어갑니다. <strong>CPU에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다.</strong>\n<strong>별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드입니다.</strong></p>\n<h3 id=\"클로저\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80\" aria-label=\"클로저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저</h3>\n<p>클로저는 <strong>여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성</strong>입니다.</p>\n<p>클로저에 대한 소개들입니다.</p>\n<ul>\n<li>자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수</li>\n<li>함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것</li>\n<li>함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수</li>\n<li>이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수</li>\n<li>자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합</li>\n<li>로컬 변수를 참조하고 있는 함수 내의 함수</li>\n<li>자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수</li>\n</ul>\n<p>MDN에서는 클로저에 대해 <strong>클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상</strong>으로 정의합니다.</p>\n<blockquote>\n<p>클로저란 어떤 함수A에서 선언한 변수 a를 참조하는 내부 함수B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상</p>\n</blockquote>\n<p>클로저 함수의 참조 카운트를 0으로 만들면 가비지 컬렉터가 결국 수거해 가는데 참조 카운트를 0 으로 만들기 위해서는 식별자에 참조형이 아닌 기본 데이터(null, undefined)를 할당하면 됩니다.</p>\n<h3 id=\"클로저-정리\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%A0%95%EB%A6%AC\" aria-label=\"클로저 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저 정리</h3>\n<ul>\n<li>클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상입니다.</li>\n<li>내부함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐 아니라 콜백으로 전달하는 경우도 포함됩니다.</li>\n<li>클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있습니다.</li>\n<li>클로저는 다양한 곳에서 활용할 수 있는 중요한 개념입니다.</li>\n</ul>","excerpt":"콜백함수 콜백함수는 다른 코드의 인자로 넘겨주는 함수이며, 제어권과 관련이 깊습니다. 콜백함수의 this도 전역공간을 가리킵니다. 그리고 당연한 말이지만 콜백함수도 함수입니다. 객체의 메서드를 전달하더라도 함수로서 호출됩니다. 콜백지옥은 콜백ㄷ 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상으로, 자바스크립트에서 흔히 발생하는 문제입니다. 동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식이며, 비동기적인 코드는 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어갑니다. CPU에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다.\n별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드입니다. 클로저 클로저는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다. 클로저에 대한 소개들입니다. 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수 함수가 …","frontmatter":{"date":"December 03, 2022","title":"[Core-Javascript] 네 번째 팁 모음","categories":"교재","author":"hoonloper","emoji":"📖"},"fields":{"slug":"/books/core-javascript-4/"}},"next":{"id":"f1a72c63-1c6c-515f-a84d-cb07110b913b","html":"<h3 id=\"this\" style=\"position:relative;\"><a href=\"#this\" aria-label=\"this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>this</h3>\n<p>자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정됩니다. 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 <strong>this는 함수를 호출할 때 결정</strong>된다고 할 수 있습니다.</p>\n<p><strong>전역 공간에서의 this</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span> <span class=\"token operator\">===</span> window<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token keyword\">this</span> <span class=\"token operator\">===</span> global<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>전역 공간에 변수를 할당하면 window.변수(or global)와 this.변수 모두 동일한 값이 출력되는데 그 이유는 <strong>자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티</strong>로서 동작하기 때문입니다.</p>\n<blockquote>\n<p>전역 변수를 선언하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당한다.</p>\n</blockquote>\n<p><strong>메서드로서 호출할 때 그 메서드 내부에서의 this</strong>\n프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 <strong>독립성</strong>에 있습니다.</p>\n<p><strong>함수는 그 자체로 독립적인 기능을 수행</strong>하는 반면, <strong>메서드는 자신을 호출한 대상 객체에 관한 동작을 수행</strong>합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Window { ... } 1</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">method</span><span class=\"token operator\">:</span> func<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { method: f } 2</span></code></pre></div>\n<p>메서드 내부에서의 this는 점 표기법 마지막 점 앞에 명시된 객체가 곧 this가 됩니다.</p>\n<h3 id=\"함수로서-호출할-때-그-함수-내부에서의-this\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98%EB%A1%9C%EC%84%9C-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C-%EA%B7%B8-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EC%9D%98-this\" aria-label=\"함수로서 호출할 때 그 함수 내부에서의 this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수로서 호출할 때 그 함수 내부에서의 this</h3>\n<p>어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않습니다. 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라보기 때문에 함수에서의 this는 전역 객체를 가리킵니다.</p>\n<p>변수를 사용하면 this를 우회할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">outer</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">innerFunc1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Window { ... }</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">innerFunc1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">var</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">innerFunc2</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">innerFunc2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>this를 바인딩하지 않는 함수</strong>\nES6에서는 함수 내부에서 **this가 전역 객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수(arrow function)**을 도입했습니다.</p>\n<p>화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어 상위 스코프의 this를 그대로 활용할 수 있습니다. 즉 우회법이 필요 없어집니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">outer</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">innerFunc</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { outer: f }</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">innerFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"콜백-함수-호출-시-그-함수-내부에서의-this\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EC%8B%9C-%EA%B7%B8-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EC%9D%98-this\" aria-label=\"콜백 함수 호출 시 그 함수 내부에서의 this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백 함수 호출 시 그 함수 내부에서의 this</h3>\n<p>콜백 함수에서의 this는 ‘무조건 이거다!’라고 정의할 수 없습니다. 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, <strong>특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역 객체를 바라봅니다.</strong></p>\n<h3 id=\"생성자-함수-내부에서의-this\" style=\"position:relative;\"><a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EC%9D%98-this\" aria-label=\"생성자 함수 내부에서의 this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생성자 함수 내부에서의 this</h3>\n<p>생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수입니다. 객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라고 합니다.</p>\n<p>프로그래밍적으로 ‘생성자’는 구체적인 인스턴스를 만들기 위한 일종의 틀입니다.</p>\n<h3 id=\"명시적으로-this를-바인딩하는-방법\" style=\"position:relative;\"><a href=\"#%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-this%EB%A5%BC-%EB%B0%94%EC%9D%B8%EB%94%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"명시적으로 this를 바인딩하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명시적으로 this를 바인딩하는 방법</h3>\n<ul>\n<li>func.call(): 객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있습니다.</li>\n<li>func.apply(): call 메서드와 동일하지만 apply는 두번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있습니다.</li>\n</ul>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<ul>\n<li>전역 공간에서의 this는 전역객체(브라우저 window, Node.js global)를 참조합니다.</li>\n<li>어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 주체(메서드명 앞의 객체)를 참조합니다.</li>\n<li>어떤 함수를 함수로서 호출한 경우 this는 전역 객체를 참조합니다. 메서드의 내부 함수에서도 같습니다.</li>\n<li>콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역 객체를 참조합니다.</li>\n<li>생성자 함수에서의 this는 생성될 인스턴스를 참조합니다.</li>\n</ul>","frontmatter":{"date":"November 26, 2022","title":"[Core-Javascript] 세 번째 팁 모음","categories":"교재","author":"hoonloper","emoji":"📖"},"fields":{"slug":"/books/core-javascript-3/"}},"prev":{"id":"dc1dbba9-e3c6-5d7a-aff8-eee071dcfb8e","html":"<h3 id=\"프로토타입\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\" aria-label=\"프로토타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로토타입</h3>\n<p>자바스크립트는 <strong>프로토타입 기반 객체지향 언어</strong>입니다. 클래스 기반 언어에서는 <strong>상속</strong>을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형으로 삼고 이를 복제(참조)함으로써 상속과 비슷한 효과를 얻습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>어떤 생성자 함수(constructor)를 new 연산자와 함께 호출하면 Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance가 생성됩니다. 이때 instance에는 <code class=\"language-text\">__proto__</code>라는 프로퍼티가 자동으로 부여되는데, 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조합니다.</p>\n<p>prototype 객체 내부에서 인스턴스가 사용할 메서드를 저장합니다. 그러면 인스턴스에서도 숨겨진 프로퍼티인 <code class=\"language-text\">__proto__</code>를 통해 이 메서드들에 접근할 수 있게 됩니다.</p>\n<p><code class=\"language-text\">__proto__</code>는 생략 가능한 프로퍼티입니다. 생략 가능하도록 정의되어 있으며 이 정의를 바탕으로 자바스크립트의 전체 구조가 구성됐다고 볼 수 있습니다.</p>\n<blockquote>\n<p><code class=\"language-text\">__proto__</code> 프로퍼티는 생략 가능하도록 구현돼 있기 때문에 생성자 함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게 됩니다.</p>\n</blockquote>\n<h3 id=\"array\" style=\"position:relative;\"><a href=\"#array\" aria-label=\"array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array</h3>\n<p>array는 인스턴스를 생성하든, 그냥 배열 리터럴를 생성하든 instance가 만들어집니다. 이 인스턴스의 <code class=\"language-text\">__proto__</code>는 Array.prototype을 참조하는데, <code class=\"language-text\">__proto__</code>는 생략되기에 인스턴스가 push, pop, forEach 등 메서드를 마치 자신의 것처럼 호출할 수 있습니다. 한편 Array의 prototype 프로퍼티 내부에 있지 않은 from, isArray 등의 메서드들은 인스턴스가 직접 호출할 수 없으며 Array 생성자 함수에서 직접 접근해야 실행이 가능합니다.</p>\n<h3 id=\"constructor\" style=\"position:relative;\"><a href=\"#constructor\" aria-label=\"constructor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>constructor</h3>\n<p>constructor 프로퍼티는 원래의 생성자 함수(자기자신)을 참조합니다. 자신을 참조하는 프로퍼티를 굳이 뭐하러 가지고 있을까 싶지만, 이 역시 인스턴스와의 관계에 있어서 필요한 정보입니다. 인스턴스로부터 그 원형이 무엇인지를 알 수 있는 수단이기 때문입니다.</p>\n<p>다양한 constructor 접근 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">Person</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> p1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">p1Proto<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람3'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">p1<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람4'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p5 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">p1<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람5'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"프로토타입-체인\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"프로토타입 체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로토타입 체인</h3>\n<p>프로퍼티 내부에 다시 프로퍼티가 연쇄적으로 이어진 것을 프로토타입 체인이라 하고, 이 체인을 따라가며 검색하는 것을 포로토타입 체이닝이라 합니다.</p>\n<h3 id=\"클래스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스</h3>\n<p>자바스크립트는 프로토타입 기반 언어라서 ‘상속’의 개념이 존재하지 않습니다. ES6에서 클래스 문법이 추가됐습니다만 ES6의 클래스에서도 일정 부분은 프로토타입을 활용하고 있기 때문입니다.</p>\n<p>자바스크립트는 프로토타입 기반 언어이므로 클래스의 개념이 존재하지 않지만 프로토타입을 일반적인 의미에서의 클래스 관점에서 접근해보면 비슷하게 해석할 수 있는 요소가 있습니다.</p>\n<p>생성자 함수 Array를 new 연산자와 함께 호출하면 인스턴스가 생성됩니다. 이때 Array를 일종의 클래스라고 하면, Array의 prototype 객체 내부 요소들이 인스턴스에 상속된다고 볼 수 있습니다. 엄밀히는 상속이 아닌 프로토타입 체이닝에 의한 참조지만 결과적으로는 동일하게 동작하므로 이렇게 이해해도 무방합니다. 한편 Array 내부 프로퍼티들 중 prototype 프로퍼티를 제외한 나머지는 인스턴스에 상속되지 않습니다.</p>\n<blockquote>\n<p>인스턴스에서 직접 접근할 수 없는 메서드를 스태틱 메서드라고 합니다.</p>\n</blockquote>\n<p>클래스(prototype)가 구체적인 데이터를 지니지 않게 하는 방법은 여러 가지가 있는데, 그 중 가장 쉬운 방법은 일단 만들고 나서 프로퍼티들을 일일이 지우고 더는 새로운 프로퍼티를 추가할 수 없게 하는 것입니다.</p>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<p>자바스크립트는 프로토타입 기반 언어라서 클래스 및 상속 개념은 존재하지 않지만 프로토타입을 기반으로 클래스와 비슷하게 동작하게끔 하는 다양한 기법들이 도입돼 왔습니다.</p>\n<p>클래스는 어떤 사물의 공통 속성을 모아 정의한 추상적인 개념이고, 인스턴스는 클래스의 속성을 지니는 구체적인 사례입니다. 상위 클래스(superclass)의 조건을 충족하면서 더욱 구체적인 조건이 추가된 것을 하위 클래스(subclass)라고 합니다.</p>\n<p>클래스의 prototype 내부에 정의된 메서드를 프로토타입 메서드라고 하며, 이들은 인스턴스가 마치 자신의 것처럼 호출할 수 있습니다. 한편 클래스(생성자 함수)에 직접 정의한 메서드를 스태틱 메서드라고 하며, 이들은 인스턴스가 직접 호출할 수 없고 클래스(생성자 함수)에 의해서만 호출할 수 있습니다.</p>","frontmatter":{"date":"December 10, 2022","title":"[Core-Javascript] 마지막 팁 모음","categories":"교재","author":"hoonloper","emoji":"📖"},"fields":{"slug":"/books/core-javascript-final/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/books/core-javascript-4/","nextSlug":"/books/core-javascript-3/","prevSlug":"/books/core-javascript-final/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}