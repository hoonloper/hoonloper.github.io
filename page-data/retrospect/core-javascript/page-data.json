{"componentChunkName":"component---src-templates-blog-template-js","path":"/retrospect/core-javascript/","result":{"data":{"cur":{"id":"4d784df7-196b-5f6e-83d5-0262530b96f9","html":"<p>안녕하세요. 이번에는 코어 자바스크립트 서적 정독을 기념한 짧은 회고를 작성해 보려 합니다.</p>\n<blockquote>\n<p>오랜만에 책을 정독하느라 힘이드네요 😅</p>\n</blockquote>\n<p>처음 서적을 읽게 된 계기는 자바스크립트를 주 언어로 사용하는 개발자가 자바스크립트에 대해 제대로 알지 못한다면 정말 개발자라 할 수 있을까에 대한 의문에서 시작됐습니다. 항상 성장을 위해 달려가지만 기본기가 다져져있지 않다면 성장의 한계점은 어느순간 다가올 것이라는 생각에 기본기 복습을 위한 정독이었습니다.</p>\n<p>코어 자바스크립트를 정독하면서 알고 있던 자바스크립트 지식은 단단해짐을 느꼈고 제대로 알지 못하거나 모르는 지식들을 배울 때는 뿌듯함과 성장함을 느꼈습니다. 사실 코어 자바스크립트 서적을 다 읽고나니 전문가가 아닌 초보자들에게 길잡이를 해주려는 의도로 만든 서적임을 많이 느껴 제대로 자바스크립트 기본기를 다지려면 모던 자바스크립트 딥다이브를 정독해야 함을 다시금 떠올렸습니다..</p>\n<p>저는 초보자이기에 초보자 시점에서도 쉽게 읽을 수 있는 서적이라 편했고 자바스크립트 언어로 개발을 시작하려는 분들도 보다 가벼운 마음으로 한스푼 깊게 파볼 수 있는 좋은 서적인 것 같습니다.</p>\n<p>이번 교재를 기반으로 모던 자바스크립트 딥 다이브를 정독하려 하는데 1,000 페이지가 넘는 책이다보니 아마 정독이 끝날 때쯤 얻은 꿀팁들을 정리하지 않을까 라고 조심스레 예상해봅니다.</p>\n<p>긴 글 읽어주셔서 감사하며 좋은 하루 보내세요 🙇</p>","excerpt":"안녕하세요. 이번에는 코어 자바스크립트 서적 정독을 기념한 짧은 회고를 작성해 보려 합니다. 오랜만에 책을 정독하느라 힘이드네요 😅 처음 서적을 읽게 된 계기는 자바스크립트를 주 언어로 사용하는 개발자가 자바스크립트에 대해 제대로 알지 못한다면 정말 개발자라 할 수 있을까에 대한 의문에서 시작됐습니다. 항상 성장을 위해 달려가지만 기본기가 다져져있지 않다면 성장의 한계점은 어느순간 다가올 것이라는 생각에 기본기 복습을 위한 정독이었습니다. 코어 자바스크립트를 정독하면서 알고 있던 자바스크립트 지식은 단단해짐을 느꼈고 제대로 알지 못하거나 모르는 지식들을 배울 때는 뿌듯함과 성장함을 느꼈습니다. 사실 코어 자바스크립트 서적을 다 읽고나니 전문가가 아닌 초보자들에게 길잡이를 해주려는 의도로 만든 서적임을 많이 느껴 제대로 자바스크립트 기본기를 다지려면 모던 자바스크립트 딥다이브를 정독해야 함을 다시금 떠올렸습니다.. 저는 초보자이기에 초보자 시점에서도 쉽게 읽을 수 있는 서적이라 편했…","frontmatter":{"date":"December 11, 2022","title":"[회고] Core-Javascript 정독 회고","categories":"회고","author":"hoonloper","emoji":"👣"},"fields":{"slug":"/retrospect/core-javascript/"}},"next":{"id":"dc1dbba9-e3c6-5d7a-aff8-eee071dcfb8e","html":"<h3 id=\"프로토타입\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\" aria-label=\"프로토타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로토타입</h3>\n<p>자바스크립트는 <strong>프로토타입 기반 객체지향 언어</strong>입니다. 클래스 기반 언어에서는 <strong>상속</strong>을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형으로 삼고 이를 복제(참조)함으로써 상속과 비슷한 효과를 얻습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>어떤 생성자 함수(constructor)를 new 연산자와 함께 호출하면 Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance가 생성됩니다. 이때 instance에는 <code class=\"language-text\">__proto__</code>라는 프로퍼티가 자동으로 부여되는데, 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조합니다.</p>\n<p>prototype 객체 내부에서 인스턴스가 사용할 메서드를 저장합니다. 그러면 인스턴스에서도 숨겨진 프로퍼티인 <code class=\"language-text\">__proto__</code>를 통해 이 메서드들에 접근할 수 있게 됩니다.</p>\n<p><code class=\"language-text\">__proto__</code>는 생략 가능한 프로퍼티입니다. 생략 가능하도록 정의되어 있으며 이 정의를 바탕으로 자바스크립트의 전체 구조가 구성됐다고 볼 수 있습니다.</p>\n<blockquote>\n<p><code class=\"language-text\">__proto__</code> 프로퍼티는 생략 가능하도록 구현돼 있기 때문에 생성자 함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게 됩니다.</p>\n</blockquote>\n<h3 id=\"array\" style=\"position:relative;\"><a href=\"#array\" aria-label=\"array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array</h3>\n<p>array는 인스턴스를 생성하든, 그냥 배열 리터럴를 생성하든 instance가 만들어집니다. 이 인스턴스의 <code class=\"language-text\">__proto__</code>는 Array.prototype을 참조하는데, <code class=\"language-text\">__proto__</code>는 생략되기에 인스턴스가 push, pop, forEach 등 메서드를 마치 자신의 것처럼 호출할 수 있습니다. 한편 Array의 prototype 프로퍼티 내부에 있지 않은 from, isArray 등의 메서드들은 인스턴스가 직접 호출할 수 없으며 Array 생성자 함수에서 직접 접근해야 실행이 가능합니다.</p>\n<h3 id=\"constructor\" style=\"position:relative;\"><a href=\"#constructor\" aria-label=\"constructor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>constructor</h3>\n<p>constructor 프로퍼티는 원래의 생성자 함수(자기자신)을 참조합니다. 자신을 참조하는 프로퍼티를 굳이 뭐하러 가지고 있을까 싶지만, 이 역시 인스턴스와의 관계에 있어서 필요한 정보입니다. 인스턴스로부터 그 원형이 무엇인지를 알 수 있는 수단이기 때문입니다.</p>\n<p>다양한 constructor 접근 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">Person</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> p1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">p1Proto<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람3'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">p1<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람4'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p5 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">p1<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사람5'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"프로토타입-체인\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"프로토타입 체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로토타입 체인</h3>\n<p>프로퍼티 내부에 다시 프로퍼티가 연쇄적으로 이어진 것을 프로토타입 체인이라 하고, 이 체인을 따라가며 검색하는 것을 포로토타입 체이닝이라 합니다.</p>\n<h3 id=\"클래스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스</h3>\n<p>자바스크립트는 프로토타입 기반 언어라서 ‘상속’의 개념이 존재하지 않습니다. ES6에서 클래스 문법이 추가됐습니다만 ES6의 클래스에서도 일정 부분은 프로토타입을 활용하고 있기 때문입니다.</p>\n<p>자바스크립트는 프로토타입 기반 언어이므로 클래스의 개념이 존재하지 않지만 프로토타입을 일반적인 의미에서의 클래스 관점에서 접근해보면 비슷하게 해석할 수 있는 요소가 있습니다.</p>\n<p>생성자 함수 Array를 new 연산자와 함께 호출하면 인스턴스가 생성됩니다. 이때 Array를 일종의 클래스라고 하면, Array의 prototype 객체 내부 요소들이 인스턴스에 상속된다고 볼 수 있습니다. 엄밀히는 상속이 아닌 프로토타입 체이닝에 의한 참조지만 결과적으로는 동일하게 동작하므로 이렇게 이해해도 무방합니다. 한편 Array 내부 프로퍼티들 중 prototype 프로퍼티를 제외한 나머지는 인스턴스에 상속되지 않습니다.</p>\n<blockquote>\n<p>인스턴스에서 직접 접근할 수 없는 메서드를 스태틱 메서드라고 합니다.</p>\n</blockquote>\n<p>클래스(prototype)가 구체적인 데이터를 지니지 않게 하는 방법은 여러 가지가 있는데, 그 중 가장 쉬운 방법은 일단 만들고 나서 프로퍼티들을 일일이 지우고 더는 새로운 프로퍼티를 추가할 수 없게 하는 것입니다.</p>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<p>자바스크립트는 프로토타입 기반 언어라서 클래스 및 상속 개념은 존재하지 않지만 프로토타입을 기반으로 클래스와 비슷하게 동작하게끔 하는 다양한 기법들이 도입돼 왔습니다.</p>\n<p>클래스는 어떤 사물의 공통 속성을 모아 정의한 추상적인 개념이고, 인스턴스는 클래스의 속성을 지니는 구체적인 사례입니다. 상위 클래스(superclass)의 조건을 충족하면서 더욱 구체적인 조건이 추가된 것을 하위 클래스(subclass)라고 합니다.</p>\n<p>클래스의 prototype 내부에 정의된 메서드를 프로토타입 메서드라고 하며, 이들은 인스턴스가 마치 자신의 것처럼 호출할 수 있습니다. 한편 클래스(생성자 함수)에 직접 정의한 메서드를 스태틱 메서드라고 하며, 이들은 인스턴스가 직접 호출할 수 없고 클래스(생성자 함수)에 의해서만 호출할 수 있습니다.</p>","frontmatter":{"date":"December 10, 2022","title":"[Core-Javascript] 마지막 팁 모음","categories":"서적","author":"hoonloper","emoji":"📖"},"fields":{"slug":"/books/core-javascript-final/"}},"prev":{"id":"b8a73d61-3b20-56e4-9eb7-9d95034aea77","html":"<p>누적합(Prefix Sum) 알고리즘을 활용하는 백준 문제를 풀어봤습니다.</p>\n<p>저는 누적합 알고리즘을 처음 접했기에 알고리즘에 대한 설명을 들어도 이해가 어려워서 따로 정리한 포스트입니다!</p>\n<blockquote>\n<p>누적합이란 수열 An에 대해서 각 인덱스까지의 구간의 합을 구하는 것을 누적합이라 합니다.</p>\n</blockquote>\n<p>그럼 누적합은 어떻게 구할 수 있을까요?</p>\n<p>배열의 [A ~ B] 범위의 구간 합을 구하고자 할 때, 누적합 배열을 구한 후 B까지의 누적합에서 A-1까지의 누적합을 빼주면 구간의 합을 구할 수 있습니다.</p>\n<p><strong>처음 코드</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 입력 생략</span>\nrl<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'line'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">line</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  input<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'close'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>first<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>other<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> el<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">+</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> psum <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    psum<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> psum<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> x <span class=\"token keyword\">of</span> other<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      sum <span class=\"token operator\">+=</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>초기 문제를 분석하고 풀이를 할 때 이중 for문을 사용해 구간의 합을 구했습니다. 하지만 이 풀이로 제출을 했더니 시간 초과가 나오더군요. 그래서 Prefix Sum 알고리즘을 찾게 되었고 시간 초과를 피할 수 있었습니다.</p>\n<p><strong>정답 코드</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">rl<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'line'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">line</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  input<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'close'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> answer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">N</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>other<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> el<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">+</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> psum <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> <span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    psum<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> psum<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> other<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    answer<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>psum<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> psum<span class=\"token punctuation\">[</span>start <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>answer<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>코드설명\n<code class=\"language-text\">const psum = Array.from({ length: N + 1 }, () => 0);</code> prefix sum 배열을 새로 생성하는데 주어진 N에서 1을 더해주는 이유는 인덱스로 접근하기 위함입니다.\n<code class=\"language-text\">// psum : [0, 0, 0, 0, 0, 0]</code></p>\n<p><code class=\"language-text\">for (let i = 0; i &lt; N; i++) { psum[i + 1] = psum[i] + arr[i]; }</code> 주어진 배열 요소들의 누적합을 psum 인덱스에 저장합니다.</p>\n<p><code class=\"language-text\">for (const [start, end] of other) { answer.push(psum[end] - psum[start - 1]); }</code> 주어진 시작 인덱스와 끝 인덱스를 공식에 맞게 구한 후 정답 배열에 넣습니다.</p>\n<blockquote>\n<p>공식 prefixSum의 End index - prefixSum의 Start index - 1</p>\n</blockquote>\n<p>이후 정답 배열의 로그를 찍어보면 정상적으로 정답을 확인할 수 있고 시간 초과 또한 면할 수 있었습니다. 아주 기초적인 문제이지만 많이 돌아온만큼 응용 문제들을 마주쳐도 흔들리지 않는 탄탄한 기본기를 갖춰야 됨을 느꼈습니다.</p>","frontmatter":{"date":"December 17, 2022","title":"[알고리즘] 구간 합 구하기4(백준11659) - 누적합(Prefix Sum)","categories":"알고리즘","author":"hoonloper","emoji":"🧠"},"fields":{"slug":"/algorithm/prefix-sum-1/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/retrospect/core-javascript/","nextSlug":"/books/core-javascript-final/","prevSlug":"/algorithm/prefix-sum-1/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}