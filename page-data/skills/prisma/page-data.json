{"componentChunkName":"component---src-templates-blog-template-js","path":"/skills/prisma/","result":{"data":{"cur":{"id":"9c3f3a71-ad7c-5f99-8d95-14b528e0b078","html":"<p><img src=\"https://user-images.githubusercontent.com/78959175/190888255-f601e5a6-41b1-4c5c-bf09-62db4e25ccda.png\" alt=\"111\"></p>\n<p>소규모 프로젝트의 Back-End 개발을 시작했습니다.</p>\n<p>Nest X TypeORM 조합만 사용해왔던 저는 새로운 기술을 배워보고 싶어 평소 흥미롭게 바라보던 Prisma를 적용해보기로 결정합니다.</p>\n<p>공식 문서에서 설명하는 Prisma는 이렇습니다.</p>\n<h2 id=\"프리즈마란\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EB%9E%80\" aria-label=\"프리즈마란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마란?</h2>\n<p>Prisma는 오픈 소스 차세대 ORM입니다. 다음 부분으로 구성됩니다.</p>\n<ul>\n<li>Prisma Client : Node.js 및 TypeScript를 위한 자동 생성 및 유형 안전 쿼리 빌더</li>\n<li>Prisma Migrate : 마이그레이션 시스템</li>\n<li>Prisma Studio : 데이터베이스의 데이터를 보고 편집하는 GUI</li>\n<li>Prisma Client는 모든 Node.js(지원 버전) 또는 TypeScript 백엔드 애플리케이션(서버리스 애플리케이션 및 마이크로서비스 포함)에서 사용할 수 있습니다.</li>\n</ul>\n<h2 id=\"프리즈마의-작동-방식\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\" aria-label=\"프리즈마의 작동 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마의 작동 방식</h2>\n<p><strong>RDBMS</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">datasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel Post {\n  id        Int     @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean @default(false)\n  author    User?   @relation(fields: [authorId], references: [id])\n  authorId  Int?\n}\n\nmodel User {\n  id    Int     @id @default(autoincrement())\n  email String  @unique\n  name  String?\n  posts Post[]\n}</code></pre></div>\n<p><strong>NoSQL</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">datasource db {\n  provider = \"mongodb\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel Post {\n  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n  title     String\n  content   String?\n  published Boolean @default(false)\n  author    User?   @relation(fields: [authorId], references: [id])\n  authorId  String  @db.ObjectId\n}\n\nmodel User {\n  id    String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n  email String  @unique\n  name  String?\n  posts Post[]\n}</code></pre></div>\n<p>이 스키마에서는 세 가지를 구성합니다.</p>\n<ul>\n<li>Data source : 데이터베이스 연결을 지정합니다(환경 변수를 통해).</li>\n<li>Generator : Prisma Client를 생성하고자 함을 나타냅니다.</li>\n<li>Data model : 애플리케이션 모델을 정의합니다.</li>\n</ul>\n<h3 id=\"prisma-client로-데이터베이스에-접근하기\" style=\"position:relative;\"><a href=\"#prisma-client%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0\" aria-label=\"prisma client로 데이터베이스에 접근하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prisma Client로 데이터베이스에 접근하기</h3>\n<p>Prisma Client를 사용하는 첫 번째 단계는 @prisma/clientnpm 패키지를 설치하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install @prisma/client</code></pre></div>\n<p>@prisma/client패키지를 설치하면 prisma generatePrisma 스키마를 읽고 Prisma Client 코드를 생성 하는 명령이 호출됩니다.</p>\n<p>데이터 모델을 변경한 후 내부 코드가 DB에 업데이트 되도록 Prisma Client를 수동으로 다시 생성해야 합니다 .</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">prisma generate</code></pre></div>\n<p>Prisma Client가 생성되면 코드로 가져와서 데이터베이스에 쿼리를 보낼 수 있습니다.</p>","excerpt":"111 소규모 프로젝트의 Back-End 개발을 시작했습니다. Nest X TypeORM 조합만 사용해왔던 저는 새로운 기술을 배워보고 싶어 평소 흥미롭게 바라보던 Prisma를 적용해보기로 결정합니다. 공식 문서에서 설명하는 Prisma는 이렇습니다. 프리즈마란? Prisma는 오픈 소스 차세대 ORM입니다. 다음 부분으로 구성됩니다. Prisma Client : Node.js 및 TypeScript를 위한 자동 생성 및 유형 안전 쿼리 빌더 Prisma Migrate : 마이그레이션 시스템 Prisma Studio : 데이터베이스의 데이터를 보고 편집하는 GUI Prisma Client는 모든 Node.js(지원 버전) 또는 TypeScript 백엔드 애플리케이션(서버리스 애플리케이션 및 마이크로서비스 포함)에서 사용할 수 있습니다. 프리즈마의 작동 방식 RDBMS NoSQL 이 스키마에서는 세 가지를 구성합니다. Data source : 데이터베이스 연결을 지정합니다(환경 변…","frontmatter":{"date":"September 18, 2022","title":"[Skill] Prisma Proj-1","categories":"SKILL","author":"hoonloper","emoji":"🛠"},"fields":{"slug":"/skills/prisma/"}},"next":{"id":"41c752e0-b625-5b1f-8c43-5394bea5e4ae","html":"<p><strong>안녕하세요! 이번 포스트는 트랜잭션에 대해 알아보고 Dead lock이 무엇인지, 어떻게 하면 피할 수 있는지를 알아보겠습니다!</strong></p>\n<h2 id=\"트랜잭션이란\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%B4%EB%9E%80\" aria-label=\"트랜잭션이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션이란?</h2>\n<p>트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미합니다.</p>\n<h2 id=\"트랜잭션-사용-목적\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81\" aria-label=\"트랜잭션 사용 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 사용 목적</h2>\n<ul>\n<li>데이터 부정합 방지<br>\n데이터베이스 서버에 여러 개의 클라이언트가 동시에 액세스하는 경우<br>\n응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우</li>\n<li>데이터베이스의 완전성(integrity) 유지 확신<br>\n데이터베이스가 수행한 일부 쿼리가 남으면 안 됨<br>\nex) 송금시 한 계좌에서 인출 → 다른 계좌에서 입금 확인<br>\n트랜잭션은 서로 간섭하면 안 됨<br>\nex) 쿼리 하나 실패 → 데이터베이스 시스템이 전체 트랜잭션 또는 실패한 쿼리 롤백</li>\n<li>거래의 안정성 확보\n테이블에서 데이터를 읽어옴<br>\n→ 다른 테이블에 데이터 입력/갱신/삭제 도중 오류 발생<br>\n→ 모든 작업 원상태로 되돌림<br>\n처리 과정이 모두 성공했을 때만 최종적으로 데이터베이스에 반영</li>\n</ul>\n<h2 id=\"트랜잭션-특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%ED%8A%B9%EC%A7%95\" aria-label=\"트랜잭션 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 특징</h2>\n<ol>\n<li>트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위입니다.</li>\n<li>사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위입니다.</li>\n<li>하나의 트랜잭션은 Commit되거나 Rollback 됩니다.</li>\n</ol>\n<h2 id=\"트랜잭션의-4가지-성질\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%EC%84%B1%EC%A7%88\" aria-label=\"트랜잭션의 4가지 성질 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션의 4가지 성질</h2>\n<h3 id=\"atomicity원자성\" style=\"position:relative;\"><a href=\"#atomicity%EC%9B%90%EC%9E%90%EC%84%B1\" aria-label=\"atomicity원자성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Atomicity(원자성)</h3>\n<ol>\n<li>트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 합니다.</li>\n<li>트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 합니다.</li>\n</ol>\n<h3 id=\"consistency일관성\" style=\"position:relative;\"><a href=\"#consistency%EC%9D%BC%EA%B4%80%EC%84%B1\" aria-label=\"consistency일관성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Consistency(일관성)</h3>\n<ol>\n<li>트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환합니다.</li>\n<li>시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 합니다.</li>\n</ol>\n<h3 id=\"isolation독립성격리성\" style=\"position:relative;\"><a href=\"#isolation%EB%8F%85%EB%A6%BD%EC%84%B1%EA%B2%A9%EB%A6%AC%EC%84%B1\" aria-label=\"isolation독립성격리성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Isolation(독립성,격리성)</h3>\n<ol>\n<li>둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없습니다.</li>\n<li>수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없습니다.</li>\n</ol>\n<h3 id=\"durablility영속성지속성\" style=\"position:relative;\"><a href=\"#durablility%EC%98%81%EC%86%8D%EC%84%B1%EC%A7%80%EC%86%8D%EC%84%B1\" aria-label=\"durablility영속성지속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Durablility(영속성,지속성)</h3>\n<ol>\n<li>성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 합니다.</li>\n</ol>\n<p><a href=\"https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation\">격리 수준에 대해 정리된 블로그 글</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">💡 트랜잭션 격리수준(Transaction Isolation Level)\n특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지 결정하는 것\n\nREAD UNCOMMITTED\n어떤 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여짐\nREAD COMMITED\n어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회 가능\nREPEATABLE READ\n트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회 가능\nSERIALIZABLE\n트랜잭션이 특정 테이블을 조회하면 다른 트랜잭션은 그 테이블의 데이터를 추가/변경/삭제 불가능\n\n→ 아래로 갈수록 트랜잭션 간 고립 정도가 높아지고 성능이 떨어짐</code></pre></div>\n<h2 id=\"commit-rollback\" style=\"position:relative;\"><a href=\"#commit-rollback\" aria-label=\"commit rollback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit? Rollback?</h2>\n<h3 id=\"commit연산\" style=\"position:relative;\"><a href=\"#commit%EC%97%B0%EC%82%B0\" aria-label=\"commit연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit연산</h3>\n<ol>\n<li>Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산입니다.</li>\n</ol>\n<h3 id=\"rollback연산\" style=\"position:relative;\"><a href=\"#rollback%EC%97%B0%EC%82%B0\" aria-label=\"rollback연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rollback연산</h3>\n<ol>\n<li>Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산입니다.</li>\n<li>Rollback시에는 해당 트랜잭션을 재시작하거나 폐기합니다.</li>\n</ol>\n<h2 id=\"️-트랜잭션-사용시-주의사항\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"️ 트랜잭션 사용시 주의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⚠️ 트랜잭션 사용시 주의사항</h2>\n<ul>\n<li>트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋습니다. 즉 트랜잭션의 범위를 최소화하라는 의미입니다.</li>\n<li>일반적으로 데이터베이스 커넥션은 개수가 제한적입니다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 됩니다.</li>\n<li>그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있습니다.</li>\n</ul>","frontmatter":{"date":"September 17, 2022","title":"[CS] 트랜잭션(transaction)","categories":"CS","author":"hoonloper","emoji":"💾"},"fields":{"slug":"/cs/transaction/"}},"prev":{"id":"9b5ac0ef-fa15-5cd1-91cb-97cadfd4b6ab","html":"<p><img src=\"https://user-images.githubusercontent.com/78959175/190888255-f601e5a6-41b1-4c5c-bf09-62db4e25ccda.png\" alt=\"111\"></p>\n<h2 id=\"프리즈마를-선택해야-하는-이유\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"프리즈마를 선택해야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마를 선택해야 하는 이유</h2>\n<p>Prisma의 주요 목표는 데이터베이스 작업 시 애플리케이션 <strong>개발자의 생산성을 높이는 것입니다.</strong> 다음은 Prisma의 목표를 이루기 위한 몇 가지 예입니다.</p>\n<ul>\n<li>관계형 데이터를 매핑하는 대신 개체에서 생각하기</li>\n<li>복잡한 모델 객체를 피하기 위해 클래스가 아닌 쿼리</li>\n<li>데이터베이스 및 애플리케이션 모델을 위한 단일 정보 소스</li>\n<li>일반적인 함정과 반패턴을 방지하는 제약</li>\n<li>쉽게 만드는 추상화</li>\n<li>컴파일 시 유효성을 검사할 수 있는 유형 안전 데이터베이스 쿼리</li>\n<li>개발자가 앱의 중요한 부분에 집중할 수 있도록 상용구 감소</li>\n<li>문서를 찾을 필요 없이 코드 편집기에서 자동 완성</li>\n</ul>\n<h4 id=\"sql-orm-및-기타-데이터베이스-도구의-문제\" style=\"position:relative;\"><a href=\"#sql-orm-%EB%B0%8F-%EA%B8%B0%ED%83%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8F%84%EA%B5%AC%EC%9D%98-%EB%AC%B8%EC%A0%9C\" aria-label=\"sql orm 및 기타 데이터베이스 도구의 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL, ORM 및 기타 데이터베이스 도구의 문제</h4>\n<p>현재 Node.js 및 TypeScript 에코시스템에 존재하는 데이터베이스 도구의 주요 문제는 생산성과 제어 간의 주요 절충점이 필요하다는 것 입니다.</p>\n<h3 id=\"원시-sql-전체-제어-낮은-생산성\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%8B%9C-sql-%EC%A0%84%EC%B2%B4-%EC%A0%9C%EC%96%B4-%EB%82%AE%EC%9D%80-%EC%83%9D%EC%82%B0%EC%84%B1\" aria-label=\"원시 sql 전체 제어 낮은 생산성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원시 SQL: 전체 제어, 낮은 생산성</h3>\n<p>원시 SQL(예: 기본 pg또는 mysqlNode.js 데이터베이스 드라이버 사용)을 사용하면 데이터베이스 작업을 완전히 제어할 수 있습니다. 그러나 일반 SQL 문자열을 데이터베이스로 보내는 것이 번거롭고 많은 오버헤드(수동 연결 처리, 반복적인 상용구 등)가 수반되므로 생산성이 저하됩니다.</p>\n<p>이 접근 방식의 또 다른 주요 문제는 쿼리 결과에 대해 형식 안전성을 얻지 못한다는 것입니다. 물론 결과를 수동으로 입력할 수도 있지만 이것은 엄청난 양의 작업이며 입력을 동기화 상태로 유지하기 위해 데이터베이스 스키마 또는 쿼리를 변경할 때마다 주요 리팩토링이 필요합니다.</p>\n<p>또한 SQL 쿼리를 일반 문자열로 제출하면 편집기에서 자동 완성 기능을 사용할 수 없습니다.</p>\n<h3 id=\"sql-쿼리-빌더-높은-제어력-중간-수준의-생산성\" style=\"position:relative;\"><a href=\"#sql-%EC%BF%BC%EB%A6%AC-%EB%B9%8C%EB%8D%94-%EB%86%92%EC%9D%80-%EC%A0%9C%EC%96%B4%EB%A0%A5-%EC%A4%91%EA%B0%84-%EC%88%98%EC%A4%80%EC%9D%98-%EC%83%9D%EC%82%B0%EC%84%B1\" aria-label=\"sql 쿼리 빌더 높은 제어력 중간 수준의 생산성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL 쿼리 빌더: 높은 제어력, 중간 수준의 생산성</h3>\n<p>높은 수준의 제어를 유지하고 더 나은 생산성을 제공하는 일반적인 솔루션은 SQL 쿼리 빌더(예: knex.js )를 사용하는 것입니다. 이러한 종류의 도구는 SQL 쿼리를 구성하는 프로그래밍 방식의 추상화를 제공합니다.</p>\n<p>SQL 쿼리 빌더의 가장 큰 단점은 애플리케이션 개발자가 여전히 SQL의 관점에서 데이터를 생각할 필요가 있다는 것입니다. 이는 관계형 데이터를 개체로 변환하는 인지적 및 실제적 비용을 초래합니다. 또 다른 문제는 SQL 쿼리에서 무엇을 하고 있는지 정확히 모른다면 발을 들이받기가 너무 쉽다는 것입니다.</p>\n<h3 id=\"orm-통제력이-낮고-생산성이-향상됨\" style=\"position:relative;\"><a href=\"#orm-%ED%86%B5%EC%A0%9C%EB%A0%A5%EC%9D%B4-%EB%82%AE%EA%B3%A0-%EC%83%9D%EC%82%B0%EC%84%B1%EC%9D%B4-%ED%96%A5%EC%83%81%EB%90%A8\" aria-label=\"orm 통제력이 낮고 생산성이 향상됨 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM: 통제력이 낮고 생산성이 향상됨</h3>\n<p>ORM 은 애플리케이션 모델을 클래스로 정의할 수 있도록 하여 SQL에서 추상화되며 이러한 클래스는 데이터베이스의 테이블에 매핑됩니다.</p>\n<p><strong>“객체 관계형 매퍼”(ORM)는 프로그래머의 친구(객체)와 데이터베이스의 원시(관계) 사이의 간격을 연결하기 위해 존재합니다. 이러한 서로 다른 모델의 이유는 기능만큼이나 문화적인 것입니다. 프로그래머는 실행 중인 프로그램에서 단일 항목의 상태를 캡슐화하기 때문에 객체를 좋아합니다. 데이터베이스는 전체 데이터 세트 제약 조건과 전체 데이터 세트에 대한 효율적인 액세스 패턴에 더 적합하기 때문에 관계를 좋아합니다.</strong></p>\n<p>그런 다음 모델 클래스의 인스턴스에서 메서드를 호출하여 데이터를 읽고 쓸 수 있습니다.</p>\n<p>훨씬 더 편리하고 개발자가 데이터에 대해 생각할 때 가지고 있는 모델에 더 가깝습니다.</p>\n<p><strong>ORM은 시작이 좋고 시간이 지날수록 복잡해지며, 얼마 지나지 않아 명확한 경계, 명확한 승리 조건, 명확한 출구 전략이 없는 약속에 사용자를 가두는 수렁을 나타냅니다.</strong></p>\n<p>애플리케이션 개발자로서 데이터에 대한 멘탈 모델은 객체 의 멘탈 모델 입니다. 반면에 SQL의 데이터에 대한 멘탈 모델은 테이블 입니다.</p>\n<p>데이터의 이 두 가지 다른 표현 사이의 분할은 종종 객체 관계형 임피던스 불일치라고 합니다. 개체 관계형 임피던스 불일치는 많은 개발자가 기존 ORM 작업을 좋아하지 않는 주요 이유이기도 합니다.</p>\n<p>예를 들어, 각 접근 방식에서 데이터가 구성되고 관계가 처리되는 방식을 고려해봅시다.</p>\n<ul>\n<li>관계형 데이터베이스 : 데이터는 일반적으로 정규화(평면)되며 외래 키를 사용하여 엔터티 간에 연결합니다. 그런 다음 실제 관계를 나타내기 위해 엔터티를 JOIN해야 합니다.</li>\n<li>객체 지향 : 객체는 단순히 점 표기법을 사용하여 관계를 순회할 수 있는 깊게 중첩된 구조일 수 있습니다.</li>\n</ul>\n<p>이것은 ORM의 주요 함정 중 하나를 암시합니다. 친숙한 점 표기법을 사용하여 단순히 관계를 순회할 수 있는 것처럼 보이지만 내부적으로 ORM은 비용이 많이 들고 애플리케이션 속도를 크게 늦출 가능성이 있는 SQL JOIN을 생성합니다. <strong>n+1 문제가 발생합니다.</strong></p>\n<h3 id=\"결론-orm의-매력은-관계형-모델을-추상화하고-데이터를-순수하게-객체-측면에서-생각한다는-전제입니다-전제는-훌륭하지만-관계형-데이터가-개체에-쉽게-매핑될-수-있다는-잘못된-가정을-기반으로-하므로-많은-복잡성과-함정이-발생합니다\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0-orm%EC%9D%98-%EB%A7%A4%EB%A0%A5%EC%9D%80-%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%B6%94%EC%83%81%ED%99%94%ED%95%98%EA%B3%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%88%9C%EC%88%98%ED%95%98%EA%B2%8C-%EA%B0%9D%EC%B2%B4-%EC%B8%A1%EB%A9%B4%EC%97%90%EC%84%9C-%EC%83%9D%EA%B0%81%ED%95%9C%EB%8B%A4%EB%8A%94-%EC%A0%84%EC%A0%9C%EC%9E%85%EB%8B%88%EB%8B%A4-%EC%A0%84%EC%A0%9C%EB%8A%94-%ED%9B%8C%EB%A5%AD%ED%95%98%EC%A7%80%EB%A7%8C-%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EA%B0%9C%EC%B2%B4%EC%97%90-%EC%89%BD%EA%B2%8C-%EB%A7%A4%ED%95%91%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8B%A4%EB%8A%94-%EC%9E%98%EB%AA%BB%EB%90%9C-%EA%B0%80%EC%A0%95%EC%9D%84-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%AF%80%EB%A1%9C-%EB%A7%8E%EC%9D%80-%EB%B3%B5%EC%9E%A1%EC%84%B1%EA%B3%BC-%ED%95%A8%EC%A0%95%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"결론 orm의 매력은 관계형 모델을 추상화하고 데이터를 순수하게 객체 측면에서 생각한다는 전제입니다 전제는 훌륭하지만 관계형 데이터가 개체에 쉽게 매핑될 수 있다는 잘못된 가정을 기반으로 하므로 많은 복잡성과 함정이 발생합니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론: ORM의 매력은 관계형 모델을 추상화하고 데이터를 순수하게 객체 측면에서 생각한다는 전제입니다. 전제는 훌륭하지만 관계형 데이터가 개체에 쉽게 매핑될 수 있다는 잘못된 가정을 기반으로 하므로 많은 복잡성과 함정이 발생합니다.</h3>","frontmatter":{"date":"September 18, 2022","title":"[Skill] Prisma Proj-2","categories":"SKILL","author":"hoonloper","emoji":"🛠"},"fields":{"slug":"/skills/prisma2/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/skills/prisma/","nextSlug":"/cs/transaction/","prevSlug":"/skills/prisma2/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}