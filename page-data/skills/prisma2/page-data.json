{"componentChunkName":"component---src-templates-blog-template-js","path":"/skills/prisma2/","result":{"data":{"cur":{"id":"9b5ac0ef-fa15-5cd1-91cb-97cadfd4b6ab","html":"<p><img src=\"https://user-images.githubusercontent.com/78959175/190888255-f601e5a6-41b1-4c5c-bf09-62db4e25ccda.png\" alt=\"111\"></p>\n<h2 id=\"프리즈마를-선택해야-하는-이유\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"프리즈마를 선택해야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마를 선택해야 하는 이유</h2>\n<p>Prisma의 주요 목표는 데이터베이스 작업 시 애플리케이션 <strong>개발자의 생산성을 높이는 것입니다.</strong> 다음은 Prisma의 목표를 이루기 위한 몇 가지 예입니다.</p>\n<ul>\n<li>관계형 데이터를 매핑하는 대신 개체에서 생각하기</li>\n<li>복잡한 모델 객체를 피하기 위해 클래스가 아닌 쿼리</li>\n<li>데이터베이스 및 애플리케이션 모델을 위한 단일 정보 소스</li>\n<li>일반적인 함정과 반패턴을 방지하는 제약</li>\n<li>쉽게 만드는 추상화</li>\n<li>컴파일 시 유효성을 검사할 수 있는 유형 안전 데이터베이스 쿼리</li>\n<li>개발자가 앱의 중요한 부분에 집중할 수 있도록 상용구 감소</li>\n<li>문서를 찾을 필요 없이 코드 편집기에서 자동 완성</li>\n</ul>\n<h4 id=\"sql-orm-및-기타-데이터베이스-도구의-문제\" style=\"position:relative;\"><a href=\"#sql-orm-%EB%B0%8F-%EA%B8%B0%ED%83%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8F%84%EA%B5%AC%EC%9D%98-%EB%AC%B8%EC%A0%9C\" aria-label=\"sql orm 및 기타 데이터베이스 도구의 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL, ORM 및 기타 데이터베이스 도구의 문제</h4>\n<p>현재 Node.js 및 TypeScript 에코시스템에 존재하는 데이터베이스 도구의 주요 문제는 생산성과 제어 간의 주요 절충점이 필요하다는 것 입니다.</p>\n<h3 id=\"원시-sql-전체-제어-낮은-생산성\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%8B%9C-sql-%EC%A0%84%EC%B2%B4-%EC%A0%9C%EC%96%B4-%EB%82%AE%EC%9D%80-%EC%83%9D%EC%82%B0%EC%84%B1\" aria-label=\"원시 sql 전체 제어 낮은 생산성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원시 SQL: 전체 제어, 낮은 생산성</h3>\n<p>원시 SQL(예: 기본 pg또는 mysqlNode.js 데이터베이스 드라이버 사용)을 사용하면 데이터베이스 작업을 완전히 제어할 수 있습니다. 그러나 일반 SQL 문자열을 데이터베이스로 보내는 것이 번거롭고 많은 오버헤드(수동 연결 처리, 반복적인 상용구 등)가 수반되므로 생산성이 저하됩니다.</p>\n<p>이 접근 방식의 또 다른 주요 문제는 쿼리 결과에 대해 형식 안전성을 얻지 못한다는 것입니다. 물론 결과를 수동으로 입력할 수도 있지만 이것은 엄청난 양의 작업이며 입력을 동기화 상태로 유지하기 위해 데이터베이스 스키마 또는 쿼리를 변경할 때마다 주요 리팩토링이 필요합니다.</p>\n<p>또한 SQL 쿼리를 일반 문자열로 제출하면 편집기에서 자동 완성 기능을 사용할 수 없습니다.</p>\n<h3 id=\"sql-쿼리-빌더-높은-제어력-중간-수준의-생산성\" style=\"position:relative;\"><a href=\"#sql-%EC%BF%BC%EB%A6%AC-%EB%B9%8C%EB%8D%94-%EB%86%92%EC%9D%80-%EC%A0%9C%EC%96%B4%EB%A0%A5-%EC%A4%91%EA%B0%84-%EC%88%98%EC%A4%80%EC%9D%98-%EC%83%9D%EC%82%B0%EC%84%B1\" aria-label=\"sql 쿼리 빌더 높은 제어력 중간 수준의 생산성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL 쿼리 빌더: 높은 제어력, 중간 수준의 생산성</h3>\n<p>높은 수준의 제어를 유지하고 더 나은 생산성을 제공하는 일반적인 솔루션은 SQL 쿼리 빌더(예: knex.js )를 사용하는 것입니다. 이러한 종류의 도구는 SQL 쿼리를 구성하는 프로그래밍 방식의 추상화를 제공합니다.</p>\n<p>SQL 쿼리 빌더의 가장 큰 단점은 애플리케이션 개발자가 여전히 SQL의 관점에서 데이터를 생각할 필요가 있다는 것입니다. 이는 관계형 데이터를 개체로 변환하는 인지적 및 실제적 비용을 초래합니다. 또 다른 문제는 SQL 쿼리에서 무엇을 하고 있는지 정확히 모른다면 발을 들이받기가 너무 쉽다는 것입니다.</p>\n<h3 id=\"orm-통제력이-낮고-생산성이-향상됨\" style=\"position:relative;\"><a href=\"#orm-%ED%86%B5%EC%A0%9C%EB%A0%A5%EC%9D%B4-%EB%82%AE%EA%B3%A0-%EC%83%9D%EC%82%B0%EC%84%B1%EC%9D%B4-%ED%96%A5%EC%83%81%EB%90%A8\" aria-label=\"orm 통제력이 낮고 생산성이 향상됨 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM: 통제력이 낮고 생산성이 향상됨</h3>\n<p>ORM 은 애플리케이션 모델을 클래스로 정의할 수 있도록 하여 SQL에서 추상화되며 이러한 클래스는 데이터베이스의 테이블에 매핑됩니다.</p>\n<p><strong>“객체 관계형 매퍼”(ORM)는 프로그래머의 친구(객체)와 데이터베이스의 원시(관계) 사이의 간격을 연결하기 위해 존재합니다. 이러한 서로 다른 모델의 이유는 기능만큼이나 문화적인 것입니다. 프로그래머는 실행 중인 프로그램에서 단일 항목의 상태를 캡슐화하기 때문에 객체를 좋아합니다. 데이터베이스는 전체 데이터 세트 제약 조건과 전체 데이터 세트에 대한 효율적인 액세스 패턴에 더 적합하기 때문에 관계를 좋아합니다.</strong></p>\n<p>그런 다음 모델 클래스의 인스턴스에서 메서드를 호출하여 데이터를 읽고 쓸 수 있습니다.</p>\n<p>훨씬 더 편리하고 개발자가 데이터에 대해 생각할 때 가지고 있는 모델에 더 가깝습니다.</p>\n<p><strong>ORM은 시작이 좋고 시간이 지날수록 복잡해지며, 얼마 지나지 않아 명확한 경계, 명확한 승리 조건, 명확한 출구 전략이 없는 약속에 사용자를 가두는 수렁을 나타냅니다.</strong></p>\n<p>애플리케이션 개발자로서 데이터에 대한 멘탈 모델은 객체 의 멘탈 모델 입니다. 반면에 SQL의 데이터에 대한 멘탈 모델은 테이블 입니다.</p>\n<p>데이터의 이 두 가지 다른 표현 사이의 분할은 종종 객체 관계형 임피던스 불일치라고 합니다. 개체 관계형 임피던스 불일치는 많은 개발자가 기존 ORM 작업을 좋아하지 않는 주요 이유이기도 합니다.</p>\n<p>예를 들어, 각 접근 방식에서 데이터가 구성되고 관계가 처리되는 방식을 고려해봅시다.</p>\n<ul>\n<li>관계형 데이터베이스 : 데이터는 일반적으로 정규화(평면)되며 외래 키를 사용하여 엔터티 간에 연결합니다. 그런 다음 실제 관계를 나타내기 위해 엔터티를 JOIN해야 합니다.</li>\n<li>객체 지향 : 객체는 단순히 점 표기법을 사용하여 관계를 순회할 수 있는 깊게 중첩된 구조일 수 있습니다.</li>\n</ul>\n<p>이것은 ORM의 주요 함정 중 하나를 암시합니다. 친숙한 점 표기법을 사용하여 단순히 관계를 순회할 수 있는 것처럼 보이지만 내부적으로 ORM은 비용이 많이 들고 애플리케이션 속도를 크게 늦출 가능성이 있는 SQL JOIN을 생성합니다. <strong>n+1 문제가 발생합니다.</strong></p>\n<h3 id=\"결론-orm의-매력은-관계형-모델을-추상화하고-데이터를-순수하게-객체-측면에서-생각한다는-전제입니다-전제는-훌륭하지만-관계형-데이터가-개체에-쉽게-매핑될-수-있다는-잘못된-가정을-기반으로-하므로-많은-복잡성과-함정이-발생합니다\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0-orm%EC%9D%98-%EB%A7%A4%EB%A0%A5%EC%9D%80-%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%B6%94%EC%83%81%ED%99%94%ED%95%98%EA%B3%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%88%9C%EC%88%98%ED%95%98%EA%B2%8C-%EA%B0%9D%EC%B2%B4-%EC%B8%A1%EB%A9%B4%EC%97%90%EC%84%9C-%EC%83%9D%EA%B0%81%ED%95%9C%EB%8B%A4%EB%8A%94-%EC%A0%84%EC%A0%9C%EC%9E%85%EB%8B%88%EB%8B%A4-%EC%A0%84%EC%A0%9C%EB%8A%94-%ED%9B%8C%EB%A5%AD%ED%95%98%EC%A7%80%EB%A7%8C-%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EA%B0%9C%EC%B2%B4%EC%97%90-%EC%89%BD%EA%B2%8C-%EB%A7%A4%ED%95%91%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8B%A4%EB%8A%94-%EC%9E%98%EB%AA%BB%EB%90%9C-%EA%B0%80%EC%A0%95%EC%9D%84-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%AF%80%EB%A1%9C-%EB%A7%8E%EC%9D%80-%EB%B3%B5%EC%9E%A1%EC%84%B1%EA%B3%BC-%ED%95%A8%EC%A0%95%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"결론 orm의 매력은 관계형 모델을 추상화하고 데이터를 순수하게 객체 측면에서 생각한다는 전제입니다 전제는 훌륭하지만 관계형 데이터가 개체에 쉽게 매핑될 수 있다는 잘못된 가정을 기반으로 하므로 많은 복잡성과 함정이 발생합니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론: ORM의 매력은 관계형 모델을 추상화하고 데이터를 순수하게 객체 측면에서 생각한다는 전제입니다. 전제는 훌륭하지만 관계형 데이터가 개체에 쉽게 매핑될 수 있다는 잘못된 가정을 기반으로 하므로 많은 복잡성과 함정이 발생합니다.</h3>","excerpt":"111 프리즈마를 선택해야 하는 이유 Prisma의 주요 목표는 데이터베이스 작업 시 애플리케이션 개발자의 생산성을 높이는 것입니다. 다음은 Prisma의 목표를 이루기 위한 몇 가지 예입니다. 관계형 데이터를 매핑하는 대신 개체에서 생각하기 복잡한 모델 객체를 피하기 위해 클래스가 아닌 쿼리 데이터베이스 및 애플리케이션 모델을 위한 단일 정보 소스 일반적인 함정과 반패턴을 방지하는 제약 쉽게 만드는 추상화 컴파일 시 유효성을 검사할 수 있는 유형 안전 데이터베이스 쿼리 개발자가 앱의 중요한 부분에 집중할 수 있도록 상용구 감소 문서를 찾을 필요 없이 코드 편집기에서 자동 완성 SQL, ORM 및 기타 데이터베이스 도구의 문제 현재 Node.js 및 TypeScript 에코시스템에 존재하는 데이터베이스 도구의 주요 문제는 생산성과 제어 간의 주요 절충점이 필요하다는 것 입니다. 원시 SQL: 전체 제어, 낮은 생산성 원시 SQL(예: 기본 pg또는 mysqlNode.js 데이터베이…","frontmatter":{"date":"September 18, 2022","title":"[Skill] Prisma Proj-2","categories":"SKILL","author":"hoonloper","emoji":"🛠"},"fields":{"slug":"/skills/prisma2/"}},"next":{"id":"9c3f3a71-ad7c-5f99-8d95-14b528e0b078","html":"<p><img src=\"https://user-images.githubusercontent.com/78959175/190888255-f601e5a6-41b1-4c5c-bf09-62db4e25ccda.png\" alt=\"111\"></p>\n<p>소규모 프로젝트의 Back-End 개발을 시작했습니다.</p>\n<p>Nest X TypeORM 조합만 사용해왔던 저는 새로운 기술을 배워보고 싶어 평소 흥미롭게 바라보던 Prisma를 적용해보기로 결정합니다.</p>\n<p>공식 문서에서 설명하는 Prisma는 이렇습니다.</p>\n<h2 id=\"프리즈마란\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EB%9E%80\" aria-label=\"프리즈마란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마란?</h2>\n<p>Prisma는 오픈 소스 차세대 ORM입니다. 다음 부분으로 구성됩니다.</p>\n<ul>\n<li>Prisma Client : Node.js 및 TypeScript를 위한 자동 생성 및 유형 안전 쿼리 빌더</li>\n<li>Prisma Migrate : 마이그레이션 시스템</li>\n<li>Prisma Studio : 데이터베이스의 데이터를 보고 편집하는 GUI</li>\n<li>Prisma Client는 모든 Node.js(지원 버전) 또는 TypeScript 백엔드 애플리케이션(서버리스 애플리케이션 및 마이크로서비스 포함)에서 사용할 수 있습니다.</li>\n</ul>\n<h2 id=\"프리즈마의-작동-방식\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%EC%A6%88%EB%A7%88%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\" aria-label=\"프리즈마의 작동 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리즈마의 작동 방식</h2>\n<p><strong>RDBMS</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">datasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel Post {\n  id        Int     @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean @default(false)\n  author    User?   @relation(fields: [authorId], references: [id])\n  authorId  Int?\n}\n\nmodel User {\n  id    Int     @id @default(autoincrement())\n  email String  @unique\n  name  String?\n  posts Post[]\n}</code></pre></div>\n<p><strong>NoSQL</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">datasource db {\n  provider = \"mongodb\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel Post {\n  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n  title     String\n  content   String?\n  published Boolean @default(false)\n  author    User?   @relation(fields: [authorId], references: [id])\n  authorId  String  @db.ObjectId\n}\n\nmodel User {\n  id    String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n  email String  @unique\n  name  String?\n  posts Post[]\n}</code></pre></div>\n<p>이 스키마에서는 세 가지를 구성합니다.</p>\n<ul>\n<li>Data source : 데이터베이스 연결을 지정합니다(환경 변수를 통해).</li>\n<li>Generator : Prisma Client를 생성하고자 함을 나타냅니다.</li>\n<li>Data model : 애플리케이션 모델을 정의합니다.</li>\n</ul>\n<h3 id=\"prisma-client로-데이터베이스에-접근하기\" style=\"position:relative;\"><a href=\"#prisma-client%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0\" aria-label=\"prisma client로 데이터베이스에 접근하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prisma Client로 데이터베이스에 접근하기</h3>\n<p>Prisma Client를 사용하는 첫 번째 단계는 @prisma/clientnpm 패키지를 설치하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install @prisma/client</code></pre></div>\n<p>@prisma/client패키지를 설치하면 prisma generatePrisma 스키마를 읽고 Prisma Client 코드를 생성 하는 명령이 호출됩니다.</p>\n<p>데이터 모델을 변경한 후 내부 코드가 DB에 업데이트 되도록 Prisma Client를 수동으로 다시 생성해야 합니다 .</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">prisma generate</code></pre></div>\n<p>Prisma Client가 생성되면 코드로 가져와서 데이터베이스에 쿼리를 보낼 수 있습니다.</p>","frontmatter":{"date":"September 18, 2022","title":"[Skill] Prisma Proj-1","categories":"SKILL","author":"hoonloper","emoji":"🛠"},"fields":{"slug":"/skills/prisma/"}},"prev":{"id":"e8154d56-dd68-5fb5-84bb-370a3592768a","html":"<p>안녕하세요! 이번 포스트는 JavaScript와 TypeScript 차이에 대해 작성하려 합니다!</p>\n<h2 id=\"javascript--typescript\" style=\"position:relative;\"><a href=\"#javascript--typescript\" aria-label=\"javascript  typescript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript &#x26; TypeScript</h2>\n<h3 id=\"javascript\" style=\"position:relative;\"><a href=\"#javascript\" aria-label=\"javascript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript</h3>\n<ul>\n<li>자바스크립트는 ‘웹페이지에 생동감을 불어넣기 위해’ 만들어진 <strong>동적인</strong> 프로그래밍 언어입니다.</li>\n<li>동적인 언어에 맞게 암묵적 형변환 현상이 있어 보다 개발을 쉽게 할 수 있는 언어입니다.</li>\n</ul>\n<h3 id=\"typescript\" style=\"position:relative;\"><a href=\"#typescript\" aria-label=\"typescript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript</h3>\n<ul>\n<li>타입스크립트는 자바스크립트 언어에 타입을 부여한 언어입니다.</li>\n<li>동적인 자바스크립트를 정적으로 바꿔줘 예상치 못한 에러를 방지할 수 있습니다.</li>\n<li>런타임에서 발생할 에러를 컴파일 단계에서 미리 잡아줘 에러 예방이 가능합니다.</li>\n<li>타입스크립트는 브라우저에서 실행하려면 자바스크립트로 바꿔주는 <strong>컴파일</strong> 과정을 거칩니다.</li>\n</ul>\n<h2 id=\"typescript를-왜-사용하는가\" style=\"position:relative;\"><a href=\"#typescript%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"typescript를 왜 사용하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript를 왜 사용하는가?!</h2>\n<p>제가 지금까지 개발하면서 느꼈던 점 위주로 작성하겠습니다.</p>\n<p>장점</p>\n<ol>\n<li>데이터 유효성 검사로 타입 에러를 최소화 할 수 있다.</li>\n<li>내가 아닌 다른 개발자가 코드를 봤을 때 타입이 명시적으로 작성되어 있어 코드를 이해하기 편하다.</li>\n<li>타입이 달라 발생하는 에러(DB Type과 불일치 등)들을 사전에 방지할 수 있다.</li>\n<li>기본적인 Number, String 외에도 다양한 타입들을 지원해 적재적소에 알맞는 타입을 지정할 수 있다.</li>\n</ol>\n<p>단점</p>\n<ol>\n<li>컴파일이라는 과정이 있기에 비교적 무겁게 돌아간다.(큰 차이는 없을 수도..?)</li>\n<li>개발하며 가장 많이 사용되는 변수나 함수 등 하나하나 타입을 지정해야 해서 귀찮음을 유발한다.</li>\n<li>타입이 많아지면 관리하기가 어려워진다.</li>\n<li>자바스크립트의 동적인 특징과 타입스크립트의 정적인 특징이 만나 숙련도가 낮은 개발자는 코드를 이해하기 힘들다.</li>\n</ol>\n<p>등이 있겠습니다.</p>\n<p>특히 단점의 2번.. 타입스크립트를 사용하는 모든 개발자들을 괴롭히는 주 원인인데요. 이러한 단점에도 불구하고 장점이 주는 이점이 너무나도 강력해 타입스크립트를 사용하는 개발자들이 많은 것으로 생각됩니다!(제 생각..)</p>\n<p>계좌 이체나 결제 등 실제 돈이 오고가는 흐름에서 데이터의 타입 이슈가 발생한다면..? 생각만해도 끔찍합니다. 사실 모든? 개발자들이 고려하는 부분이라 생각해 조치를 취해뒀겠지만 혹시나 하는 위험 요소들이 존재합니다. 이런 혹시나 하는 위험 요소들을 100% 커버는 하지 못할지라도 99%에 가깝게 커버할 수 있다고 생각해요.</p>\n<p>간단 요약</p>\n<ul>\n<li>JS보다 TS가 개발에 있어 안정적이다.</li>\n<li>TS는 JS와는 다르게 타입을 지정해 명시적인 코드, 즉 클린한 코드를 작성할 수 있게 도와준다.</li>\n<li>TS는 내 취향이다.</li>\n</ul>\n<p>읽어주셔서 감사합니다 :)</p>","frontmatter":{"date":"September 19, 2022","title":"[CS] JavaScript & TypeScript","categories":"CS","author":"hoonloper","emoji":"💾"},"fields":{"slug":"/cs/js-vs-ts/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/skills/prisma2/","nextSlug":"/skills/prisma/","prevSlug":"/cs/js-vs-ts/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}