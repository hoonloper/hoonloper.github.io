{"componentChunkName":"component---src-templates-blog-template-js","path":"/skills/promise-all/","result":{"data":{"cur":{"id":"3946968e-89f6-5c12-b296-21fa5b5734bf","html":"<p>안녕하세요. 이번 포스트는 Promise.all을 활용해 테스트 코드의 동작 시간을 단축한 경험을 풀어보려 해요.</p>\n<p><strong>동기와 비동기가 무엇인지에 대해서는 인터넷에 너무나 많은 양질의 자료들이 많으니 여기서는 설명을 스킵할게요 :)</strong></p>\n<p>진득하게 테스트 코드를 작성하고 있던 저는 한가지 고민에 빠졌어요.</p>\n<p>테스트 코드가 늘어날수록 테스트 시간이 늘어나 견디기 힘들만큼 길어져 더이상은 안되겠다 싶었죠.</p>\n<p>테스트 DB에 접근해 데이터를 가져오지만 데이터 양이 많아 한번 get 요청에 평균 1초가 걸렸어요.</p>\n<p><del>DB에서 뽑아오는 API를 수정하지 않는 이상 속도 개선에 대한 부분은 감안하고 진행해야 했어요 😭</del></p>\n<p>그래서 작성하고 있던 제 테스트 코드를 뜯어 고치기로 마음을 다짐했어요!</p>\n<p>다른 테스트 코드들은 상관이 없으니 실질적으로 문제를 일으키는 녀석들은 필터링 관련 테스트였어요.</p>\n<p>필터링 관련 항목이 약 20개며, 정렬 관련 항목이 약 15개 정도 되니 <strong>총 35번의 API 호출이 연속적으로 이뤄지고 평균 1초가 걸리는 요청에 의해 필터링과 정렬 총합 평균 30초의 시간</strong>이 걸렸어요.</p>\n<p>해당 테스트 코드를 검토하니 이렇게 로직이 짜여져 있었어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'테스트'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> 필터 <span class=\"token keyword\">of</span> 필터옵션<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> 응답 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> 대충<span class=\"token constant\">API</span><span class=\"token function\">호출하는함수</span><span class=\"token punctuation\">(</span>필터<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">대충데이터형식검사하는함수</span><span class=\"token punctuation\">(</span>응답<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 <code class=\"language-text\">for - of</code> 문으로 이루어져있다보니 비동기 처리를 하려 <code class=\"language-text\">async - await</code>을 걸어줬지만 반대로 동기적인 코드가 되어버렸죠 😅</p>\n<p>이 문제를 해결하기 위해 <code class=\"language-text\">for - of</code> 반복문을 집어 던지고!! Promise.all을 가져왔답니다.</p>\n<p><strong>리팩토링한 코드는 다음과 같아요.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'테스트'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> 매핑한응답 <span class=\"token operator\">=</span> 필터옵션<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">필터</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> 대충<span class=\"token constant\">API</span><span class=\"token function\">호출하는함수</span><span class=\"token punctuation\">(</span>필터<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> 응답 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>매핑한응답<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">대충데이터형식검사하는함수</span><span class=\"token punctuation\">(</span>응답<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Promise.all은 <strong>Promise로 되어있는 코드를 비동기적, 즉 병렬로 처리</strong>해주기 때문에 마지막 요청에 응답까지 끝난 후 결과를 배열 형태로 반환해줘요.</p>\n<p>실제로 테스트 동작 시간이 5~6배 정도 빨라졌어요.</p>\n<p><strong>실제 정렬 테스트의 결과만 가져왔어요.</strong></p>\n<h3 id=\"적용-전\" style=\"position:relative;\"><a href=\"#%EC%A0%81%EC%9A%A9-%EC%A0%84\" aria-label=\"적용 전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>적용 전</h3>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/200555001-1a9b7cf5-5e65-463f-9ed9-8558cabf611f.png\" alt=\"Promise 적용 전 코드\"></p>\n<h3 id=\"적용-후\" style=\"position:relative;\"><a href=\"#%EC%A0%81%EC%9A%A9-%ED%9B%84\" aria-label=\"적용 후 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>적용 후</h3>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/200555004-41676372-52e1-48a9-aa3d-f2a37564db0d.png\" alt=\"Promise 적용 후 코드\"></p>\n<p>복잡한 설명 없이 깔끔하게 <strong>이슈 -> 원인 분석 -> 해결</strong> 순서로 적어봤어요.</p>\n<p>앞으로 테스트 코드 작성이 끝나면 API의 응답 시간을 단축해볼 계획이 있답니다 😊</p>","excerpt":"안녕하세요. 이번 포스트는 Promise.all을 활용해 테스트 코드의 동작 시간을 단축한 경험을 풀어보려 해요. 동기와 비동기가 무엇인지에 대해서는 인터넷에 너무나 많은 양질의 자료들이 많으니 여기서는 설명을 스킵할게요 :) 진득하게 테스트 코드를 작성하고 있던 저는 한가지 고민에 빠졌어요. 테스트 코드가 늘어날수록 테스트 시간이 늘어나 견디기 힘들만큼 길어져 더이상은 안되겠다 싶었죠. 테스트 DB에 접근해 데이터를 가져오지만 데이터 양이 많아 한번 get 요청에 평균 1초가 걸렸어요. DB에서 뽑아오는 API를 수정하지 않는 이상 속도 개선에 대한 부분은 감안하고 진행해야 했어요 😭 그래서 작성하고 있던 제 테스트 코드를 뜯어 고치기로 마음을 다짐했어요! 다른 테스트 코드들은 상관이 없으니 실질적으로 문제를 일으키는 녀석들은 필터링 관련 테스트였어요. 필터링 관련 항목이 약 20개며, 정렬 관련 항목이 약 15개 정도 되니 총 35번의 API 호출이 연속적으로 이뤄지고 평균 1…","frontmatter":{"date":"October 26, 2022","title":"[Skill] Promise.all을 활용해 동작 시간 단축","categories":"SKILL","author":"hoonloper","emoji":"🛠"},"fields":{"slug":"/skills/promise-all/"}},"next":{"id":"f602a153-3a23-5e5d-8548-b8925fc146cb","html":"<blockquote>\n<p>행사 관련해서 제가 직접 촬영한 사진이 없네요 ㅠㅠ 참고 바라며 마지막에 행사 상품 사진이라도 첨부할게요!</p>\n</blockquote>\n<p><a href=\"https://youtu.be/VH1GTGIMHQw\">NestJS Korea Meetup 영상 다시보기🔥</a></p>\n<h1 id=\"nestjs-코리아-밋업에-참여하다\" style=\"position:relative;\"><a href=\"#nestjs-%EC%BD%94%EB%A6%AC%EC%95%84-%EB%B0%8B%EC%97%85%EC%97%90-%EC%B0%B8%EC%97%AC%ED%95%98%EB%8B%A4\" aria-label=\"nestjs 코리아 밋업에 참여하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NestJS 코리아 밋업에 참여하다.</h1>\n<p>오늘은 강남에 있는 팀 스파르타에서 진행된 NestJS 밋업에 참여했습니다!</p>\n<p>개발자로서 개발 관련한 행사에 참여하는 것은 이번이 처음이라 매우 떨렸네요 😅</p>\n<p>지난번에 인프콘 행사에 신청했지만 아쉽게 당첨되지는 못해서 참여 못한 기억이 스물스물 올라옵니다 😂</p>\n<p>행사 진행 일시와 장소는 아래와 같아요!</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token list punctuation\">-</span> 일시: 2022.10.20(목) 오후 7시 ~ 10시(3시간)\n<span class=\"token list punctuation\">-</span> 장소: 서울특별시 강남구 테헤란로 44길 8, 12층 (팀스파르타)</code></pre></div>\n<h3 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h3>\n<ul>\n<li><strong>19:00 ~ 19:10</strong>\n<ul>\n<li>오프닝 인사</li>\n</ul>\n</li>\n<li><strong>19:10 ~ 19:40</strong>\n<ul>\n<li>남정호 - Nestia + TypeScript-JSON</li>\n<li>Automatic SDK generator with 초고속 JSON 상하차(시대가 어느 때인데 아직도 swagger 하세요?)</li>\n</ul>\n</li>\n<li><strong>19:40 ~ 20:10</strong>\n<ul>\n<li>조헌일 - NestJS에서 서버리스 트랜스코딩 파이프라인 만들기</li>\n<li>NestJS에서 빠르고 쉽게 트랜스코딩 파이프라인을 구축하는 법. 그 과정에서 각 인프라와 서비스를 사용한 방법 공유</li>\n</ul>\n</li>\n<li><strong>20:10 ~ 20:40</strong>\n<ul>\n<li>김인성 - NestJS에서 AOP 우아하게 적용하기</li>\n<li>NestJS provider 탐색을 통해 run time에 initialize된 instance를 decorator로 활용하여, controller가 아닌 각 service에 AOP개념을 우아하게 적용하는 방법 알아보기</li>\n</ul>\n</li>\n<li><strong>20:40 ~ 21:10</strong>\n<ul>\n<li>이경석 - NestJS 기반의 테스트 작성방법</li>\n<li>NestJS에 종속적인 테스트와 독립적인 테스트를 구분해서 작성하는 방법</li>\n</ul>\n</li>\n<li><strong>21:10 ~ 21:40</strong>\n<ul>\n<li>차진혁 - NestJS lifecycle과 interceptor</li>\n<li>NestJS에서 rxjs를 이용한 interceptor 구현과 lifecycle 측면에서의 interceptor 바라보기</li>\n</ul>\n</li>\n<li><strong>21:40 ~ 22:10</strong>\n<ul>\n<li>패널토크</li>\n<li>연사자들과 함께 네트워킹 &#x26; 굿즈 전달</li>\n</ul>\n</li>\n</ul>\n<p>Assemble 행사 스케쥴은 위와 같아요! 여기서 저는 <strong>남정호 님의 Nestia + TypeScript-JSON</strong> 발표와 <strong>김인성 님의 NestJS에서 AOP 우아하게 적용하기</strong> 발표, <strong>차진혁 님의 NestJS lifesycle과 interceptor</strong> 발표가 가장 기대됐어요.</p>\n<hr>\n<h3 id=\"남정호님-발표-소감\" style=\"position:relative;\"><a href=\"#%EB%82%A8%EC%A0%95%ED%98%B8%EB%8B%98-%EB%B0%9C%ED%91%9C-%EC%86%8C%EA%B0%90\" aria-label=\"남정호님 발표 소감 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>남정호님 발표 소감</h3>\n<p>우선 첫번째로 남정호 님의 발표를 보고 난 후 소감이에요.</p>\n<p>남정호님은 samchon이란 개발 이름을 사용하는 이름 있는 개발자분이십니다! (<a href=\"https://github.com/samchon\">https://github.com/samchon</a>)</p>\n<p>평소 오픈톡방에서 nestia라는 라이브러리를 지속적으로 홍보하시고 무엇보다 Validation 부분에서 압도적인 속도를 보여준다는 내용이 인상깊었어요.</p>\n<p>nestia는 SDK(SoftwareDevelopmentKit)Generator, SwaggerGenerator 역할을 수행해요.</p>\n<p>아래와 같은 특징이 있습니다.</p>\n<ul>\n<li>인터페이스를 DTO로 사용 가능</li>\n<li>자동 Validation 지원</li>\n<li>Class-Validator + Transformer 보다 최대 2,000배 빠름</li>\n</ul>\n<p>개발자인 저는 무엇보다 2,000배 빠른 특징에 시선이 가더라구요. 이런 속도 차이가 가능한 것은 TypeScript-JSON을 활용한 것인데요.</p>\n<p>코드를 컴파일러 수준에서 분석하여 최적의 런타임 코드를 만들어주는 AOT(Ahead Of Time) 컴파일을 사용한다고 합니다!</p>\n<p><del>사실 전 무슨말인지 하나도 모르겠더라구요 😭</del></p>\n<p>자세한 내용이 궁금하시면 제일 상단에 링크를 봐주세요!</p>\n<p>느낀점: 어떻게 개발되었는지와 사용 방법은 아직까지 잘 모르겠지만 부족함을 느끼고 공부해야겠다는 다짐이 생겼습니다.</p>\n<hr>\n<h3 id=\"조헌일님-발표-소감\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%ED%97%8C%EC%9D%BC%EB%8B%98-%EB%B0%9C%ED%91%9C-%EC%86%8C%EA%B0%90\" aria-label=\"조헌일님 발표 소감 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조헌일님 발표 소감</h3>\n<p>NestJS 기반 서버리스 트랜스코딩 파이프라인에 대한 발표 내용입니다.</p>\n<p>팀 스파르타에 일원으로 개발자로 근무중이신 조헌일님의 발표였는데요.</p>\n<p>발표의 핵심 내용은 VOD 트랜스코딩 파이프라인을 설계하게 된 과정이었습니다.</p>\n<p>느낀점: VOD 관련 서비스를 하는 곳으로 이직을 하게 된다면 참고할 자료로 너무나 좋은 발표였으나 그 외에는 흥미가 가진 않았어요.</p>\n<hr>\n<h3 id=\"김인성님-발표-소감\" style=\"position:relative;\"><a href=\"#%EA%B9%80%EC%9D%B8%EC%84%B1%EB%8B%98-%EB%B0%9C%ED%91%9C-%EC%86%8C%EA%B0%90\" aria-label=\"김인성님 발표 소감 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>김인성님 발표 소감</h3>\n<p><strong>김인성님의 NestJS에서 AOP 우아하게 적용하기</strong>는 NestJS를 개발하며 AOP에 관심이 생긴 저에게 정말 많은 흥미를 준 발표 제목이었습니다.</p>\n<p>Viva Republica (Toss) - Node.js Developer로 근무를 하시기에 발표를 바라보는 저의 눈이 더욱 반짝였어요!</p>\n<p>내용은.. 너무나 어려웠기에 제 능력으로 이 포스트에 담을 수 없기에 소감 정도로만 깔끔하게 마무리하겠습니다!</p>\n<p>느낀점: 메타데이터를 활용해서 뭐 어쩌구 저쩌구.. 깊게 더 깊게 파고든다.₩!!@~의 느낌이라 제가 나중에 더 능력있는 개발자로 성장하게 된다면 다시한번 발표를 참고할만한 좋은 내용이었어요!</p>\n<hr>\n<h3 id=\"이경석님-발표-소감\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EA%B2%BD%EC%84%9D%EB%8B%98-%EB%B0%9C%ED%91%9C-%EC%86%8C%EA%B0%90\" aria-label=\"이경석님 발표 소감 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이경석님 발표 소감</h3>\n<p>겜퍼의 개발자로 근무중이신 이경석님의 발표 소감입니다.</p>\n<p>테스트 코드 작성 방법에 대해 발표를 하셨는데 제가 생각했던 테스트와 많이 달라서 신선했습니다.</p>\n<p>기존 도메인 모델 내에 종속되어있는 Nest와 TypeORM을 역전환해 Nest와 TypeORM이 도메인 모델을 품고있는 형태로 전환하는 발표였는데 발표를 듣는 동안 ??????가 머리속을 가득 채웠죠.</p>\n<p>느낀점: 테스트에 소요되는 시간을 절약한다는 접근은 저도 매우 동의하나 저렇게까지 해야하나에 대한 의문도 같이 들었고.. 흠 막 끌리는 내용은 아니었지만 시야를 넓히기에는 좋은 발표였습니다!</p>\n<hr>\n<h3 id=\"차진혁님-발표-소감\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%A7%84%ED%98%81%EB%8B%98-%EB%B0%9C%ED%91%9C-%EC%86%8C%EA%B0%90\" aria-label=\"차진혁님 발표 소감 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차진혁님 발표 소감</h3>\n<p>마지막으로 Superb AI에서 근무중이신 차진혁님의 발표 소감입니다.</p>\n<p>RxJS를 사용하는 Interceptor 단에서 RxJS를 활용해 성능 개선을 하는 발표였어요.</p>\n<p>느낀점: 기대하고 있던 내용과는 많이 달랐지만 인터셉터에서 어떤 기술이 적용되는지와 어떻게 활용하면 좋을지에 대해 감각을 기르기 좋은 발표였습니다.</p>\n<hr>\n<p>이렇게 소감에 대해 정리해봤는데요. 생각보다 내용이 짧아서 저도 당황했어요 😅</p>\n<p><strong>행사에 참여해서 받은 굿즈 사진 올리면서 이번 포스팅을 마무리하겠습니다!</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/199618426-9f87daca-6f0d-4620-928a-d7a1c7895adf.jpeg\" alt=\"같이 참관한 지인들과!\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/199618421-08755144-29b6-4c86-95da-7eecc93ec13f.jpeg\" alt=\"작업할 때 입은 굿즈\"></p>","frontmatter":{"date":"October 20, 2022","title":"[EVENT] NestJS Assemble! - 2번째 Nest 코리아 밋업 후기","categories":"EVENT","author":"hoonloper","emoji":"🎊"},"fields":{"slug":"/event/nestjs2/"}},"prev":{"id":"f1cfcb7c-db6a-5e27-aba8-1d63408568ff","html":"<p><del>사내에서 몽고DB를 다루기 때문에 좀 더 깊게 공부하려고 정리한 글입니다.</del></p>\n<h2 id=\"nosql이란\" style=\"position:relative;\"><a href=\"#nosql%EC%9D%B4%EB%9E%80\" aria-label=\"nosql이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL이란?</h2>\n<p>NoSQL은 Not Only SQL, SQL 뿐만 아니다라는 의미를 지니고 있습니다. 즉, SQL을 사용하는 관계형 데이터베이스가 아닌 데이터베이스를 의미합니다.</p>\n<blockquote>\n<p>대표적인 관계형 데이터베이스로는 MySQL, Oracle, PostgreSQL이 있고, NoSQL 진영에는 이 포스트에서 다루는 MongoDB와 Redis, HBase 등이 있습니다.</p>\n</blockquote>\n<p>그래서 NoSQL은 왜 탄생하게 됐을까요? RDBMS만으로 충분하지 않을까?라는 의문이 있습니다. 하지만 RDBMS은 은총알이 아니었고 분명한 한계점이 있죠. NoSQL은 다음과 같이 RDBMS에선 하기 힘든 일을 쉽게 지원합니다.</p>\n<ul>\n<li>수평 확장 가능한 분산 시스템</li>\n<li>Schema-less</li>\n<li>완화된 ACID</li>\n</ul>\n<h2 id=\"rdbms-vs-nosql\" style=\"position:relative;\"><a href=\"#rdbms-vs-nosql\" aria-label=\"rdbms vs nosql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RDBMS vs NoSQL</h2>\n<p>인터넷에 RDBMS와 NoSQL의 비교라고 검색하면 다음과 같은 표를 많이 볼 수 있다.</p>\n<h3 id=\"rdbms-nosql\" style=\"position:relative;\"><a href=\"#rdbms-nosql\" aria-label=\"rdbms nosql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RDBMS NoSQL</h3>\n<p>적합한 사용례 데이터 정합성이 보장되어야 하는 은행 시스템 낮은 지연 시간, 가용성이 중요한 SNS 시스템\n데이터 모델 정규화와 참조 무결성이 보장된 스키마 스키마가 없는 자유로운 데이터 모델\n트랜젝션 강력한 ACID 지원 완화된 ACID(BASE)\n확장 하드웨어 강화(Scale up) 수평 확장 가능한 분산 아키텍처(Scale out)\nAPI SQL 쿼리 객체 기반 API 제공\n마치 RDBMS에 수평 확장이 불가능한 것 처럼 써놨지만 MySQL Replication이나 MySQL Cluster가 존재하여 수평 확장이 불가능한 것은 아니다. 그리고 NoSQL에서도 ACID가 불가능하지 않다. MongoDB의 경우 분산 트랜젝션까지도 지원하고 있다. 단, NoSQL 데이터베이스는 대게 분산 아키텍처를 염두하고 출시된 제품이 많아 더 편리하다는 장점이 있고 BASE 기반이기 때문에 완전한 ACID가 아니다. 점점 서로의 장점을 흡수하고 있기 때문에 위 표는 참고 정도로만 보면 될 것 같다.</p>\n<blockquote>\n<p>그래서 MongoDB가 뭔데?\nMongoDB는 앞서 설명한 것 처럼 NoSQL 데이터베이스고 다음 세 가지 특징을 가지고있다.</p>\n</blockquote>\n<p>Document\nBASE\nOpen Source\n데이터는 Document 기반으로 구성되어있고, ACID 대신 BASE를 택하여 성능과 가용성을 우선시한다. 그리고 오픈 소스라는 점 덕분에 무료로 이용이 가능하다.</p>\n<p>여담으로 MongoDB는 분명 몇 년전까진 AGPL 라이센스였는데 어느 순간 SSPL(Server Side Public License)로 변경되었다. 아마 AWS(DocumentDB)나 Azure(CosmosDB)에서 별도 계약 없이 MongoDB를 이용해 돈을 벌었기 때문이 아닐까 싶다. 아무튼 아직 오픈 소스기는 하다1. MongoDB의 발전을 위한다면 클라우드 서비스 내 제품 대신 MongoDB Atlas를 이용하는 것이 좋을 것 같다. 비용도 AWS DocumentDB보단 저렴하게 시작할 수 있다.</p>\n<p>Document\nMongoDB는 Document 기반 데이터베이스다. Database > Collection > Document > Field 계층으로 이루어져 있으며 Document는 RDBMS의 Row에 해당한다. 계층은 RDBMS와 유사하다.</p>\n<p>RDMBS와 MongoDB 데이터 계층 구조\n흥미로운 점은 Document 기반 데이터베이스은 RDBMS와 다르게 자유로이 데이터 구조를 잡을 수 있다는 점이다. MongoDB는 BSON으로 데이터가 쌓이기 때문에 Array 데이터나 Nested한 데이터를 쉽게 넣을 수 있다.</p>\n<p>JSON(BSON)의 형태\n위 데이터 구조에서 ObjectId라는 생소한 타입을 볼 수 있다. ObjectId는 RDBMS의 Primary Key와 같이 고유한 키를 의미하는데 차이점은 Primary Key는 DBMS가 직접 부여한다면 ObjectId는 클라이언트에서 생성한다는 점이다. 이는 MongoDB 클러스터에서 Sharding된 데이터를 빠르게 가져오기 위함인데 Router(mongos)는 ObjectId를 보고 데이터가 존재하는 Shard에서 데이터를 요청할 수 있다. 의아하게도 MongoDB 서버에서 알아서 ObjectId를 부여해서 저장해도 될 것 같은데 딱히 지원해주지 않는다. 참고로 ObjectId를 넣지않고 저장한다면 데이터가 그대로 저장된다.</p>\n<p><a href=\"https://developer.mongodb.com/quickstart/bson-data-types-objectid/\">https://developer.mongodb.com/quickstart/bson-data-types-objectid/</a>\nObjectId는 세 영역으로 나눠져있다. 각각 첫 4 byte는 UNIX Timestamp 정보를 담고있고 다음 5 byte는 랜덤한 값으로 이루어져 있는데 3 byte와 2 byte로 나뉜다. 첫 3 byte는 클라이언트의 머신별로 고유한 키(mac 주소나 ip 주소)를 이용하여 랜덤 값을 만들어 사용한다. 다음 2 byte는 process id를 이용한다. 5 byte를 채운 후 마지막 2 byte는 Auto Increment되는 값으로 구성된다.</p>\n<p>이쯤되면 ObjectId가 충돌날 가능성이 어느 정도일지 궁금할 수 있다. 충돌이 발생하려면 같은 시간, 기기에서 만들어낸 해시 값이 일치하고 우연히 같은 process id를 가지고 있으며 정말 우연히 increase된 count가 일치해야 한다. 확률은 계산해보지 않았지만 거의 충돌날 일은 없을 것 같다.2</p>\n<p>다음으로 MongoDB 데이터 조작에 대해서 알아보자. MongoDB와 같은 NoSQL은 이름처럼 SQL을 사용하지 않고 별도로 제공하는 API를 통해 데이터를 건들 수 있다. MongoDB의 경우 자바스크립트 엔진 SpiderMonkey를 사용하여 API를 제공한다. 따라서 자바스크립트를 조금은 알아야한다.</p>\n<p>Insert Query\n데이터를 삽입하는 쿼리를 보면 SQL과는 모습이 많이 다른 것을 알 수 있다. 마치 클래스에서 메서드를 통해 실행하는 모습인데, 이처럼 MongoDB는 객체 조작을 통해 데이터를 관리할 수 있다.</p>\n<p>BASE\nBASE는 ACID와 대립되는 개념으로 다음 세 가지로 이루어져있다.</p>\n<p>Basically Avaliable\n기본적으로 언제든지 사용할 수 있다는 의미를 가지고 있다.\n즉, 가용성이 필요하다는 뜻을 가진다.\nSoft state\n외부의 개입이 없어도 정보가 변경될 수 있다는 의미를 가지고 있다.\n네트워크 파티션 등 문제가 발생되어 일관성(Consistency)이 유지되지 않는 경우 일관성을 위해 데이터를 자동으로 수정한다.\nEventually consistent\n일시적으로 일관적이지 않은 상태가 되어도 일정 시간 후 일관적인 상태가 되어야한다는 의미를 가지고 있다.\n장애 발생시 일관성을 유지하기 위한 이벤트를 발생시킨다.\n이처럼 BASE는 ACID와는 다르게 일관성을 어느정도 포기하고 가용성을 우선시한다. 즉, 데이터가 조금 맞지 않더라도 일단 내려준다는 뜻이다.</p>\n<p>참고로 굳이 왜 Basically Avaliable이나 Eventually consistent처럼 어렵게 표현했는지 의아했는데 Acid(산)과 대립되는 느낌을 주기 위해 억지로 Base(염기)로 맞췄다는 소리를 들었다. 물론 진짜인진 모르겠지만 꽤 재밌는 이야기라고 생각한다.</p>\n<p>ACID?\n마치 MongoDB는 전혀 ACID하지 않다는 식으로 글을 썼지만 사실 MongoDB는 트랜젝션을 제공한다. 아직 ACID하지 않을 때도 Single-Document Transaction을 제공하고 MongoDB 4.0부터는 Multi-Document Transaction을 제공함으로서 ACID를 충족했다. 이후 MongoDB 4.2에서 Shard Cluster Transacion을 제공하면서 분산 트랜젝션까지 가능해졌다.</p>\n<p>MongoDB는 분산 시스템이 핵심이다\n이번엔 MongoDB의 분산 시스템에 대해서 다뤄보자. MongoDB에서 분산 시스템은 기본으로 깔리고 들어가는만큼 반드시 알고 넘어가야하는 부분이다.</p>\n<p>Thinking face가 생각한 것 처럼 웹 서비스가 발전하면서 데이터 무결성을 버리면서까지 더 많은 데이터, 빠른 성능, 수평 확장이 필요한 데이터베이스가 필요해졌다. 그런 요구 사항으로 인해 MongoDB가 탄생했다.</p>","frontmatter":{"date":"November 02, 2022","title":"[CS] MongoDB","categories":"CS","author":"hoonloper","emoji":"💾"},"fields":{"slug":"/cs/mongodb/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/skills/promise-all/","nextSlug":"/event/nestjs2/","prevSlug":"/cs/mongodb/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}