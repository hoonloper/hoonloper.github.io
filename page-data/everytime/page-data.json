{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/everytime/",
    "result": {"data":{"cur":{"id":"e37cf59e-4880-501e-86a0-09e752347a9c","html":"<p>첫번째 게시글을 작성해봤습니다.</p>\n<p>추후 업데이트 될 게시글들을 기대해 주세요!</p>","excerpt":"첫번째 게시글을 작성해봤습니다. 추후 업데이트 될 게시글들을 기대해 주세요!","frontmatter":{"date":"August 21, 2022","title":"모애-타임[에브리 타임 클론 코딩]","categories":"프로젝트","author":"hoonloper","emoji":"🧢"},"fields":{"slug":"/everytime/"}},"next":{"id":"2bf346dc-8dae-558d-be4d-e8d79b8e4080","html":"<iframe width=\"928\" height=\"522\" src=\"https://www.youtube.com/embed/DbXRvWfqHCk\" title=\"테크톡🎤 시간복잡도, 공간복잡도 - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n## 빅-오(Big-O)는 무엇일까?\n<p>-> 간단하게 설명하면 알고리즘의 효율성을 나타내는 지표 혹은 언어입니다. Big-O를 확실히 이해하고 있어야 알고리즘을 구현할 때 큰 고비를 해결할 수 있습니다. 또한, Big-O에 대한 개념을 몰라 난처한 상황에 놓이거나 본인 코드의 개선점을 절대 찾지 못할 수도 있으니 꼭 이해하고 숙지했으면 합니다.</p>\n<h2 id=\"빅-오big-o는-무엇일까\" style=\"position:relative;\"><a href=\"#%EB%B9%85-%EC%98%A4big-o%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" aria-label=\"빅 오big o는 무엇일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빅-오(Big-O)는 무엇일까?</h2>\n<p>-> 간단하게 설명하면 알고리즘의 효율성을 나타내는 지표 혹은 언어입니다. Big-O를 확실히 이해하고 있어야 알고리즘을 구현할 때 큰 고비를 해결할 수 있습니다. 또한, Big-O에 대한 개념을 몰라 난처한 상황에 놓이거나 본인 코드의 개선점을 절대 찾지 못할 수도 있으니 꼭 이해하고 숙지했으면 합니다.</p>\n<h2 id=\"시간복잡도란\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%9E%80\" aria-label=\"시간복잡도란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간복잡도란?</h2>\n<p>-> 여러분들이 택배 기사라고 가정해 봅니다. 수많은 택배 물량을 해소하려면 택배 차량의 최대 적재량으로 배송하며 빠른 시간 내에 모든 가정에 배달을 완료해야 할 것입니다. 이 상황에서 택배의 물량이 감당하지 못할만큼 쏟아진다면 여러분들은 어떻게 할 것 같나요? 택배 차량의 수를 늘리든지 조금이라도 더 빨리 배송하면서 하나의 택배라도 더 배달하려고 할 것입니다. 여기서, 택배 차량의 적재량을 늘릴 수 있게 공간을 늘린다고 하거나 택배 차량의 성능을 업그레이드 또는 비행기로 운반한다면 먼 거리를 보다 빠른 속도로 더 많은 택배를 배송할 수 있을 것입니다.</p>\n<p>이것이 바로 점근적 <strong>실행 시간(Asymptotic runtime)</strong>, 또는 Big-O 시간에 대한 개념입니다.</p>\n<h3 id=\"1-택배-배송\" style=\"position:relative;\"><a href=\"#1-%ED%83%9D%EB%B0%B0-%EB%B0%B0%EC%86%A1\" aria-label=\"1 택배 배송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 택배 배송</h3>\n<p>O(n) - n이 배송해야 할 물품이라고 생각해봅시다. 택배 물량이 늘어나면 늘어날수록 배송 시간 또한 선형적으로 증가합니다.</p>\n<h3 id=\"2-비행기-배송-또는-택배-차량-성능-상승\" style=\"position:relative;\"><a href=\"#2-%EB%B9%84%ED%96%89%EA%B8%B0-%EB%B0%B0%EC%86%A1-%EB%98%90%EB%8A%94-%ED%83%9D%EB%B0%B0-%EC%B0%A8%EB%9F%89-%EC%84%B1%EB%8A%A5-%EC%83%81%EC%8A%B9\" aria-label=\"2 비행기 배송 또는 택배 차량 성능 상승 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 비행기 배송 또는 택배 차량 성능 상승</h3>\n<p>O(1) - 배송 물량에 상관없이 일정한 시간으로 배송 예정일에 맞춰 배송을 끝마칠 수 있습니다. 즉, 상수시간만큼 소요됩니다.</p>\n<p>여기서 선형식은 시간이 어떻게 흐르든 결국 상수를 뛰어넘게 됩니다. 이 외에도 다양한 실행 시간이 존재합니다.</p>\n<p>O(logN), O(NlogN), O(N), O(N^2), O(2^N) 등이 있으며 너비가 w미터이고 높이가 h미터인 울타리를 색칠하는 시간을 O(wh)로 표기할 수 있으며 p번의 페인트를 덧칠한다면 O(whp)의 시간이 소요됩니다.</p>\n<ul>\n<li><strong>Big-O</strong> : 시간의 상한을 나타냅니다. (최악의 경우)</li>\n<li><strong>Big-θ</strong> : 등가 개념 또는 하한을 나타냅니다. (최선의 경우)</li>\n<li><strong>Big-Ω</strong> : 빅오와 빅세타 둘 다 의미합니다. (평균의 경우)</li>\n</ul>\n<h2 id=\"최선의-경우-최악의-경우-평균적인-경우\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%84%A0%EC%9D%98-%EA%B2%BD%EC%9A%B0-%EC%B5%9C%EC%95%85%EC%9D%98-%EA%B2%BD%EC%9A%B0-%ED%8F%89%EA%B7%A0%EC%A0%81%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-label=\"최선의 경우 최악의 경우 평균적인 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최선의 경우, 최악의 경우, 평균적인 경우</h2>\n<p>-> 퀵 정렬을 예로들어 살펴보겠습니다. 퀵 정렬은 ‘축’이 되는 원소 하나를 무작위로 뽑은 뒤 이보다 작은 원소들은 앞에, 큰 원소들은 뒤에 놓이도록 원소의 위치를 바꿉니다. 그 결과 ‘부분 정렬’이 완성되고, 그 뒤 왼쪽과 오른쪽 부분을 이와 비슷한 방식으로 재귀적으로 정렬해 나갑니다.</p>\n<ul>\n<li>최선의 경우\n<ul>\n<li>만약 모든 원소가 동일하다면 퀵정렬은 평균적으로 한 차례만 순회하고 끝날 것입니다. [O(N)]</li>\n</ul>\n</li>\n<li>최악의 경우\n<ul>\n<li>배열에서 가장 큰 원소가 계속해서 축이 된다면 재귀 호출이 배열을 절반 크기의 부분 배열로 나누지 못하고 고작 하나 줄어든 크기의 부분 배열로 나누게 됩니다.[O(N^2)]</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>평균적인 경우\n<ul>\n<li>위와 같이 최선과 최악의 경우가 흔히 발생하는 것은 아닙니다. [O(NlogN)]</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"공간복잡도란\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%9E%80\" aria-label=\"공간복잡도란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공간복잡도란?</h2>\n<p>알고리즘에서는 시간뿐 아니라 메모리(혹은 공간) 또한 신경써야 합니다.</p>\n<p>공간복잡도는 시간 복잡도와 평행선을 달리는 개념입니다. 크기가 n인 배열을 만들고자 한다면 O(n)의 공간이 필요합니다. n x n 크기의 2차원 배열을 만들고자 한다면 O(n^2)의 공간이 필요합니다.</p>\n<p>재귀 호출에서 사용하는 스택 공간 또한 공간 복잡도 계산에 포함됩니다.</p>\n<h3 id=\"상수항은-무시\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%88%98%ED%95%AD%EC%9D%80-%EB%AC%B4%EC%8B%9C\" aria-label=\"상수항은 무시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상수항은 무시!</h3>\n<p>Big-O는 단순히 증가하는 비율을 나타내는 개념이므로 특수한 입력에 한해 O(N) 코드가 O(1) 코드보다 빠르게 동작하는 것은 가능성이 있습니다.</p>\n<p>이런 이유로 수행 시간에서 상수항을 무시합니다. 즉 O(2N)이든 O(64N)이든 O(N)으로 표기합니다.</p>\n<p>하지만, O(N)이 언제나 O(2N)보다 나은 것은 아닙니다.</p>\n<h3 id=\"지배적이지-않은-항은-무시\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EB%B0%B0%EC%A0%81%EC%9D%B4%EC%A7%80-%EC%95%8A%EC%9D%80-%ED%95%AD%EC%9D%80-%EB%AC%B4%EC%8B%9C\" aria-label=\"지배적이지 않은 항은 무시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지배적이지 않은 항은 무시!</h3>\n<p>O(N^2+N)과 같은 수식이 있을 때는 어떻게 해야 할까요? 두번째 N은 상수항은 아니지만 특별히 중요한 항도 아닙니다. O(N^2+N^2)은 O(N^2)가 됩니다. N^2항을 무시해도 된다면 그보다 작은 N항은 무시해도 됩니다.</p>\n<ul>\n<li>O(N^2+N)은 O(N^2)이 된다.</li>\n<li>O(N+logN)은 O(N)이 된다.</li>\n<li>O(5*2^N+1000N^100)은 O(2^N)이 된다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186401538-f546df5e-28e8-48bf-8736-bcd32bc32674.png\" alt=\"image\"></p>\n<p>위 그래프와 같이 O(N^2)은 O(N)보다 맣이 느리지만 O(2^N)이나 O(N!)보다는 느리지 않고, 최악의 경우보다 느린 경우는 생각보다 많습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>첫번째 코드입니다. 이 코드에서는 A의 일이 끝마쳐진뒤 B의 일을 수행합니다. 시간복잡도는 O(I+J)가 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>두번째 코드입니다. 이 코드에서는 A의 각 원소에 대해 B의 일을 수행합니다. 시간복잡도는 O(I*J)가 됩니다.</p>\n<p><strong>즉, 첫번째 코드의 형태라면 수행 시간을 더하는 형태이고, 두번째 코드의 형태라면 수행 시간을 곱해야 합니다.</strong></p>\n<h2 id=\"상환-시간\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%99%98-%EC%8B%9C%EA%B0%84\" aria-label=\"상환 시간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상환 시간</h2>\n<p>ArrayList(동적 가변크기 배열)는 배열의 역할을 함과 동시에 크기가 자유롭게 조절되는 자료 구조입니다.</p>\n<p>배열이 가득 차 있는 경우를 생각해보면 배열에 N개의 원소가 들어있을 때 새로운 원소를 삽입하려면 O(N)이 걸립니다. 크기가 2N인 배열을 새로 만들고 기존의 모든 원소를 새 배열로 복사해야 하기 때문입니다. 따라서 이 경우 삽입 연산은 O(N) 시간이 소요됩니다.</p>\n<p>하지만, 배열이 가득 차 있는 경우는 극히 드물기에 대다수의 경우에는 배열에 가용 공간이 존재하고 이때의 삽입 연산은 O(1)이 걸립니다.</p>\n<p>최악의 경우는 가끔 발생하지만 한번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 수행 시간을 분할 상환한다는 개념입니다.</p>\n<p>즉, 1에서 X까지 2배씩 증가하는 수열과 X에서 1까지 절반씩 감소하는 수열을 분할 상환해보면 결국 필요한 시간은 O(1)이다.</p>\n<h3 id=\"logn-수행-시간\" style=\"position:relative;\"><a href=\"#logn-%EC%88%98%ED%96%89-%EC%8B%9C%EA%B0%84\" aria-label=\"logn 수행 시간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>logN 수행 시간</h3>\n<p>이진 탐색을 생각해봅니다. 이진 탐색은 N개의 정렬된 원소가 들어있는 배열에서 원소 x를 찾을 때 사용됩니다.</p>\n<p>먼저 원소 x와 배열의 중간값을 비교합니다. <strong>‘x중간값’을 만족하면 이를 반환합니다. ‘x &#x3C; 중간값’일 때는 배열의 왼쪽부분을 재탐색하고 ‘x > 중간값’일 때는 배열의 오른쪽 부분을 재탐색합니다.</strong></p>\n<p>N을 절반씩 나누는 과정에서 몇 단계만에 1이 되는지에 따라 결정됩니다.</p>\n<p>즉, 2^k = N을 만족하는 k는 로그(log)입니다.</p>\n<p>2^4 = 16 → log16 = 4, logN = k → 2^k = N</p>\n<p>어떤 문제에서 원소의 개수가 절반씩 줄어든다면 그 문제의 수행 시간은 O(logN)이 될 가능성이 큽니다.</p>\n<p>같은 원리로, 균형 이진 탐색 트리에서 원소를 찾는 문제도 O(logN)입니다. 매 단계마다 원소의 대소를 비교한 뒤 왼쪽 혹은 오른쪽으로 내려갑니다. 각 단계에서 검색해야 할 노드의 개수가 절반씩 줄어들게 되므로, 문제 공간 또한 절반씩 줄어듭니다.</p>\n<h3 id=\"재귀적으로-수행-시간-구하기\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\"재귀적으로 수행 시간 구하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀적으로 수행 시간 구하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 코드를 보고 함수가 두번 호출되었으니 O(N^2)이라고 생각할 수 있는데 틀렸습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186401606-a7f766f4-8957-484e-9af0-c12a774b3134.png\" alt=\"image\"></p>\n<p>전체 노드의 개수는 2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^N (= 2^(N+1) -1)이 됩니다.</p>\n<p>여기서 다수의 호출로 이루어진 재귀 함수에서 수행 시간은 보통 O(분기(재호출)^깊이)로 표현됩니다.</p>\n<p>따라서, 위 수행 시간은 O(2^N)이 됩니다.</p>\n<p>이 알고리즘에서 공간복잡도는 O(N)이 될 것입니다. 전체 노드의 개숮는 O(2^N)이지만 특정 시각에 사용하는 공간의 크기는 O(N)입니다.</p>","frontmatter":{"date":"August 01, 2022","title":"\\[Tech-Talk\\]시간복잡도, 공간복잡도","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/techBigO/"}},"prev":{"id":"58126f90-a9b3-5a73-8645-c2e23371d859","html":"<p>첫번째 게시글을 작성해봤습니다.</p>\n<p>추후 업데이트 될 게시글들을 기대해 주세요!</p>","frontmatter":{"date":"August 21, 2022","title":"인덕대학교 36대 대의원회 의장","categories":"경험","author":"hoonloper","emoji":"🧢"},"fields":{"slug":"/student/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/everytime/","nextSlug":"/modern-agile-team/techBigO/","prevSlug":"/student/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}