{"componentChunkName":"component---src-templates-blog-template-js","path":"/algorithm/bruteforce/","result":{"data":{"cur":{"id":"bb3116a1-79dc-59bc-af4c-8b1c91990ddd","html":"<h3 id=\"안녕하세요-이번-포스트는-완전-탐색에-대해-알아보겠습니다-\" style=\"position:relative;\"><a href=\"#%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-%EC%9D%B4%EB%B2%88-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B2%A0%EC%8A%B5%EB%8B%88%EB%8B%A4-\" aria-label=\"안녕하세요 이번 포스트는 완전 탐색에 대해 알아보겠습니다  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>안녕하세요. 이번 포스트는 완전 탐색에 대해 알아보겠습니다 :)</h3>\n<h2 id=\"완전탐색brute-force이란\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84%ED%83%90%EC%83%89brute-force%EC%9D%B4%EB%9E%80\" aria-label=\"완전탐색brute force이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전탐색(brute force)이란?</h2>\n<p>우선 영어 단어 해석부터 살펴보겠습니다. brute force는 무식한? 힘으로 해석이 되는데요. 즉, 가능한 모든 경우의 수를 모두 탐색하면서 요구조건에 충족되는 결과만을 가져오기에 붙은 이름이지 않을까 생각이 들어요!</p>\n<p>완전 탐색 알고리즘이 주는 강점은 예외 없이 정답만을 출력한다는 것입니다.</p>\n<ul>\n<li>\n<p>일반적 방법으로 문제를 해결하기 위해서는 모든 자료를 탐색해야 하기 때문에 특정한 구조를 전체적으로 탐색할 수 있는 방법을 필요로 합니다.</p>\n</li>\n<li>\n<p>알고리즘 설계의 가장 기본적인 접근 방법은 해가 존재할 것으로 예상되는 모든 영역을 전체 탐색하는 방법입니다.</p>\n</li>\n<li>\n<p>선형 구조를 전체적으로 탐색하는 순차 탐색, 비선형 구조를 전체적으로 탐색하는 깊이 우선 탐색(DFS, Depth First Search)과 너비 우선 탐색(BFS, breadth first search)이 가장 기본적인 도구입니다.</p>\n</li>\n</ul>\n<h2 id=\"100-정답만을-출력한다면-완전-탐색-알고리즘만-사용해야-하나\" style=\"position:relative;\"><a href=\"#100-%EC%A0%95%EB%8B%B5%EB%A7%8C%EC%9D%84-%EC%B6%9C%EB%A0%A5%ED%95%9C%EB%8B%A4%EB%A9%B4-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98\" aria-label=\"100 정답만을 출력한다면 완전 탐색 알고리즘만 사용해야 하나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>100% 정답만을 출력한다면 완전 탐색 알고리즘만 사용해야 하나?</h2>\n<p>결론을 우선으로 말하면 아닙니다.</p>\n<p>문제 해결 알고리즘을 사용할 때 기본적으로 <strong>2가지 규칙</strong>이 존재합니다.</p>\n<ul>\n<li>사용된 알고리즘이 문제를 해결할 수 있는가?</li>\n<li>효율적으로 동작하는가?</li>\n</ul>\n<p>첫번째 규칙인 문제를 해결할 수 있는가에는 너무나 적합한 알고리즘이겠지만 두번째인 효율적으로 동작하는가에 대해서 의문을 가질 수 밖에 없습니다.\n만약 주어진 경우가 백만번, 천만번 이런식으로 늘어난다면 결코 효율적인 알고리즘이라고 할 수 없습니다.</p>\n<h2 id=\"완전-탐색-기법을-활용하기\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-%EA%B8%B0%EB%B2%95%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"완전 탐색 기법을 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전 탐색 기법을 활용하기!</h2>\n<p>완전 탐색 알고리즘을 사용하기 위해서 다음을 고려해야 합니다.</p>\n<ul>\n<li>해결하고자 하는 문제의 경우의 수를 대략적으로 계산합니다.</li>\n<li>가능한 모든 방법을 다 고려합니다.</li>\n<li>실제 답을 구할 수 있는지 적용해봅니다.</li>\n</ul>\n<h2 id=\"각-방식에-대한-설명\" style=\"position:relative;\"><a href=\"#%EA%B0%81-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85\" aria-label=\"각 방식에 대한 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각 방식에 대한 설명</h2>\n<h3 id=\"-brute-force-기법\" style=\"position:relative;\"><a href=\"#-brute-force-%EA%B8%B0%EB%B2%95\" aria-label=\" brute force 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>① Brute Force 기법</h3>\n<p>이 방법은 반복 / 조건문을 통해 가능한 모든 방법을 단순히 찾는 경우를 의미합니다.</p>\n<p>예를 들어, 0000~9999 경우의 수 자물쇠 암호를 찾는 경우처럼 모든 경우의 수를 따지는 경우입니다.</p>\n<h3 id=\"-순열permutation\" style=\"position:relative;\"><a href=\"#-%EC%88%9C%EC%97%B4permutation\" aria-label=\" 순열permutation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>② 순열(Permutation)</h3>\n<p>우선 순열이 무엇인지 이해하자. 순열은 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법을 의미한다.</p>\n<p>즉, 순서가 중요함! 만약, 수열에서 숫자 [1, 2, 3]이 있다면, 이것을 [1, 2, 3]으로 보는 순서와 [3, 2, 1]로 보는 순서가 차이가 있음이 중요한 경우를 의미한다.</p>\n<p>같은 데이터가 입력된 수열이지만, 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전 / 다음 수열을 찾아낼 수 있는 경우를 계산할 수 있다.</p>\n<p>그래서, 만약 N개의 서로 다른 데이터가 있고 이를 순열로 나타낸다면 전체 순열의 가지 수는 N!개가 된다. 최초에 N개 중 1개가 올 수 있고 그 이후에는 각각 N-1, N-2, … , 1개가 올 수 있어 이를 모두 곱하면 N!이 되기 때문이다.</p>\n<p>[1, 2, 3]을 사전 순으로 나열하는 순열이 있다고 가정해보자. 그러면 아래와 같이 나열될 수 있을 것이다.</p>\n<p>위 내용과 같이 순열을 나열할 수 있는데, 최초 / 최종 순열을 보면 숫자가 오름 / 내림차순인 것을 알 수 있다. (중복된 숫자가 있다면 비내림 / 비오름차순으로 된다.)</p>\n<p>여기서 사전 순 순열의 규칙을 알아낼 수 있는데 N개의 데이터가 있고 1~i번째 데이터를 설정했을 때, i번째 데이터 기준 최종 순열은 i+1부터 N까지가 모두 내림차순이라는 것이다.(반대로 최초 순열이면 i+1부터 N이 오름차순!)</p>\n<p>예를 들어, 1 3 2를 보자. 이는 0번째 숫자가 1일 때의 최종 순열이다. 왜냐하면 3 2는 내림차순이기 때문이다. 그렇다면 이 다음 순열은 어떻게 구할 수 있을까?</p>\n<p>i번째가 고정이었고 i+1부터 내림차순인 경우가 최종 순열이므로 다음은 i번째부터 모두 오름차순이 되는 최초 순열이 된다. 즉, i-1까지는 변동이 없고 i는 i+1 ~ N까지의 숫자 중 자신보다 크지만 가장 작은 숫자와 교환이 되고 그 i+1~N은 다시 오름차순이 되어야 한다.</p>\n<p>그래서 1 3 2의 다음 순열은 2 1 3이다. 1 3 2에서 1은 2와 교체되었고 1 3은 오름차순으로 정렬되었다.</p>\n<p>이러한 규칙을 통해 이전 / 다음 순열을 구하거나 모든 순열을 완전 탐색으로 구하는 로직을 구현할 수 있게 된다.</p>\n<h3 id=\"-재귀recursive\" style=\"position:relative;\"><a href=\"#-%EC%9E%AC%EA%B7%80recursive\" aria-label=\" 재귀recursive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>③ 재귀(Recursive)</h3>\n<p>재귀는 말 그대로 자기 자신을 호출한다는 의미이다. 왜 자기 자신을 호출할 필요가 있을까?</p>\n<p>예를 들어, 총 4개의 숫자 중에 2개를 선택하는 경우를 모두 출력한다고 가정해보자. 1~4까지 숫자가 있고 2개를 중복 없이 선택하는 모든 경우의 수를 출력하고자 한다고 가정하자.</p>\n<p>이를 반복문으로 표현한다면 다음과 같을 것이다.</p>\n<p>for i from 1 to 4..\nchose i\nfor j from i+1 to 4..\nchose j\nprint i j</p>\n<p>손 쉽게 2중 반복문으로 해결하였다. 그런데.. 만약 숫자 N개의 숫자 중 M개를 고르는 경우라고 할 때, N과 M이 매우 큰 숫자라면 어떨까? 반복문을 수백, 수천 개를 써 내려갈 수는 없다!</p>\n<p>이를 재귀 함수를 활용한다면 자기 자신을 호출함으로써 다음 숫자를 선택할 수 있도록 이동시켜 전체 코드를 매우 짧게 줄일 수 있다!</p>\n<p>여기서 중요한 점!</p>\n<p>⑴ 재귀를 탈출하기 위한 탈출 조건이 필요!\n▶ 이것이 없으면 n개를 모두 골랐음에도 더 숫자를 선택하고자 하여 선택된 숫자를 저장하는 배열에 범위 초과 오류가 나거나, 다른 자료구조를 쓴 경우 잘못된 출력이 나올 수 있고, 혹은 무한 루프가 발생할 수 있다!</p>\n<p>⑵ 현재 함수의 상태를 저장하는 Parameter가 필요!\n▶ 위에서 우리는 curr, cnt를 통해 어떤 숫자까지 선택했는지, 몇 개를 선택했는지 전달하였다. 이것이 없다면 현재 함수의 상태를 저장할 수 없어 재귀 탈출 조건을 만들 수 없게 되거나 잘못된 결과를 출력하게 된다!</p>\n<p>⑶ Return문을 신경 쓸 것!\n▶ 위의 함수는 단순 출력이기에 void로 함수를 작성했다. 그런데, 재귀를 통해 이후의 연산 결과를 반환 후 이전 결과에 추가 연산을 수행하는 경우도 있을 수 있다. 즉, 문제 해결을 위한 정확한 정의를 수행하여야 이것을 완벽히 풀 수 있다.</p>\n<p>잘 생각해보면 Dynamic Programming과도 매우 흡사해 보인다. 그 또한 Top-Down을 사용 시 재귀를 통해 수행하는데, 기저 사례를 통해 탈출 조건을 만들고, 현재 함수의 상태를 전달하는 Parameter를 전달한다.</p>\n<p>또한 Return을 통해 필요한 값을 반환하여 정답을 구하는 연산 시에 사용하게 된다.</p>\n<p>완전 탐색의 재귀와 DP의 차이점은, DP는 작은 문제가 큰 문제와 동일한 구조를 가져 큰 문제의 답을 구할 시에 작은 문제의 결과를 기억한 뒤 그대로 사용하여 수행 속도를 빠르게 한다는 것이다.</p>\n<p>그에 반해 완전 탐색은 크고 작은 문제의 구조가 다를 수 있고, 이전 결과를 반드시 기억하는 것이 아니라 해결 가능한 방법을 모두 탐색한다는 차이가 있다.\n(즉, DP는 일반적인 재귀 중 조건을 만족하는 경우에 적용 가능!)</p>\n<h3 id=\"-비트마스크bitmask\" style=\"position:relative;\"><a href=\"#-%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%ACbitmask\" aria-label=\" 비트마스크bitmask permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>④ 비트마스크(Bitmask)</h3>\n<p>비트마스크란 비트(bit) 연산을 통해서 부분 집합을 표현하는 방법을 의미한다.</p>\n<p>비트 연산이란 다음과 같은 것들이 있다.</p>\n<ul>\n<li>And 연산(&#x26;) : 둘 다 1이면 1</li>\n<li>OR 연산(|) : 둘 중 1개만 1이면 1</li>\n<li>NOT 연산(~) : 1이면 0, 0이면 1</li>\n<li>XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0</li>\n<li>Shift 연산(&#x3C;&#x3C;, >>) : A &#x3C;&#x3C; B라고 한다면 A를 좌측으로 B 비트만큼 미는 것이다.</li>\n</ul>\n<p>① 집합 포함 여부 검사</p>\n<p>② 숫자 추가하기</p>\n<p>③ 특정 숫자 제거하기</p>\n<p>④ 토글 연산하기</p>\n<p>⑤ 전체 집합, 공집합 표현하기</p>\n<h3 id=\"-bfs-dfs-사용하기\" style=\"position:relative;\"><a href=\"#-bfs-dfs-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\" bfs dfs 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⑤ BFS, DFS 사용하기</h3>\n<p>이는 그래프 자료 구조에서 모든 정점을 탐색하기 위한 방법이다.</p>\n<p>BFS는 너비 우선 탐색으로 현재 정점과 인접한 정점을 우선으로 탐색하고 DFS는 깊이 우선 탐색으로 현재 인접한 정점을 탐색 후 그 다음 인접한 정점을 탐색하여 끝까지 탐색하는 방식이다.</p>\n<p>이 내용은 그래프 관련 포스팅(여기)과 BFS 포스팅(여기), DFS 포스팅(여기)를 참고</p>","excerpt":"안녕하세요. 이번 포스트는 완전 탐색에 대해 알아보겠습니다 :) 완전탐색(brute force)이란? 우선 영어 단어 해석부터 살펴보겠습니다. brute force는 무식한? 힘으로 해석이 되는데요. 즉, 가능한 모든 경우의 수를 모두 탐색하면서 요구조건에 충족되는 결과만을 가져오기에 붙은 이름이지 않을까 생각이 들어요! 완전 탐색 알고리즘이 주는 강점은 예외 없이 정답만을 출력한다는 것입니다. 일반적 방법으로 문제를 해결하기 위해서는 모든 자료를 탐색해야 하기 때문에 특정한 구조를 전체적으로 탐색할 수 있는 방법을 필요로 합니다. 알고리즘 설계의 가장 기본적인 접근 방법은 해가 존재할 것으로 예상되는 모든 영역을 전체 탐색하는 방법입니다. 선형 구조를 전체적으로 탐색하는 순차 탐색, 비선형 구조를 전체적으로 탐색하는 깊이 우선 탐색(DFS, Depth First Search)과 너비 우선 탐색(BFS, breadth first search)이 가장 기본적인 도구입니다. 100% …","frontmatter":{"date":"September 01, 2022","title":"[자료구조] 완전 탐색 - brute force","categories":"자료구조","author":"hoonloper","emoji":"🧠"},"fields":{"slug":"/algorithm/bruteforce/"}},"next":{"id":"d6b47a14-5574-56f1-8c1d-7a17c1f7cb17","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/wMXXdj6E444\" title=\"테크톡🎤 Refresh Token Flow - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p>인증 관련해서 아주 중요한 Refresh Token에 대해 알아보도록 하겠습니다.</p>\n<p>이 게시글을 방문한 분들은 JWT(Json Web Token)에 대한 지식이 있다고 생각하고 가볍게 짚고 넘어가겠습니다.</p>\n<aside>\n🔎 JWT가 무엇인지 모른다면 인터넷에 많은 정보들이 공유되어 있으니 확인하고 오신다면 더 유용한 정보가 될 수 있습니다.\n</aside>\n<h2 id=\"jwt란-\" style=\"position:relative;\"><a href=\"#jwt%EB%9E%80-\" aria-label=\"jwt란  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT란 ?</h2>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186412429-50eb402d-2a14-4973-8871-27bf59d0dcda.png\" alt=\"Untitled\"></p>\n<p>JWT는 Json Web Token의 약어로, JSON 형식의 데이터를 암호화해 저장하는 토큰이며 다음과 같이 세 부분으로 구성됩니다.</p>\n<ul>\n<li>헤더(header): 토큰 종류와 해시 알고리즘 정보</li>\n<li>페이로드(payload): 토큰의 내용물이 인코딩된 부분</li>\n<li>시그니처(signature): 일련의 문자열, 시그니처를 통해 토큰이 변조되었는지 여부를 확인</li>\n</ul>\n<h3 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>간편합니다. 세션/쿠키는 별도의 저장소의 관리가 필요합니다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다. 이는 Stateless 한 서버를 만드는 입장에서는 큰 강점입니다. 여기서 Stateless는 어떠한 별도의 저장소도 사용하지 않는, 즉 상태를 저장하지 않는 것을 의미합니다. 이는 서버를 확장하거나 유지,보수하는데 유리합니다.</li>\n<li>확장성이 뛰어납니다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능합니다. 예를 들어 Facebook 로그인, Google 로그인 등은 모두 토큰을 기반으로 인증을 합니다. 이에 선택적으로 이름이나 이메일 등을 받을 수 있는 권한도 받을 수 있습니다.  여기까지의 글만 봤을 때는 JWT가 세션/쿠키 방식보다 더 효율적으로 보입니다. 하지만 JWT도 단점들이 존재합니다.</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h3>\n<ul>\n<li>이미 발급된 JWT에 대해서는 돌이킬 수 없습니다. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 됩니다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능합니다. 따라서 악의적인 사용자는 유효기간이 지나기 전까지 신나게 정보들을 털어갈 수 있습니다. -> 해결책기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급합니다. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있습니다. 이는 다음 포스팅에 나올 Oauth2에 더 자세히 다루도록 하겠습니다.</li>\n<li>Payload 정보가 제한적입니다. 위에서 언급했다시피 Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있습니다. (세션/쿠키 방식에서는 유저의 정보가 전부 서버의 저장소에 안전하게 보관됩니다) 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없습니다.</li>\n<li>JWT의 길이입니다. 세션/쿠키 방식에 비해 JWT의 길이는 깁니다. 따라서 인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생하게 됩니다.</li>\n</ul>\n<h2 id=\"access-token--refresh-token\" style=\"position:relative;\"><a href=\"#access-token--refresh-token\" aria-label=\"access token  refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token &#x26; Refresh Token</h2>\n<h3 id=\"access-token\" style=\"position:relative;\"><a href=\"#access-token\" aria-label=\"access token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token</h3>\n<p>인증을 위한 JWT 입니다. 하지만 제 3자에게 탈취당할 경우 보안에 취약하기 때문에 보안을 위해 유효기간을 매우 짧게 가져갑니다. Access Token은 유효기간이 짧기 때문에 인증이 빈번히 일어난다는 단점이 있습니다.</p>\n<h3 id=\"refresh-token\" style=\"position:relative;\"><a href=\"#refresh-token\" aria-label=\"refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refresh Token</h3>\n<p>Access Token과 동일하게 인증을 위한 JWT 입니다. 하지만 유효 기간이 짧은 Access Token을 보완하기 위해 사용되기에 상대적으로 유효 기간이 깁니다. 그리고 Access Token의 유효 기간이 만료되었을 경우 새로 발급해주는 키가 됩니다.</p>\n<h2 id=\"access-token-refresh-token-인증-과정nestjs\" style=\"position:relative;\"><a href=\"#access-token-refresh-token-%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95nestjs\" aria-label=\"access token refresh token 인증 과정nestjs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Access Token + Refresh Token 인증 과정(Nest.js)</strong></h2>\n<p>우선 그림으로 먼저 확인 후 실제 작성한 코드로 어떻게 발급이 되는지 과정을 살펴보겠습니다!</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186412425-b42bc8f4-419e-41f5-bfde-c04926582344.png\" alt=\"Untitled 1\"></p>\n<aside>\n🔎 코드 작성은 인터넷에 수많은 자료가 있어 생략하고 흐름을 중점으로 봐주시면 되겠습니다.\n</aside>\n<p><strong>로그인 코드입니다.</strong></p>\n<p>accessToken 및 refreshToken을 발급받은 것을 알 수 있습니다.</p>\n<img width=\"693\" alt=\"스크린샷_2022-07-14_오전_11 30 34\" src=\"https://user-images.githubusercontent.com/78959175/186412389-3e9825d4-209c-49c3-9c8a-bdc4c142e8f7.png\">\n<img width=\"700\" alt=\"스크린샷_2022-07-14_오전_11 31 07\" src=\"https://user-images.githubusercontent.com/78959175/186412392-d0b234dc-9ee4-411d-910b-ca87a90c8713.png\">\n<p>각각의 토큰 발급 코드입니다. 유저의 정보를 payload에 담아 발급하며, 발급된 토큰은 유저 DB에 업데이트 해줍니다.</p>\n<img width=\"957\" alt=\"스크린샷_2022-07-14_오전_11 24 21\" src=\"https://user-images.githubusercontent.com/78959175/186412373-85777a35-b0ce-4be3-b074-86f544de8c7b.png\">\n<p>Postman을 이용해 요청을 보내면 정상적으로 accessToken과 refreshToken이 발급되는 것을 알 수 있습니다.</p>\n<img width=\"265\" alt=\"스크린샷_2022-07-14_오전_11 31 50\" src=\"https://user-images.githubusercontent.com/78959175/186412399-df7dd810-590d-4512-831a-fa7f8f0e9765.png\">\n<p>DB 데이터를 확인해봐도 정상적으로 Refresh Token이 저장된 것을 확인할 수 있습니다.</p>\n<p>그럼 발급받은 AccessToken으로 정상적인 요청이 되는지 확인해보겠습니다!</p>\n<p>테스트를 위해 급하게 작성한 코드라 흐름 위주로 설명할게요!\n<img width=\"903\" alt=\"스크린샷_2022-07-14_오전_11 47 25\" src=\"https://user-images.githubusercontent.com/78959175/186412402-defcffd8-9b23-4759-9f02-662f32e47279.png\"></p>\n<p>새로 발급한 토큰입니다. 해당 accessToken을 POST 요청에 실어서 보내겠습니다.</p>\n<img width=\"878\" alt=\"스크린샷_2022-07-14_오전_11 48 10\" src=\"https://user-images.githubusercontent.com/78959175/186412406-c3862188-6a05-460e-864b-3ee00699b6d8.png\">\n<p>Postman에 Authorization Bearer Token 인풋박스에 토큰을 입력해준 후 요청을 보내면!</p>\n<img width=\"359\" alt=\"스크린샷_2022-07-14_오전_11 48 47\" src=\"https://user-images.githubusercontent.com/78959175/186412411-0ce50d48-2218-4747-998d-6a4e5ee56085.png\">\n<p>쨘~!! 이렇게 성공을하게 됩니다. 그럼 토큰을 어떻게 확인하는지 보겠습니다.</p>\n<img width=\"636\" alt=\"스크린샷_2022-07-14_오전_11 49 48\" src=\"https://user-images.githubusercontent.com/78959175/186412414-a514ff77-3624-4f85-89ef-1dd270dee977.png\">\n<p>JWT 전략 코드입니다. BearerToken 값을 읽어 해독한 값이 validate에 payload 매개변수로 들어갑니다. 해당 매개변수에서 email을 추출해 DB에 있는 데이터인지 확인 후 중요한 정보인 salt는 구조분해할당으로 제외하고 user값을 리턴합니다. 인증이 되지 않을 경우 RefreshToken 인증 코드는 이따가 추가하겠습니다.</p>\n<img width=\"469\" alt=\"스크린샷_2022-07-14_오전_11 51 37\" src=\"https://user-images.githubusercontent.com/78959175/186412419-8a3ea316-342b-4f72-a431-96cc51a08cec.png\">\n<p>해당 유저값을 콘솔에 찍어보면 정상적으로 데이터 확인이 가능합니다!</p>","frontmatter":{"date":"July 15, 2022","title":"[Tech-Talk] Refresh Token","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/teck12RefreshToken/"}},"prev":{"id":"41c752e0-b625-5b1f-8c43-5394bea5e4ae","html":"<p><strong>안녕하세요! 이번 포스트는 트랜잭션에 대해 알아보고 Dead lock이 무엇인지, 어떻게 하면 피할 수 있는지를 알아보겠습니다!</strong></p>\n<h2 id=\"트랜잭션이란\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%B4%EB%9E%80\" aria-label=\"트랜잭션이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션이란?</h2>\n<p>트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미합니다.</p>\n<h2 id=\"트랜잭션-사용-목적\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81\" aria-label=\"트랜잭션 사용 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 사용 목적</h2>\n<ul>\n<li>데이터 부정합 방지<br>\n데이터베이스 서버에 여러 개의 클라이언트가 동시에 액세스하는 경우<br>\n응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우</li>\n<li>데이터베이스의 완전성(integrity) 유지 확신<br>\n데이터베이스가 수행한 일부 쿼리가 남으면 안 됨<br>\nex) 송금시 한 계좌에서 인출 → 다른 계좌에서 입금 확인<br>\n트랜잭션은 서로 간섭하면 안 됨<br>\nex) 쿼리 하나 실패 → 데이터베이스 시스템이 전체 트랜잭션 또는 실패한 쿼리 롤백</li>\n<li>거래의 안정성 확보\n테이블에서 데이터를 읽어옴<br>\n→ 다른 테이블에 데이터 입력/갱신/삭제 도중 오류 발생<br>\n→ 모든 작업 원상태로 되돌림<br>\n처리 과정이 모두 성공했을 때만 최종적으로 데이터베이스에 반영</li>\n</ul>\n<h2 id=\"트랜잭션-특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%ED%8A%B9%EC%A7%95\" aria-label=\"트랜잭션 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 특징</h2>\n<ol>\n<li>트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위입니다.</li>\n<li>사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위입니다.</li>\n<li>하나의 트랜잭션은 Commit되거나 Rollback 됩니다.</li>\n</ol>\n<h2 id=\"트랜잭션의-4가지-성질\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%EC%84%B1%EC%A7%88\" aria-label=\"트랜잭션의 4가지 성질 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션의 4가지 성질</h2>\n<h3 id=\"atomicity원자성\" style=\"position:relative;\"><a href=\"#atomicity%EC%9B%90%EC%9E%90%EC%84%B1\" aria-label=\"atomicity원자성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Atomicity(원자성)</h3>\n<ol>\n<li>트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 합니다.</li>\n<li>트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 합니다.</li>\n</ol>\n<h3 id=\"consistency일관성\" style=\"position:relative;\"><a href=\"#consistency%EC%9D%BC%EA%B4%80%EC%84%B1\" aria-label=\"consistency일관성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Consistency(일관성)</h3>\n<ol>\n<li>트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환합니다.</li>\n<li>시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 합니다.</li>\n</ol>\n<h3 id=\"isolation독립성격리성\" style=\"position:relative;\"><a href=\"#isolation%EB%8F%85%EB%A6%BD%EC%84%B1%EA%B2%A9%EB%A6%AC%EC%84%B1\" aria-label=\"isolation독립성격리성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Isolation(독립성,격리성)</h3>\n<ol>\n<li>둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없습니다.</li>\n<li>수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없습니다.</li>\n</ol>\n<h3 id=\"durablility영속성지속성\" style=\"position:relative;\"><a href=\"#durablility%EC%98%81%EC%86%8D%EC%84%B1%EC%A7%80%EC%86%8D%EC%84%B1\" aria-label=\"durablility영속성지속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Durablility(영속성,지속성)</h3>\n<ol>\n<li>성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 합니다.</li>\n</ol>\n<p><a href=\"https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation\">격리 수준에 대해 정리된 블로그 글</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">💡 트랜잭션 격리수준(Transaction Isolation Level)\n특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지 결정하는 것\n\nREAD UNCOMMITTED\n어떤 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여짐\nREAD COMMITED\n어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회 가능\nREPEATABLE READ\n트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회 가능\nSERIALIZABLE\n트랜잭션이 특정 테이블을 조회하면 다른 트랜잭션은 그 테이블의 데이터를 추가/변경/삭제 불가능\n\n→ 아래로 갈수록 트랜잭션 간 고립 정도가 높아지고 성능이 떨어짐</code></pre></div>\n<h2 id=\"commit-rollback\" style=\"position:relative;\"><a href=\"#commit-rollback\" aria-label=\"commit rollback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit? Rollback?</h2>\n<h3 id=\"commit연산\" style=\"position:relative;\"><a href=\"#commit%EC%97%B0%EC%82%B0\" aria-label=\"commit연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit연산</h3>\n<ol>\n<li>Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산입니다.</li>\n</ol>\n<h3 id=\"rollback연산\" style=\"position:relative;\"><a href=\"#rollback%EC%97%B0%EC%82%B0\" aria-label=\"rollback연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rollback연산</h3>\n<ol>\n<li>Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산입니다.</li>\n<li>Rollback시에는 해당 트랜잭션을 재시작하거나 폐기합니다.</li>\n</ol>\n<h2 id=\"️-트랜잭션-사용시-주의사항\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"️ 트랜잭션 사용시 주의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⚠️ 트랜잭션 사용시 주의사항</h2>\n<ul>\n<li>트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋습니다. 즉 트랜잭션의 범위를 최소화하라는 의미입니다.</li>\n<li>일반적으로 데이터베이스 커넥션은 개수가 제한적입니다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 됩니다.</li>\n<li>그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있습니다.</li>\n</ul>","frontmatter":{"date":"September 17, 2022","title":"[CS] 트랜잭션(transaction)","categories":"CS","author":"hoonloper","emoji":"💾"},"fields":{"slug":"/cs/transaction/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/algorithm/bruteforce/","nextSlug":"/modern-agile-team/teck12RefreshToken/","prevSlug":"/cs/transaction/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}