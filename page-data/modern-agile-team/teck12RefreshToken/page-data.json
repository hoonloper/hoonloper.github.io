{"componentChunkName":"component---src-templates-blog-template-js","path":"/modern-agile-team/teck12RefreshToken/","result":{"data":{"cur":{"id":"d6b47a14-5574-56f1-8c1d-7a17c1f7cb17","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/wMXXdj6E444\" title=\"테크톡🎤 Refresh Token Flow - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p>인증 관련해서 아주 중요한 Refresh Token에 대해 알아보도록 하겠습니다.</p>\n<p>이 게시글을 방문한 분들은 JWT(Json Web Token)에 대한 지식이 있다고 생각하고 가볍게 짚고 넘어가겠습니다.</p>\n<aside>\n🔎 JWT가 무엇인지 모른다면 인터넷에 많은 정보들이 공유되어 있으니 확인하고 오신다면 더 유용한 정보가 될 수 있습니다.\n</aside>\n<h2 id=\"jwt란-\" style=\"position:relative;\"><a href=\"#jwt%EB%9E%80-\" aria-label=\"jwt란  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT란 ?</h2>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186412429-50eb402d-2a14-4973-8871-27bf59d0dcda.png\" alt=\"Untitled\"></p>\n<p>JWT는 Json Web Token의 약어로, JSON 형식의 데이터를 암호화해 저장하는 토큰이며 다음과 같이 세 부분으로 구성됩니다.</p>\n<ul>\n<li>헤더(header): 토큰 종류와 해시 알고리즘 정보</li>\n<li>페이로드(payload): 토큰의 내용물이 인코딩된 부분</li>\n<li>시그니처(signature): 일련의 문자열, 시그니처를 통해 토큰이 변조되었는지 여부를 확인</li>\n</ul>\n<h3 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>간편합니다. 세션/쿠키는 별도의 저장소의 관리가 필요합니다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다. 이는 Stateless 한 서버를 만드는 입장에서는 큰 강점입니다. 여기서 Stateless는 어떠한 별도의 저장소도 사용하지 않는, 즉 상태를 저장하지 않는 것을 의미합니다. 이는 서버를 확장하거나 유지,보수하는데 유리합니다.</li>\n<li>확장성이 뛰어납니다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능합니다. 예를 들어 Facebook 로그인, Google 로그인 등은 모두 토큰을 기반으로 인증을 합니다. 이에 선택적으로 이름이나 이메일 등을 받을 수 있는 권한도 받을 수 있습니다.  여기까지의 글만 봤을 때는 JWT가 세션/쿠키 방식보다 더 효율적으로 보입니다. 하지만 JWT도 단점들이 존재합니다.</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h3>\n<ul>\n<li>이미 발급된 JWT에 대해서는 돌이킬 수 없습니다. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 됩니다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능합니다. 따라서 악의적인 사용자는 유효기간이 지나기 전까지 신나게 정보들을 털어갈 수 있습니다. -> 해결책기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급합니다. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있습니다. 이는 다음 포스팅에 나올 Oauth2에 더 자세히 다루도록 하겠습니다.</li>\n<li>Payload 정보가 제한적입니다. 위에서 언급했다시피 Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있습니다. (세션/쿠키 방식에서는 유저의 정보가 전부 서버의 저장소에 안전하게 보관됩니다) 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없습니다.</li>\n<li>JWT의 길이입니다. 세션/쿠키 방식에 비해 JWT의 길이는 깁니다. 따라서 인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생하게 됩니다.</li>\n</ul>\n<h2 id=\"access-token--refresh-token\" style=\"position:relative;\"><a href=\"#access-token--refresh-token\" aria-label=\"access token  refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token &#x26; Refresh Token</h2>\n<h3 id=\"access-token\" style=\"position:relative;\"><a href=\"#access-token\" aria-label=\"access token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token</h3>\n<p>인증을 위한 JWT 입니다. 하지만 제 3자에게 탈취당할 경우 보안에 취약하기 때문에 보안을 위해 유효기간을 매우 짧게 가져갑니다. Access Token은 유효기간이 짧기 때문에 인증이 빈번히 일어난다는 단점이 있습니다.</p>\n<h3 id=\"refresh-token\" style=\"position:relative;\"><a href=\"#refresh-token\" aria-label=\"refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refresh Token</h3>\n<p>Access Token과 동일하게 인증을 위한 JWT 입니다. 하지만 유효 기간이 짧은 Access Token을 보완하기 위해 사용되기에 상대적으로 유효 기간이 깁니다. 그리고 Access Token의 유효 기간이 만료되었을 경우 새로 발급해주는 키가 됩니다.</p>\n<h2 id=\"access-token-refresh-token-인증-과정nestjs\" style=\"position:relative;\"><a href=\"#access-token-refresh-token-%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95nestjs\" aria-label=\"access token refresh token 인증 과정nestjs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Access Token + Refresh Token 인증 과정(Nest.js)</strong></h2>\n<p>우선 그림으로 먼저 확인 후 실제 작성한 코드로 어떻게 발급이 되는지 과정을 살펴보겠습니다!</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186412425-b42bc8f4-419e-41f5-bfde-c04926582344.png\" alt=\"Untitled 1\"></p>\n<aside>\n🔎 코드 작성은 인터넷에 수많은 자료가 있어 생략하고 흐름을 중점으로 봐주시면 되겠습니다.\n</aside>\n<p><strong>로그인 코드입니다.</strong></p>\n<p>accessToken 및 refreshToken을 발급받은 것을 알 수 있습니다.</p>\n<img width=\"693\" alt=\"스크린샷_2022-07-14_오전_11 30 34\" src=\"https://user-images.githubusercontent.com/78959175/186412389-3e9825d4-209c-49c3-9c8a-bdc4c142e8f7.png\">\n<img width=\"700\" alt=\"스크린샷_2022-07-14_오전_11 31 07\" src=\"https://user-images.githubusercontent.com/78959175/186412392-d0b234dc-9ee4-411d-910b-ca87a90c8713.png\">\n<p>각각의 토큰 발급 코드입니다. 유저의 정보를 payload에 담아 발급하며, 발급된 토큰은 유저 DB에 업데이트 해줍니다.</p>\n<img width=\"957\" alt=\"스크린샷_2022-07-14_오전_11 24 21\" src=\"https://user-images.githubusercontent.com/78959175/186412373-85777a35-b0ce-4be3-b074-86f544de8c7b.png\">\n<p>Postman을 이용해 요청을 보내면 정상적으로 accessToken과 refreshToken이 발급되는 것을 알 수 있습니다.</p>\n<img width=\"265\" alt=\"스크린샷_2022-07-14_오전_11 31 50\" src=\"https://user-images.githubusercontent.com/78959175/186412399-df7dd810-590d-4512-831a-fa7f8f0e9765.png\">\n<p>DB 데이터를 확인해봐도 정상적으로 Refresh Token이 저장된 것을 확인할 수 있습니다.</p>\n<p>그럼 발급받은 AccessToken으로 정상적인 요청이 되는지 확인해보겠습니다!</p>\n<p>테스트를 위해 급하게 작성한 코드라 흐름 위주로 설명할게요!\n<img width=\"903\" alt=\"스크린샷_2022-07-14_오전_11 47 25\" src=\"https://user-images.githubusercontent.com/78959175/186412402-defcffd8-9b23-4759-9f02-662f32e47279.png\"></p>\n<p>새로 발급한 토큰입니다. 해당 accessToken을 POST 요청에 실어서 보내겠습니다.</p>\n<img width=\"878\" alt=\"스크린샷_2022-07-14_오전_11 48 10\" src=\"https://user-images.githubusercontent.com/78959175/186412406-c3862188-6a05-460e-864b-3ee00699b6d8.png\">\n<p>Postman에 Authorization Bearer Token 인풋박스에 토큰을 입력해준 후 요청을 보내면!</p>\n<img width=\"359\" alt=\"스크린샷_2022-07-14_오전_11 48 47\" src=\"https://user-images.githubusercontent.com/78959175/186412411-0ce50d48-2218-4747-998d-6a4e5ee56085.png\">\n<p>쨘~!! 이렇게 성공을하게 됩니다. 그럼 토큰을 어떻게 확인하는지 보겠습니다.</p>\n<img width=\"636\" alt=\"스크린샷_2022-07-14_오전_11 49 48\" src=\"https://user-images.githubusercontent.com/78959175/186412414-a514ff77-3624-4f85-89ef-1dd270dee977.png\">\n<p>JWT 전략 코드입니다. BearerToken 값을 읽어 해독한 값이 validate에 payload 매개변수로 들어갑니다. 해당 매개변수에서 email을 추출해 DB에 있는 데이터인지 확인 후 중요한 정보인 salt는 구조분해할당으로 제외하고 user값을 리턴합니다. 인증이 되지 않을 경우 RefreshToken 인증 코드는 이따가 추가하겠습니다.</p>\n<img width=\"469\" alt=\"스크린샷_2022-07-14_오전_11 51 37\" src=\"https://user-images.githubusercontent.com/78959175/186412419-8a3ea316-342b-4f72-a431-96cc51a08cec.png\">\n<p>해당 유저값을 콘솔에 찍어보면 정상적으로 데이터 확인이 가능합니다!</p>","excerpt":"인증 관련해서 아주 중요한 Refresh Token에 대해 알아보도록 하겠습니다. 이 게시글을 방문한 분들은 JWT(Json Web Token)에 대한 지식이 있다고 생각하고 가볍게 짚고 넘어가겠습니다. JWT란 ? Untitled JWT는 Json Web Token의 약어로, JSON 형식의 데이터를 암호화해 저장하는 토큰이며 다음과 같이 세 부분으로 구성됩니다. 헤더(header): 토큰 종류와 해시 알고리즘 정보 페이로드(payload): 토큰의 내용물이 인코딩된 부분 시그니처(signature): 일련의 문자열, 시그니처를 통해 토큰이 변조되었는지 여부를 확인 장점 간편합니다. 세션/쿠키는 별도의 저장소의 관리가 필요합니다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다. 이는 Stateless 한 서버를 만드는 입장에서는 큰 강점입니다. 여기서 Stateless는 어떠한 별도의 저장소도 사용하지 않는, 즉 상태를 저장하지 않는 것을 의미합…","frontmatter":{"date":"July 15, 2022","title":"[Tech-Talk] Refresh Token","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/teck12RefreshToken/"}},"next":{"id":"d513370c-8dc1-5af6-a2b5-d396f6ad95d6","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/sf8vvKtvQBY\" title=\"테크톡🎤 데이터베이스 인덱스 - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<h2 id=\"index란\" style=\"position:relative;\"><a href=\"#index%EB%9E%80\" aria-label=\"index란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index란?</h2>\n<p>인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸립니다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같은 역할을 합니다. 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 해줍니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411954-a492d973-0179-48a1-9d22-9a0845555a5e.png\" alt=\"111\"></p>\n<h2 id=\"인덱스index의-관리\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EC%9D%98-%EA%B4%80%EB%A6%AC\" aria-label=\"인덱스index의 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스(index)의 관리</h2>\n<p>DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생합니다.</p>\n<blockquote>\n<p>💡 INSERT: 새로운 데이터에 대한 인덱스를 추가함 DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함 UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함</p>\n</blockquote>\n<h2 id=\"인덱스index의-장점과-단점\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\" aria-label=\"인덱스index의 장점과 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스(index)의 장점과 단점</h2>\n<h3 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있습니다.</li>\n<li>전반적인 시스템의 부하를 줄일 수 있습니다.</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h3>\n<ul>\n<li>인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요합니다.</li>\n<li>인덱스를 관리하기 위해 추가 작업이 필요합니다.</li>\n<li>인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있습니다.</li>\n</ul>\n<p>만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있습니다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문인데, 앞에서 설명한 것처럼 UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해줍니다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것입니다.</p>\n<h3 id=\"조건-검색-where-절의-효율성\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%EA%B1%B4-%EA%B2%80%EC%83%89-where-%EC%A0%88%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1\" aria-label=\"조건 검색 where 절의 효율성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>조건 검색 Where 절의 효율성</strong></h3>\n<p>테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다. 이렇게 되면 Where절에 특정 조건에 맞는 데이터들을 찾아낼때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과 맞는지 비교해야 합니다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 하지만 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠. 이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다.</p>\n<h3 id=\"정렬-order-by-절의-효율성\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC-order-by-%EC%A0%88%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1\" aria-label=\"정렬 order by 절의 효율성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>정렬 Order by 절의 효율성</strong></h3>\n<p>인덱스(Index)를 사용하면 Order by에 의한 Sort과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이 걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다. 이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.</p>\n<h3 id=\"min-max의-효율적인-처리-가능\" style=\"position:relative;\"><a href=\"#min-max%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%B2%98%EB%A6%AC-%EA%B0%80%EB%8A%A5\" aria-label=\"min max의 효율적인 처리 가능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>MIN, MAX의 효율적인 처리 가능</strong></h3>\n<p>이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점입니다. MIN값과 MAX값을 레코드의 시작값과 끝 값 한건씩만 가져오면 되기에 FULL TABLE SCAN으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.</p>\n<blockquote>\n<p>💡 여기서 잠깐!<br>\nIndex를 남발하지 말아야 하는 이유<br>\n데이터베이스 서버에 성능 문제가 발생하면 가장 빨리 생각하는 해결책이 인덱스 추가 생성입니다. 문제가 발생할 때마다 인덱스를 생성하면서 인덱스가 쌓여가는 것은 하나의 쿼리문을 빠르게 만들 수는 있지만, 전체적인 데이터베이스의 성능 부하를 초래합니다. 조회 성능을 극대화하려 만든 객체인데 많은 인덱스가 쌓여서 INSERT, UPDATE, DELETE 시에 부하가 발생해 전체적인 데이터베이스 성능을 저하합니다. 그렇기에인덱스를 생성하는 것보다는 SQL문을 좀 더 효율적으로 짜는 방향으로 나가야 한다. 인덱스 생성은 마지막 수단으로 강구해야 할 문제이다.</p>\n</blockquote>\n<h3 id=\"인덱스index를-사용하면-좋은-경우\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EA%B2%BD%EC%9A%B0\" aria-label=\"인덱스index를 사용하면 좋은 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스(index)를 사용하면 좋은 경우</h3>\n<ul>\n<li>규모가 작지 않은 테이블</li>\n<li>INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼</li>\n<li>JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼</li>\n<li>데이터의 중복도가 낮은 컬럼</li>\n</ul>\n<p>인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요합니다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해줘야 효율적으로 인덱스를 사용할 수 있습니다.</p>\n<h3 id=\"인덱스-생성-전략\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%83%9D%EC%84%B1-%EC%A0%84%EB%9E%B5\" aria-label=\"인덱스 생성 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>인덱스 생성 전략</strong></h3>\n<p>생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를 거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.</p>\n<ol>\n<li>조건절에 자주 등장하는 컬럼</li>\n<li>항상 = 으로 비교되는 컬럼</li>\n<li>중복되는 데이터가 최소한인(분포도가 좋은) 컬럼</li>\n<li>ORDER BY 절에서 자주 사용되는 컬럼</li>\n<li>조인 조건으로 자주 사용되는 컬럼</li>\n</ol>\n<h2 id=\"인덱스의-자료-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0\" aria-label=\"인덱스의 자료 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스의 자료 구조</h2>\n<h3 id=\"1-해시-테이블hash-table\" style=\"position:relative;\"><a href=\"#1-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94hash-table\" aria-label=\"1 해시 테이블hash table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 해시 테이블(Hash Table)</h3>\n<p>해시 테이블은 key와 value를 한 쌍으로 데이터를 저장하는 자료구조입니다. (key, value)로 쌍을 표현하며, key값을 이용해 대응되는 value값을 구하는 방식입니다. 해시 충돌이라는 변수가 존재하지만 평균적으로O(1)의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411966-af1c833f-6c57-40d0-a9d7-fe1e4cb136b7.png\" alt=\"222\"></p>\n<p>해시 테이블을 이용한다면 인덱스는(key, value) = (컬럼의 값, 데이터의 위치)로 구현하는데, 해시 테이블은 실제로 인덱스에서 잘 사용되지 않습니다.</p>\n<p>그 이유는, 해시 테이블은 등호(=) 연산에 최적화되어있기 때문입니다.</p>\n<p>데이터베이스에선 부등호(&#x3C;, >) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없습니다.</p>\n<h3 id=\"2-btree-인덱스\" style=\"position:relative;\"><a href=\"#2-btree-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"2 btree 인덱스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. <strong>B+Tree 인덱스</strong></h3>\n<p>인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다. 그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.</p>\n<p>B * Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다. 구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node로 구성됩니다. 특정 컬럼에 인덱스를 생성하는 순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT 블록을 기준으로 가지가 되는 BRANCH블록을 정의하며 마지막으로 잎에 해당하는 LEAF 블록에 인덱스의 키가 되는 데이터와 데이터의 물리적 주소 정보인 ROWID를 저장합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411967-537e20e1-8a00-4f64-b877-26886751b720.png\" alt=\"333\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186411971-c8f4dbc3-787b-4d89-af6f-8a3a4d47ceac.png\" alt=\"444\"></p>","frontmatter":{"date":"June 10, 2022","title":"[Tech-Talk] Database Index","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech11DbIndex/"}},"prev":{"id":"1359b708-20b5-5a2d-9bb8-cb2d6b6db0e4","html":"<p>안녕하세요 👋🏻</p>\n<p>이번 포스트는 제가 개발을 처음 입문해 Back-End 개발자로 성장하기까지 도움을 준 모던 애자일 팀에 대해 소개하려고 합니다!</p>","frontmatter":{"date":"August 23, 2022","title":"[경험] SW 개발 동아리 Modern-Agile","categories":"경험","author":"hoonloper","emoji":"🧢"},"fields":{"slug":"/modern-agile-team/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/modern-agile-team/teck12RefreshToken/","nextSlug":"/modern-agile-team/tech11DbIndex/","prevSlug":"/modern-agile-team/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}