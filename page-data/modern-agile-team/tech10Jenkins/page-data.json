{"componentChunkName":"component---src-templates-blog-template-js","path":"/modern-agile-team/tech10Jenkins/","result":{"data":{"cur":{"id":"9e718ed5-d497-5392-9493-7d4f91ec8c49","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/srVhzwgO2xw\" title=\"테크톡🎤 젠킨스 - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411168-1028d032-fe47-43df-a6d7-e62c4f3d10a6.png\" alt=\"111\"></p>\n<h3 id=\"젠킨스란\" style=\"position:relative;\"><a href=\"#%EC%A0%A0%ED%82%A8%EC%8A%A4%EB%9E%80\" aria-label=\"젠킨스란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>젠킨스란?</h3>\n<p>소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴, 즉 CI(Continuous Integration) 툴 이라고 표현합니다.</p>\n<p>다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유영역에 있는 저장소에 빈번히 업로드함으로써 지속적 통합이 가능하도록 해주는 유용한 툴입니다.</p>\n<blockquote>\n<p>💡 모든 언어의 조합과 소스 코드 레포지토리에 대한 **지속적인 통합(Continuous integration, CI)**과 지속적 배포(continuous delivery, CD) 환경을 구축하기 위한 도구이다다. 빌드, 테스트, 배포 프로세스를 자동화하여 소프트웨어 품질과 개발 생산성을 높일 수 있다.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>웹사이트</th>\n<th>jenkins-ci.org</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>발표일</td>\n<td>2011년 2월 2일</td>\n</tr>\n<tr>\n<td>프로그래밍 언어</td>\n<td>Java</td>\n</tr>\n<tr>\n<td>최근 버전</td>\n<td>2.23.3</td>\n</tr>\n<tr>\n<td>운영체제</td>\n<td>크로스 플랫폼</td>\n</tr>\n<tr>\n<td>종류</td>\n<td>지속적 통합</td>\n</tr>\n<tr>\n<td>라이선스</td>\n<td>MIT</td>\n</tr>\n</tbody>\n</table>\n<p>젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방식이 일반적이었는데 특히 개발자들이 당일 작성한 소스들의 커밋이 모드 끝난 심야 시간대에 이러한 빌드가 타이머에 의해 집중적으로 진행됐습니다. 이를 nightly-build라 합니다.</p>\n<p>하지만, 젠킨스는 정기적인 빌드에서 한발 나아가 서브버전, Git 과 같은 버전관리시스템과 연동하여 소스의 커밋을 감지하면 자동적으로 자동화 테스트가 포함된 빌드가 작동되도록 설정할 수 있습니다.</p>\n<h3 id=\"젠킨스-장점\" style=\"position:relative;\"><a href=\"#%EC%A0%A0%ED%82%A8%EC%8A%A4-%EC%9E%A5%EC%A0%90\" aria-label=\"젠킨스 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>젠킨스 장점</h3>\n<p>개발중인 프로젝트에서 커밋은 매우 빈번히 일어나기 때문에 커밋 횟수만큼 빌드를 실행하는 것이 아닌 작업이 큐잉되어 실행될 차례를 기다립니다.</p>\n<p>코드의 변경과 함께 이뤄지는 이 같은 자동화된 빌드와 테스트 작업들은 다음과 같은 장점들이 있습니다.</p>\n<ul>\n<li>프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출</li>\n<li>자동화 테스트 수행</li>\n<li>정적 코드 분석에 의한 코딩 규약 준수여부 체크</li>\n<li>프로파일링 툴을 이용한 소스 변경에 따른 성능 변화 감시</li>\n<li>결합 테스트 환경에 대한 배포작업</li>\n<li>500여가지가 넘는 플러그인을 온라인으로 간단히 인스톨 할 수 있는 기능을 제공</li>\n<li>스크립트를 이용해 손쉽게 자신에게 필요한 기능을 추가 가능</li>\n</ul>\n<h3 id=\"각종-배치-작업의-간략화\" style=\"position:relative;\"><a href=\"#%EA%B0%81%EC%A2%85-%EB%B0%B0%EC%B9%98-%EC%9E%91%EC%97%85%EC%9D%98-%EA%B0%84%EB%9E%B5%ED%99%94\" aria-label=\"각종 배치 작업의 간략화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각종 배치 작업의 간략화</h3>\n<p>프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외에 DB셋업이나 환경설정, Deploy작업과 같은 단순 작업에 시간과 노력을 들이는 경우가 빈번합니다. 데이터베이스의 구축, 어플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 이전에 CLI로 실행되던 작업들이 젠킨스 덕분에 웹 인터페이스로 손쉽게 가능해졌습니다.</p>\n<h3 id=\"build-자동화의-확립\" style=\"position:relative;\"><a href=\"#build-%EC%9E%90%EB%8F%99%ED%99%94%EC%9D%98-%ED%99%95%EB%A6%BD\" aria-label=\"build 자동화의 확립 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Build 자동화의 확립</h3>\n<p>빌드 툴의 경우 Java는 maven과 gradle이 자리잡고 있으며, 이미 빌드 관리 툴을 이용해 프로젝트를 진행하고 있다면 젠킨스를 사용하지 않을 이유가 하나도 없습니다. 젠킨스와 연동해 빌드 자동화를 통하여 프로젝트 진행의 효율성을 높일 수 있기 때문입니다.</p>\n<h3 id=\"자동화-테스트\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%8F%99%ED%99%94-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"자동화 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자동화 테스트</h3>\n<p>젠킨스를 사용해야 하는 가장 큰 이유 중 하나이며, 사실상 자동화 테스트가 포함되지 않은 빌드는 CI자체가 불가능하다고 봐도 무방합니다. 젠킨스는 Subversion이나 Git과 같은 버전관리시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행하기 때문에 만약 개인이 미처 실시하지 못한 테스트가 있다 하여도 든든한 안전망이 되어줍니다. 제대로 테스트를 거치지 않은 코드를 커밋하게 되면 화난 젠킨스를 만날 수 있습니다.</p>\n<h3 id=\"코드-표준-준수여부-검사\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%ED%91%9C%EC%A4%80-%EC%A4%80%EC%88%98%EC%97%AC%EB%B6%80-%EA%B2%80%EC%82%AC\" aria-label=\"코드 표준 준수여부 검사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 표준 준수여부 검사</h3>\n<p>자동화 테스트와 마찬가지로 개인이 미처 실시하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여합니다.</p>\n<h3 id=\"빌드-파이프라인-구성\" style=\"position:relative;\"><a href=\"#%EB%B9%8C%EB%93%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%84%B1\" aria-label=\"빌드 파이프라인 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빌드 파이프라인 구성</h3>\n<p>2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따는 빌드 파이프라인 구성이 필요합니다. 예를 들면, 도메인 -> 서비스 -> UI와 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안됩니다. 젠킨스에서는 이러한 빌드 파이프라인의 구성을 간단히 할 수 있으며, 스크립트를 통해서 매우 복잡한 제어까지도 가능합니다.</p>\n<h1 id=\"연결된-화면\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0%EB%90%9C-%ED%99%94%EB%A9%B4\" aria-label=\"연결된 화면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결된 화면</h1>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411178-fbadcea5-4d1a-41fb-8213-7c320c12c285.png\" alt=\"222\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411179-a3f63d3d-60e9-40d6-9850-f110fc56fc71.png\" alt=\"333\"></p>\n<p>.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411181-0c07ac2f-bf9c-4c72-b103-c56513d4ec5b.png\" alt=\"444\"></p>\n<p>게다가 젠킨스의 장점으로는 Slack과의 연동으로 매번 젠킨스를 접속해 에러 유무를 판단하는 작업을 자동화해 협업툴인 Slack 메시지로 넘어오게 설정할 수 있습니다. 아래 사진은 젠킨스 결과 메시지입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411184-2dc36600-f374-47ee-a3a4-bb9b07fe4c82.png\" alt=\"555\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186411189-d3cc6893-6894-403a-b09d-5af525ea6c7f.png\" alt=\"666\"></p>","excerpt":"111 젠킨스란? 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴, 즉 CI(Continuous Integration) 툴 이라고 표현합니다. 다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유영역에 있는 저장소에 빈번히 업로드함으로써 지속적 통합이 가능하도록 해주는 유용한 툴입니다. 💡 모든 언어의 조합과 소스 코드 레포지토리에 대한 **지속적인 통합(Continuous integration, CI)**과 지속적 배포(continuous delivery, CD) 환경을 구축하기 위한 도구이다다. 빌드, 테스트, 배포 프로세스를 자동화하여 소프트웨어 품질과 개발 생산성을 높일 수 있다. 웹사이트 jenkins-ci.org 발표일 2011년 2월 2일 프로그래밍 언어 Java 최근 버전 2.23.3 운영체제 크로스 플랫폼 종류 지속적 통합 라이선스 MIT 젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방식이…","frontmatter":{"date":"May 20, 2022","title":"[Tech-Talk] 젠킨스(Jenkins)","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech10Jenkins/"}},"next":{"id":"21e0ccb4-e407-5ef9-9ede-6271cecf8b2a","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/26ZOkpDCBhQ\" title=\"테크톡🎤 테스트 코드란? - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<h2 id=\"이번-포스트는-테스트-코드에-대해-알아보겠습니다\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%88-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B2%A0%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"이번 포스트는 테스트 코드에 대해 알아보겠습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이번 포스트는 테스트 코드에 대해 알아보겠습니다.</h2>\n<h2 id=\"테스트-코드란\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%9E%80\" aria-label=\"테스트 코드란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드란?</strong></h2>\n<p>테스트코드란 내가 작성한 메서드 또는 기능이 재대로 동작하는지 테스트 하는 코드를 뜻합니다.</p>\n<p>실제로 개발 방법중 TDD라고 테스트 코드를 먼저 작성한 후 기능을 구현하는 방법도 있습니다.</p>\n<blockquote>\n<p>💡 실패하는 테스트코드 작성 -> 테스트가 성공하는 프로덕션코드 작성 -> 테스트가 성공하면 프로덕션 코드를 리팩토링</p>\n</blockquote>\n<h2 id=\"테스트-코드를-작성하는-이유\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"테스트 코드를 작성하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드를 작성하는 이유</strong></h2>\n<ol>\n<li>개발 초기 단계에 문제를 발견하게 도와줍니다.</li>\n<li>개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지를 확인할 수 있습니다.</li>\n<li>기능에 대한 불확실성을 감소시킬 수 있습니다.</li>\n<li>시스템에 대한 실제 문서를 제공합니다.(단위 테스트 자체가 문서로 사용 가능합니다.)</li>\n<li>클린한 코드를 작성할 수 있습니다.</li>\n<li>개발 시간을 단축할 수 있습니다.</li>\n</ol>\n<h2 id=\"테스트-코드를-사용하지-않는-개발-순서\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EA%B0%9C%EB%B0%9C-%EC%88%9C%EC%84%9C\" aria-label=\"테스트 코드를 사용하지 않는 개발 순서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드를 사용하지 않는 개발 순서</strong></h2>\n<ol>\n<li>프로덕션 코드를 작성합니다.</li>\n<li>서버를 실행합니다.</li>\n<li>postman과 같은 api 테스트 도구를 사용하거나 직접 화면을 만들어 버튼 등으로 통신하여 응답을 요청합니다.</li>\n<li>요청 결과를 console.log와 같은 출력을 이용하여 값을 확인합니다.</li>\n<li>에러가 나거나 원하는 결과값이 나오지 않으면 서버를 중지하고 코드를 수정합니다.</li>\n<li>1~5을 의도한 결과가 재대로 도출될 때까지 무한 반복합니다.</li>\n</ol>\n<h2 id=\"테스트의-분류\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%B6%84%EB%A5%98\" aria-label=\"테스트의 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트의 분류</strong></h2>\n<h3 id=\"유닛-테스트unit-tests\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EB%8B%9B-%ED%85%8C%EC%8A%A4%ED%8A%B8unit-tests\" aria-label=\"유닛 테스트unit tests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>유닛 테스트(Unit Tests)</strong></h3>\n<ul>\n<li>코드가 제대로 작동하는지 확인하기 위해 애플리케이션의 개별 모듈을 독립적으로 테스트(종속성과의 상호 작용없이)하는 것을 의미합니다.</li>\n<li>입력을 제공하고 출력이 예상대로인지 확인하며, 함수 또는 클래스와 같은 개별 단위 테스트입니다.</li>\n</ul>\n<h3 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a> 특징</h3>\n<ul>\n<li>가장 작은 단위의 테스트이며, 보통 메서드 레벨입니다.</li>\n<li>A라는 함수가 실행되면 B라는 결과가 나온다 정도로 테스트합니다.</li>\n<li>즉각적인 피드백이 나온다는 것이 훌륭한 장점입니다.</li>\n<li>꼭 메모리 내에서만 실행되는 테스트여야 한다는 법칙은 없습니다.\n<ul>\n<li>DB, Network Access, File System 등을 사용하여도 단위테스트의 레벨일 수 있습니다.</li>\n</ul>\n</li>\n<li>하나의 메서드들이 잘 동작한다는 것은 보장할 수 있지만, 그들이 결합되었을 때도 잘 작동한다는 것은 보장할 수 없습니다.</li>\n<li>테스트하기 어려운 부분은 stub을 사용하여 테스트합니다.\n<ul>\n<li>비용이 크지 않다면 stub 보다는 실제 객체를 사용하는 것이 좋습니다.</li>\n<li>아무래도 정교한 목 객체가 실제 객체보다 정확하지는 않기 때문입니다.</li>\n<li>모든 것은 비용 관점에서 생각해야 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"통합-테스트integration-tests\" style=\"position:relative;\"><a href=\"#%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8integration-tests\" aria-label=\"통합 테스트integration tests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>통합 테스트(Integration Tests)</strong></h3>\n<ul>\n<li>다른 모듈이 그룹으로 결합될 때 잘 작동하는지 확인하는 것을 의미합니다.</li>\n<li>예외 처리를 포함하여 의도한 응답을 위해 여러 장치에 걸쳐 프로세스를 테스트합니다.</li>\n</ul>\n<h3 id=\"특징-1\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-1\" aria-label=\"특징 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>모듈을 통합하는 과정에서 모듈 간 호환성의 문제를 찾아내기 위해 수행되는 테스트입니다.</li>\n<li>유닛 테스트와의 차이점은 유닛 테스트는 다른 컴포넌트들과 도긻적인 반면 통합 테스트는 그렇지 않습니다.</li>\n<li>예를 들면, 유닛 테스트에서 데이터베이스에 접근하는 코드는 실제 데이터 베이스와 통신하는 것은 아니지만, 통합 테스트는 실제 통신해야 합니다.</li>\n<li>통합 테스트는 대게 유닛 테스트를 작성하는 것보다 복잡하고 오랜 시간이 걸립니다.</li>\n<li>꼭 필요한 것이 아니라면, 유닛 테스트를 작성하는데 집중하는 것이 좋습니다.</li>\n</ul>\n<h3 id=\"기능-테스트functional-tests-또는-e2e-tests\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8functional-tests-%EB%98%90%EB%8A%94-e2e-tests\" aria-label=\"기능 테스트functional tests 또는 e2e tests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>기능 테스트(Functional Tests 또는 e2e Tests)</strong></h3>\n<ul>\n<li>시스템의 기능 조각(종속성과 상호 작용 할 수 있음)을 테스트하여 코드가 올바른 작업을 수행하는지 확인하는 것을 의미합니다.</li>\n<li>브라우저나 웹사이트를 제어하여 제품 자체에서 시나리오가 어떻게 작동하는지 테스트합니다.</li>\n</ul>\n<h3 id=\"특징-2\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-2\" aria-label=\"특징 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>해당 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험하는 것을 말합니다. 용어를 사용하는 곳마다 조금씩 차이가 있다고 합니다.</li>\n<li>내부 기능들까지(클래스의 메서드) 테스트 할 필요는 없습니다. 이는 단위테스트의 영역입니다.</li>\n<li>단점은 테스트를 만들기가 힘들고, 만든 테스트를 신뢰하기도 힘들다는 것입니다.</li>\n</ul>\n<h2 id=\"stub과-mock의-개념\" style=\"position:relative;\"><a href=\"#stub%EA%B3%BC-mock%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-label=\"stub과 mock의 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Stub과 Mock의 개념</strong></h2>\n<h3 id=\"stub\" style=\"position:relative;\"><a href=\"#stub\" aria-label=\"stub permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stub</h3>\n<ul>\n<li>Stub은 아직 준비되지 못한 코드를 미리 정해진 응답으로 반환할 수 있도록 하는 메커니즘입니다. 가짜 객체가 실제로 동작하는 것처럼 보이게 만들어놓은 객체이며, 호출자를 실제 구현물로부터 격리시켜 독립적인 테스트를 진행할 수 있도록 하는 것이 Stub입니다.</li>\n<li>Stub은 아래와 같은 경우 주로 사용 됩니다.\n<ul>\n<li>복잡한 로직을 단순화 하고 싶을 떄</li>\n<li>구현이 되지 않은 함수가 있을 때</li>\n<li>라이브러리에서 제공하는 함수를 사용하고자 할 때</li>\n<li>의존성을 가지는 유닛의 응답을 모사하여 독립적인 테스트를 수행하고자 할 때</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mock\" style=\"position:relative;\"><a href=\"#mock\" aria-label=\"mock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mock</h3>\n<ul>\n<li>Mock은 가짜라는 의미인데, 이 Mock 이 사용되는 부분은 Mocking이라는 작업을 할 때 사용됩니다.</li>\n<li>Mocking이란, 유닛 테스트 등을 작성할 때 해당 코드가 의존성을 가지고 있다면 그 의존하는 부분을 가짜로 대체하는 기법입니다. 일반적으로 유닛 테스트의 해당 코드가 의존하는 부분을 직접 생성하는 것이 까다로울 때 Mocking을 많이 사용합니다.</li>\n</ul>\n<h2 id=\"테스트-코드-도구의-종류\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EB%8F%84%EA%B5%AC%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"테스트 코드 도구의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드 도구의 종류</strong></h2>\n<h3 id=\"jest\" style=\"position:relative;\"><a href=\"#jest\" aria-label=\"jest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jest</h3>\n<ul>\n<li>Jest란 단순함에 초점을 둔 페이스북에서 개발한 오픈 소스 자바스크립트 테스트 프레임워크입니다. 비교적 사용이 간단하며 Babel, Typescript 등에 모두 사용할 수 있습니다.</li>\n<li>Jest는 테스트가 전역 상태를 갖도록 하여 모든 테스트를 평행적으로 수행이 가능하게 합니다. 또한 빠른 테스트를 위해 이전 테스트에서 실패했던 것을 가장 먼저 실행하고, 테스트의 수행 시간을 예측하여 실행 순서를 재배치합니다.</li>\n<li>테스트의 코드 커버리지를 파악할 땐 <code class=\"language-text\">--coverage</code> Flag를 통해 간단하게 파악할 수 있습니다.</li>\n</ul>\n<h3 id=\"mocha\" style=\"position:relative;\"><a href=\"#mocha\" aria-label=\"mocha permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mocha</h3>\n<ul>\n<li>Mocha는 Node.js와 브라우저에서 실행되는 기능이 풍부한 자바스크립트 테스트 프레임워크입니다. 비동기식 테스트를 간단하게 진행할 수 있습니다.</li>\n<li>또한 Mocha 테스트는 연속적으로 실행되어 유연하고 정확한 보고를 가능하게 하는 동시에 미검증 예외를 올바른 테스트 사례에 Mapping 합니다.</li>\n<li>Mocha는 확장성이 좋다고 알려져 있는데, 이것은 여러가지 라이브러리를 사용해서 기능을 확장시킬 수 있다는 의미입니다. Mocha의 경우 Assertion은 Chai를 사용하고, 테스트 더블은 주로 Sinon을 사용합니다.</li>\n</ul>\n<h3 id=\"jasmine\" style=\"position:relative;\"><a href=\"#jasmine\" aria-label=\"jasmine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jasmine</h3>\n<ul>\n<li>Jasmine은 자바스크립트 코드를 테스트하기 위한 동작 중심 개발 프레임워크입니다. Jasmine은 다른 Javascript 프레임워크에 의존하지 않으며, DOM이 필요하지 않습니다.</li>\n<li>구문 자체가 꺠끗하고 명확한 구문을 가지고 있어서 쉽게 시험을 작성할 수 있습니다.</li>\n<li>대표적인 사용사례는 Karma와 Jasmine의 조합으로 사용되는데, 이는 브라우징 테스트가 필요할 떄 사용합니다. 이는 Node.js와 브라우저 환경 모두에서 사용이 가능하기 때문 입니다.</li>\n<li>Mocha와의 차이점은 여러가지 라이브러리를 사용해야 했지만 Jasmine은 모든 기능을 통합해서 제공하기 때문에 추가적인 라이브러리가 필요 없습니다.</li>\n</ul>\n<h3 id=\"puppeteer\" style=\"position:relative;\"><a href=\"#puppeteer\" aria-label=\"puppeteer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Puppeteer</strong></h3>\n<ul>\n<li>Puppeteer는 Chromium이 포함되어 있고, 기본적으로 “Head가 없는” 상태로 실행됩니다. 여기서 Head가 없는 브라우저란 쉽게 말해 <code class=\"language-text\">Headless browser</code> 는 UI 없이 간편하게 백그라운드에서 실행되는 브라우저입니다. 실제로 브라우저 창을 띄우지 않고 백그라운드에서 가상으로 진행되며, 특정 페이지에 접속하고 렌더링 되는 과정 후 수행하고자 하는 코드를 수행하는데 용이합니다. 예를 들면 GUI가 없는 Ubuntu 서버 환경에서 용이할 수 있을 것입니다.</li>\n<li>이는 곧 CLI에서 작동하는 브라우저라고도 할 수 있는데, 백그라운드에서 작동한다는 것 외에 일반적인 브라우저와 같은 방식의 렌더링을 사용합니다. 하지만 만든 화면을 사용자에게 보여주지는 않습니다.</li>\n<li>브라우저 상에서 할 수 있는 것들은 대부분 Puppteer로 할 수 있습니다. 예를 들면, 스크린샷을 찍어 PDF로 만들거나, SPA로 되어 있는 페이지를 크롤링하거나, UI 테스트, 키보드 입력 자동화, 최신 버전의 크롬 브라우저 환경에서의 테스트 등 매우 다양합니다.</li>\n</ul>\n<h2 id=\"jest-사용법\" style=\"position:relative;\"><a href=\"#jest-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"jest 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jest 사용법</h2>\n<p>Jest는 단순성에 중점을 둔 자바스크립트 테스트 프레임워크이지만 여전히 자바스크립트 코드 베이스의 정확성을 보장합니다. 고유한 글로벌 상태와 병렬로 테스트를 안정적으로 실행하는 빠르고 안전함을 자랑합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 테스트 기본 양식\ntest('테스트 내용 입력', () => {\n\texpect(테스트할함수나값).toBe(의도한값) // 하단 Matcher 참고\n})</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>A.toBe(B)</th>\n<th>A의 결과가 B가 되면 pass, 아니면 Fail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A.toEqual(B)</td>\n<td>A의 결과가 B와 동일하면 pass, 아니면 Fail</td>\n</tr>\n<tr>\n<td>A.toBeNull()</td>\n<td>A의 결과가 Null이면 pass, 아니면 Fail</td>\n</tr>\n<tr>\n<td>A.toBeUndefined()</td>\n<td>A의 결과가 undefined이면 pass, 아니면 Fail</td>\n</tr>\n<tr>\n<td>A.toBeDefined()</td>\n<td>A의 결과가 정의되어있다면(언디파가 아니라면 pass</td>\n</tr>\n<tr>\n<td>A.toBeTruthy()</td>\n<td>A의 결과가 Truthy한 값이면 pass</td>\n</tr>\n<tr>\n<td>A.toBeFalsy()</td>\n<td>A의 결과가 Falsy한 값이면 pass</td>\n</tr>\n<tr>\n<td>A.toBeGreatThan(B)</td>\n<td>A의 결과가 B보다 크면 pass</td>\n</tr>\n<tr>\n<td>A.toBeGreaterThanOrEqual(B)</td>\n<td>A의 결과가 B보다 크가나 같으면 pass</td>\n</tr>\n<tr>\n<td>A.toBeLessThan(B)</td>\n<td>A의 결과가 B보다 작으면 pass</td>\n</tr>\n<tr>\n<td>A.toBeLessThanOrEqual(B)</td>\n<td>A의 결과가 B보다 작거나 같으면 pass</td>\n</tr>\n<tr>\n<td>A.toBeCloseTo(B)</td>\n<td>A의 결과가 B와 유사하면 pass (소숫점 단위 검증에 사용)</td>\n</tr>\n<tr>\n<td>A.toThrow(‘xx’)</td>\n<td>A의 결과가 “xx”라는 에러가 발생하면 pass (xx 에러가 아니라 oo 에러가 나도 fail임. 단, 해당 칸을 비워놓으면 모든 에러에 대해 pass)</td>\n</tr>\n<tr>\n<td>A.matcher.not.</td>\n<td>matcher의 결과가 fail일 경우에 pass</td>\n</tr>\n</tbody>\n</table>\n<p>함수 객체를 만들어 테스트 해볼 함수들을 작성한 후 exports로 test 파일에서도 사용할 수 있게 내보냅니다. 이후 테스트 코드 양식을 참고해 코드를 작성해 테스트를 진행합니다.</p>\n<blockquote>\n<p>💡 npm test [테스트 할 파일 명] → 전체 테스트가 아닌 하나의 파일만 테스트하고 싶으면 test 뒤에 파일명을 작성합니다.</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186410589-2c713c35-25cc-48c1-a4f6-5f3a156498c1.png\" alt=\"111\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186410604-7f0389f7-013e-44cc-bb30-ae0551e9ef68.png\" alt=\"222\"></p>","frontmatter":{"date":"May 06, 2022","title":"[Tech-Talk] 테스트 코드","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech9TestCode/"}},"prev":{"id":"d513370c-8dc1-5af6-a2b5-d396f6ad95d6","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/sf8vvKtvQBY\" title=\"테크톡🎤 데이터베이스 인덱스 - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<h2 id=\"index란\" style=\"position:relative;\"><a href=\"#index%EB%9E%80\" aria-label=\"index란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index란?</h2>\n<p>인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸립니다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같은 역할을 합니다. 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 해줍니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411954-a492d973-0179-48a1-9d22-9a0845555a5e.png\" alt=\"111\"></p>\n<h2 id=\"인덱스index의-관리\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EC%9D%98-%EA%B4%80%EB%A6%AC\" aria-label=\"인덱스index의 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스(index)의 관리</h2>\n<p>DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생합니다.</p>\n<blockquote>\n<p>💡 INSERT: 새로운 데이터에 대한 인덱스를 추가함 DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함 UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함</p>\n</blockquote>\n<h2 id=\"인덱스index의-장점과-단점\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\" aria-label=\"인덱스index의 장점과 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스(index)의 장점과 단점</h2>\n<h3 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있습니다.</li>\n<li>전반적인 시스템의 부하를 줄일 수 있습니다.</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h3>\n<ul>\n<li>인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요합니다.</li>\n<li>인덱스를 관리하기 위해 추가 작업이 필요합니다.</li>\n<li>인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있습니다.</li>\n</ul>\n<p>만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있습니다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문인데, 앞에서 설명한 것처럼 UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해줍니다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것입니다.</p>\n<h3 id=\"조건-검색-where-절의-효율성\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%EA%B1%B4-%EA%B2%80%EC%83%89-where-%EC%A0%88%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1\" aria-label=\"조건 검색 where 절의 효율성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>조건 검색 Where 절의 효율성</strong></h3>\n<p>테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다. 이렇게 되면 Where절에 특정 조건에 맞는 데이터들을 찾아낼때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과 맞는지 비교해야 합니다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 하지만 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠. 이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다.</p>\n<h3 id=\"정렬-order-by-절의-효율성\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC-order-by-%EC%A0%88%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1\" aria-label=\"정렬 order by 절의 효율성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>정렬 Order by 절의 효율성</strong></h3>\n<p>인덱스(Index)를 사용하면 Order by에 의한 Sort과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이 걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다. 이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.</p>\n<h3 id=\"min-max의-효율적인-처리-가능\" style=\"position:relative;\"><a href=\"#min-max%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%B2%98%EB%A6%AC-%EA%B0%80%EB%8A%A5\" aria-label=\"min max의 효율적인 처리 가능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>MIN, MAX의 효율적인 처리 가능</strong></h3>\n<p>이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점입니다. MIN값과 MAX값을 레코드의 시작값과 끝 값 한건씩만 가져오면 되기에 FULL TABLE SCAN으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.</p>\n<blockquote>\n<p>💡 여기서 잠깐!<br>\nIndex를 남발하지 말아야 하는 이유<br>\n데이터베이스 서버에 성능 문제가 발생하면 가장 빨리 생각하는 해결책이 인덱스 추가 생성입니다. 문제가 발생할 때마다 인덱스를 생성하면서 인덱스가 쌓여가는 것은 하나의 쿼리문을 빠르게 만들 수는 있지만, 전체적인 데이터베이스의 성능 부하를 초래합니다. 조회 성능을 극대화하려 만든 객체인데 많은 인덱스가 쌓여서 INSERT, UPDATE, DELETE 시에 부하가 발생해 전체적인 데이터베이스 성능을 저하합니다. 그렇기에인덱스를 생성하는 것보다는 SQL문을 좀 더 효율적으로 짜는 방향으로 나가야 한다. 인덱스 생성은 마지막 수단으로 강구해야 할 문제이다.</p>\n</blockquote>\n<h3 id=\"인덱스index를-사용하면-좋은-경우\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EA%B2%BD%EC%9A%B0\" aria-label=\"인덱스index를 사용하면 좋은 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스(index)를 사용하면 좋은 경우</h3>\n<ul>\n<li>규모가 작지 않은 테이블</li>\n<li>INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼</li>\n<li>JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼</li>\n<li>데이터의 중복도가 낮은 컬럼</li>\n</ul>\n<p>인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요합니다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해줘야 효율적으로 인덱스를 사용할 수 있습니다.</p>\n<h3 id=\"인덱스-생성-전략\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%83%9D%EC%84%B1-%EC%A0%84%EB%9E%B5\" aria-label=\"인덱스 생성 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>인덱스 생성 전략</strong></h3>\n<p>생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를 거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.</p>\n<ol>\n<li>조건절에 자주 등장하는 컬럼</li>\n<li>항상 = 으로 비교되는 컬럼</li>\n<li>중복되는 데이터가 최소한인(분포도가 좋은) 컬럼</li>\n<li>ORDER BY 절에서 자주 사용되는 컬럼</li>\n<li>조인 조건으로 자주 사용되는 컬럼</li>\n</ol>\n<h2 id=\"인덱스의-자료-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0\" aria-label=\"인덱스의 자료 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스의 자료 구조</h2>\n<h3 id=\"1-해시-테이블hash-table\" style=\"position:relative;\"><a href=\"#1-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94hash-table\" aria-label=\"1 해시 테이블hash table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 해시 테이블(Hash Table)</h3>\n<p>해시 테이블은 key와 value를 한 쌍으로 데이터를 저장하는 자료구조입니다. (key, value)로 쌍을 표현하며, key값을 이용해 대응되는 value값을 구하는 방식입니다. 해시 충돌이라는 변수가 존재하지만 평균적으로O(1)의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411966-af1c833f-6c57-40d0-a9d7-fe1e4cb136b7.png\" alt=\"222\"></p>\n<p>해시 테이블을 이용한다면 인덱스는(key, value) = (컬럼의 값, 데이터의 위치)로 구현하는데, 해시 테이블은 실제로 인덱스에서 잘 사용되지 않습니다.</p>\n<p>그 이유는, 해시 테이블은 등호(=) 연산에 최적화되어있기 때문입니다.</p>\n<p>데이터베이스에선 부등호(&#x3C;, >) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없습니다.</p>\n<h3 id=\"2-btree-인덱스\" style=\"position:relative;\"><a href=\"#2-btree-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"2 btree 인덱스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. <strong>B+Tree 인덱스</strong></h3>\n<p>인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다. 그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.</p>\n<p>B * Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다. 구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node로 구성됩니다. 특정 컬럼에 인덱스를 생성하는 순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT 블록을 기준으로 가지가 되는 BRANCH블록을 정의하며 마지막으로 잎에 해당하는 LEAF 블록에 인덱스의 키가 되는 데이터와 데이터의 물리적 주소 정보인 ROWID를 저장합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411967-537e20e1-8a00-4f64-b877-26886751b720.png\" alt=\"333\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186411971-c8f4dbc3-787b-4d89-af6f-8a3a4d47ceac.png\" alt=\"444\"></p>","frontmatter":{"date":"June 10, 2022","title":"[Tech-Talk] Database Index","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech11DbIndex/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/modern-agile-team/tech10Jenkins/","nextSlug":"/modern-agile-team/tech9TestCode/","prevSlug":"/modern-agile-team/tech11DbIndex/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}