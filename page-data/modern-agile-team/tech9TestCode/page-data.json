{"componentChunkName":"component---src-templates-blog-template-js","path":"/modern-agile-team/tech9TestCode/","result":{"data":{"cur":{"id":"21e0ccb4-e407-5ef9-9ede-6271cecf8b2a","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/26ZOkpDCBhQ\" title=\"테크톡🎤 테스트 코드란? - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<h2 id=\"이번-포스트는-테스트-코드에-대해-알아보겠습니다\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%88-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B2%A0%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"이번 포스트는 테스트 코드에 대해 알아보겠습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이번 포스트는 테스트 코드에 대해 알아보겠습니다.</h2>\n<h2 id=\"테스트-코드란\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%9E%80\" aria-label=\"테스트 코드란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드란?</strong></h2>\n<p>테스트코드란 내가 작성한 메서드 또는 기능이 재대로 동작하는지 테스트 하는 코드를 뜻합니다.</p>\n<p>실제로 개발 방법중 TDD라고 테스트 코드를 먼저 작성한 후 기능을 구현하는 방법도 있습니다.</p>\n<blockquote>\n<p>💡 실패하는 테스트코드 작성 -> 테스트가 성공하는 프로덕션코드 작성 -> 테스트가 성공하면 프로덕션 코드를 리팩토링</p>\n</blockquote>\n<h2 id=\"테스트-코드를-작성하는-이유\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"테스트 코드를 작성하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드를 작성하는 이유</strong></h2>\n<ol>\n<li>개발 초기 단계에 문제를 발견하게 도와줍니다.</li>\n<li>개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지를 확인할 수 있습니다.</li>\n<li>기능에 대한 불확실성을 감소시킬 수 있습니다.</li>\n<li>시스템에 대한 실제 문서를 제공합니다.(단위 테스트 자체가 문서로 사용 가능합니다.)</li>\n<li>클린한 코드를 작성할 수 있습니다.</li>\n<li>개발 시간을 단축할 수 있습니다.</li>\n</ol>\n<h2 id=\"테스트-코드를-사용하지-않는-개발-순서\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EA%B0%9C%EB%B0%9C-%EC%88%9C%EC%84%9C\" aria-label=\"테스트 코드를 사용하지 않는 개발 순서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드를 사용하지 않는 개발 순서</strong></h2>\n<ol>\n<li>프로덕션 코드를 작성합니다.</li>\n<li>서버를 실행합니다.</li>\n<li>postman과 같은 api 테스트 도구를 사용하거나 직접 화면을 만들어 버튼 등으로 통신하여 응답을 요청합니다.</li>\n<li>요청 결과를 console.log와 같은 출력을 이용하여 값을 확인합니다.</li>\n<li>에러가 나거나 원하는 결과값이 나오지 않으면 서버를 중지하고 코드를 수정합니다.</li>\n<li>1~5을 의도한 결과가 재대로 도출될 때까지 무한 반복합니다.</li>\n</ol>\n<h2 id=\"테스트의-분류\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%B6%84%EB%A5%98\" aria-label=\"테스트의 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트의 분류</strong></h2>\n<h3 id=\"유닛-테스트unit-tests\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EB%8B%9B-%ED%85%8C%EC%8A%A4%ED%8A%B8unit-tests\" aria-label=\"유닛 테스트unit tests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>유닛 테스트(Unit Tests)</strong></h3>\n<ul>\n<li>코드가 제대로 작동하는지 확인하기 위해 애플리케이션의 개별 모듈을 독립적으로 테스트(종속성과의 상호 작용없이)하는 것을 의미합니다.</li>\n<li>입력을 제공하고 출력이 예상대로인지 확인하며, 함수 또는 클래스와 같은 개별 단위 테스트입니다.</li>\n</ul>\n<h3 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a> 특징</h3>\n<ul>\n<li>가장 작은 단위의 테스트이며, 보통 메서드 레벨입니다.</li>\n<li>A라는 함수가 실행되면 B라는 결과가 나온다 정도로 테스트합니다.</li>\n<li>즉각적인 피드백이 나온다는 것이 훌륭한 장점입니다.</li>\n<li>꼭 메모리 내에서만 실행되는 테스트여야 한다는 법칙은 없습니다.\n<ul>\n<li>DB, Network Access, File System 등을 사용하여도 단위테스트의 레벨일 수 있습니다.</li>\n</ul>\n</li>\n<li>하나의 메서드들이 잘 동작한다는 것은 보장할 수 있지만, 그들이 결합되었을 때도 잘 작동한다는 것은 보장할 수 없습니다.</li>\n<li>테스트하기 어려운 부분은 stub을 사용하여 테스트합니다.\n<ul>\n<li>비용이 크지 않다면 stub 보다는 실제 객체를 사용하는 것이 좋습니다.</li>\n<li>아무래도 정교한 목 객체가 실제 객체보다 정확하지는 않기 때문입니다.</li>\n<li>모든 것은 비용 관점에서 생각해야 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"통합-테스트integration-tests\" style=\"position:relative;\"><a href=\"#%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8integration-tests\" aria-label=\"통합 테스트integration tests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>통합 테스트(Integration Tests)</strong></h3>\n<ul>\n<li>다른 모듈이 그룹으로 결합될 때 잘 작동하는지 확인하는 것을 의미합니다.</li>\n<li>예외 처리를 포함하여 의도한 응답을 위해 여러 장치에 걸쳐 프로세스를 테스트합니다.</li>\n</ul>\n<h3 id=\"특징-1\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-1\" aria-label=\"특징 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>모듈을 통합하는 과정에서 모듈 간 호환성의 문제를 찾아내기 위해 수행되는 테스트입니다.</li>\n<li>유닛 테스트와의 차이점은 유닛 테스트는 다른 컴포넌트들과 도긻적인 반면 통합 테스트는 그렇지 않습니다.</li>\n<li>예를 들면, 유닛 테스트에서 데이터베이스에 접근하는 코드는 실제 데이터 베이스와 통신하는 것은 아니지만, 통합 테스트는 실제 통신해야 합니다.</li>\n<li>통합 테스트는 대게 유닛 테스트를 작성하는 것보다 복잡하고 오랜 시간이 걸립니다.</li>\n<li>꼭 필요한 것이 아니라면, 유닛 테스트를 작성하는데 집중하는 것이 좋습니다.</li>\n</ul>\n<h3 id=\"기능-테스트functional-tests-또는-e2e-tests\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8functional-tests-%EB%98%90%EB%8A%94-e2e-tests\" aria-label=\"기능 테스트functional tests 또는 e2e tests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>기능 테스트(Functional Tests 또는 e2e Tests)</strong></h3>\n<ul>\n<li>시스템의 기능 조각(종속성과 상호 작용 할 수 있음)을 테스트하여 코드가 올바른 작업을 수행하는지 확인하는 것을 의미합니다.</li>\n<li>브라우저나 웹사이트를 제어하여 제품 자체에서 시나리오가 어떻게 작동하는지 테스트합니다.</li>\n</ul>\n<h3 id=\"특징-2\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-2\" aria-label=\"특징 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>해당 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험하는 것을 말합니다. 용어를 사용하는 곳마다 조금씩 차이가 있다고 합니다.</li>\n<li>내부 기능들까지(클래스의 메서드) 테스트 할 필요는 없습니다. 이는 단위테스트의 영역입니다.</li>\n<li>단점은 테스트를 만들기가 힘들고, 만든 테스트를 신뢰하기도 힘들다는 것입니다.</li>\n</ul>\n<h2 id=\"stub과-mock의-개념\" style=\"position:relative;\"><a href=\"#stub%EA%B3%BC-mock%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-label=\"stub과 mock의 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Stub과 Mock의 개념</strong></h2>\n<h3 id=\"stub\" style=\"position:relative;\"><a href=\"#stub\" aria-label=\"stub permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stub</h3>\n<ul>\n<li>Stub은 아직 준비되지 못한 코드를 미리 정해진 응답으로 반환할 수 있도록 하는 메커니즘입니다. 가짜 객체가 실제로 동작하는 것처럼 보이게 만들어놓은 객체이며, 호출자를 실제 구현물로부터 격리시켜 독립적인 테스트를 진행할 수 있도록 하는 것이 Stub입니다.</li>\n<li>Stub은 아래와 같은 경우 주로 사용 됩니다.\n<ul>\n<li>복잡한 로직을 단순화 하고 싶을 떄</li>\n<li>구현이 되지 않은 함수가 있을 때</li>\n<li>라이브러리에서 제공하는 함수를 사용하고자 할 때</li>\n<li>의존성을 가지는 유닛의 응답을 모사하여 독립적인 테스트를 수행하고자 할 때</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mock\" style=\"position:relative;\"><a href=\"#mock\" aria-label=\"mock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mock</h3>\n<ul>\n<li>Mock은 가짜라는 의미인데, 이 Mock 이 사용되는 부분은 Mocking이라는 작업을 할 때 사용됩니다.</li>\n<li>Mocking이란, 유닛 테스트 등을 작성할 때 해당 코드가 의존성을 가지고 있다면 그 의존하는 부분을 가짜로 대체하는 기법입니다. 일반적으로 유닛 테스트의 해당 코드가 의존하는 부분을 직접 생성하는 것이 까다로울 때 Mocking을 많이 사용합니다.</li>\n</ul>\n<h2 id=\"테스트-코드-도구의-종류\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EB%8F%84%EA%B5%AC%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"테스트 코드 도구의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>테스트 코드 도구의 종류</strong></h2>\n<h3 id=\"jest\" style=\"position:relative;\"><a href=\"#jest\" aria-label=\"jest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jest</h3>\n<ul>\n<li>Jest란 단순함에 초점을 둔 페이스북에서 개발한 오픈 소스 자바스크립트 테스트 프레임워크입니다. 비교적 사용이 간단하며 Babel, Typescript 등에 모두 사용할 수 있습니다.</li>\n<li>Jest는 테스트가 전역 상태를 갖도록 하여 모든 테스트를 평행적으로 수행이 가능하게 합니다. 또한 빠른 테스트를 위해 이전 테스트에서 실패했던 것을 가장 먼저 실행하고, 테스트의 수행 시간을 예측하여 실행 순서를 재배치합니다.</li>\n<li>테스트의 코드 커버리지를 파악할 땐 <code class=\"language-text\">--coverage</code> Flag를 통해 간단하게 파악할 수 있습니다.</li>\n</ul>\n<h3 id=\"mocha\" style=\"position:relative;\"><a href=\"#mocha\" aria-label=\"mocha permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mocha</h3>\n<ul>\n<li>Mocha는 Node.js와 브라우저에서 실행되는 기능이 풍부한 자바스크립트 테스트 프레임워크입니다. 비동기식 테스트를 간단하게 진행할 수 있습니다.</li>\n<li>또한 Mocha 테스트는 연속적으로 실행되어 유연하고 정확한 보고를 가능하게 하는 동시에 미검증 예외를 올바른 테스트 사례에 Mapping 합니다.</li>\n<li>Mocha는 확장성이 좋다고 알려져 있는데, 이것은 여러가지 라이브러리를 사용해서 기능을 확장시킬 수 있다는 의미입니다. Mocha의 경우 Assertion은 Chai를 사용하고, 테스트 더블은 주로 Sinon을 사용합니다.</li>\n</ul>\n<h3 id=\"jasmine\" style=\"position:relative;\"><a href=\"#jasmine\" aria-label=\"jasmine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jasmine</h3>\n<ul>\n<li>Jasmine은 자바스크립트 코드를 테스트하기 위한 동작 중심 개발 프레임워크입니다. Jasmine은 다른 Javascript 프레임워크에 의존하지 않으며, DOM이 필요하지 않습니다.</li>\n<li>구문 자체가 꺠끗하고 명확한 구문을 가지고 있어서 쉽게 시험을 작성할 수 있습니다.</li>\n<li>대표적인 사용사례는 Karma와 Jasmine의 조합으로 사용되는데, 이는 브라우징 테스트가 필요할 떄 사용합니다. 이는 Node.js와 브라우저 환경 모두에서 사용이 가능하기 때문 입니다.</li>\n<li>Mocha와의 차이점은 여러가지 라이브러리를 사용해야 했지만 Jasmine은 모든 기능을 통합해서 제공하기 때문에 추가적인 라이브러리가 필요 없습니다.</li>\n</ul>\n<h3 id=\"puppeteer\" style=\"position:relative;\"><a href=\"#puppeteer\" aria-label=\"puppeteer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Puppeteer</strong></h3>\n<ul>\n<li>Puppeteer는 Chromium이 포함되어 있고, 기본적으로 “Head가 없는” 상태로 실행됩니다. 여기서 Head가 없는 브라우저란 쉽게 말해 <code class=\"language-text\">Headless browser</code> 는 UI 없이 간편하게 백그라운드에서 실행되는 브라우저입니다. 실제로 브라우저 창을 띄우지 않고 백그라운드에서 가상으로 진행되며, 특정 페이지에 접속하고 렌더링 되는 과정 후 수행하고자 하는 코드를 수행하는데 용이합니다. 예를 들면 GUI가 없는 Ubuntu 서버 환경에서 용이할 수 있을 것입니다.</li>\n<li>이는 곧 CLI에서 작동하는 브라우저라고도 할 수 있는데, 백그라운드에서 작동한다는 것 외에 일반적인 브라우저와 같은 방식의 렌더링을 사용합니다. 하지만 만든 화면을 사용자에게 보여주지는 않습니다.</li>\n<li>브라우저 상에서 할 수 있는 것들은 대부분 Puppteer로 할 수 있습니다. 예를 들면, 스크린샷을 찍어 PDF로 만들거나, SPA로 되어 있는 페이지를 크롤링하거나, UI 테스트, 키보드 입력 자동화, 최신 버전의 크롬 브라우저 환경에서의 테스트 등 매우 다양합니다.</li>\n</ul>\n<h2 id=\"jest-사용법\" style=\"position:relative;\"><a href=\"#jest-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"jest 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jest 사용법</h2>\n<p>Jest는 단순성에 중점을 둔 자바스크립트 테스트 프레임워크이지만 여전히 자바스크립트 코드 베이스의 정확성을 보장합니다. 고유한 글로벌 상태와 병렬로 테스트를 안정적으로 실행하는 빠르고 안전함을 자랑합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 테스트 기본 양식\ntest('테스트 내용 입력', () => {\n\texpect(테스트할함수나값).toBe(의도한값) // 하단 Matcher 참고\n})</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>A.toBe(B)</th>\n<th>A의 결과가 B가 되면 pass, 아니면 Fail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A.toEqual(B)</td>\n<td>A의 결과가 B와 동일하면 pass, 아니면 Fail</td>\n</tr>\n<tr>\n<td>A.toBeNull()</td>\n<td>A의 결과가 Null이면 pass, 아니면 Fail</td>\n</tr>\n<tr>\n<td>A.toBeUndefined()</td>\n<td>A의 결과가 undefined이면 pass, 아니면 Fail</td>\n</tr>\n<tr>\n<td>A.toBeDefined()</td>\n<td>A의 결과가 정의되어있다면(언디파가 아니라면 pass</td>\n</tr>\n<tr>\n<td>A.toBeTruthy()</td>\n<td>A의 결과가 Truthy한 값이면 pass</td>\n</tr>\n<tr>\n<td>A.toBeFalsy()</td>\n<td>A의 결과가 Falsy한 값이면 pass</td>\n</tr>\n<tr>\n<td>A.toBeGreatThan(B)</td>\n<td>A의 결과가 B보다 크면 pass</td>\n</tr>\n<tr>\n<td>A.toBeGreaterThanOrEqual(B)</td>\n<td>A의 결과가 B보다 크가나 같으면 pass</td>\n</tr>\n<tr>\n<td>A.toBeLessThan(B)</td>\n<td>A의 결과가 B보다 작으면 pass</td>\n</tr>\n<tr>\n<td>A.toBeLessThanOrEqual(B)</td>\n<td>A의 결과가 B보다 작거나 같으면 pass</td>\n</tr>\n<tr>\n<td>A.toBeCloseTo(B)</td>\n<td>A의 결과가 B와 유사하면 pass (소숫점 단위 검증에 사용)</td>\n</tr>\n<tr>\n<td>A.toThrow(‘xx’)</td>\n<td>A의 결과가 “xx”라는 에러가 발생하면 pass (xx 에러가 아니라 oo 에러가 나도 fail임. 단, 해당 칸을 비워놓으면 모든 에러에 대해 pass)</td>\n</tr>\n<tr>\n<td>A.matcher.not.</td>\n<td>matcher의 결과가 fail일 경우에 pass</td>\n</tr>\n</tbody>\n</table>\n<p>함수 객체를 만들어 테스트 해볼 함수들을 작성한 후 exports로 test 파일에서도 사용할 수 있게 내보냅니다. 이후 테스트 코드 양식을 참고해 코드를 작성해 테스트를 진행합니다.</p>\n<blockquote>\n<p>💡 npm test [테스트 할 파일 명] → 전체 테스트가 아닌 하나의 파일만 테스트하고 싶으면 test 뒤에 파일명을 작성합니다.</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186410589-2c713c35-25cc-48c1-a4f6-5f3a156498c1.png\" alt=\"111\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186410604-7f0389f7-013e-44cc-bb30-ae0551e9ef68.png\" alt=\"222\"></p>","excerpt":"이번 포스트는 테스트 코드에 대해 알아보겠습니다. 테스트 코드란? 테스트코드란 내가 작성한 메서드 또는 기능이 재대로 동작하는지 테스트 하는 코드를 뜻합니다. 실제로 개발 방법중 TDD라고 테스트 코드를 먼저 작성한 후 기능을 구현하는 방법도 있습니다. 💡 실패하는 테스트코드 작성 -> 테스트가 성공하는 프로덕션코드 작성 -> 테스트가 성공하면 프로덕션 코드를 리팩토링 테스트 코드를 작성하는 이유 개발 초기 단계에 문제를 발견하게 도와줍니다. 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지를 확인할 수 있습니다. 기능에 대한 불확실성을 감소시킬 수 있습니다. 시스템에 대한 실제 문서를 제공합니다.(단위 테스트 자체가 문서로 사용 가능합니다.) 클린한 코드를 작성할 수 있습니다. 개발 시간을 단축할 수 있습니다. 테스트 코드를 사용하지 않는 개발 순서 프로덕션 코드를 작성합니다. 서버를 실행합니다. postman과 같은 api 테스트…","frontmatter":{"date":"May 06, 2022","title":"[Tech-Talk] 테스트 코드","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech9TestCode/"}},"next":{"id":"06309197-44c7-541a-9ebe-61375903c084","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/8Bn_vc6aUao\" title=\"테크톡🎤 클래스 다이어그램 - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p>이번 포스트는 소프트웨어 개발 프로세스 단계중 계획 및 요구분석, 설계 부분에 해당하는 클래스 다이어그램에 대해 다뤄보겠습니다.</p>\n<p>클래스 다이어그램을 알기 이전에 소프트웨어 개발 생명주기(SDLC: Software Development Life Cycle)을 먼저 간단히 알아보고 UML을 살펴본뒤 클래스 다이어그램에 대해 설명하겠습니다!</p>\n<h2 id=\"소프트웨어-개발-생명주기란\" style=\"position:relative;\"><a href=\"#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%9E%80\" aria-label=\"소프트웨어 개발 생명주기란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소프트웨어 개발 생명주기란?</h2>\n<blockquote>\n<p>💡 계획 → 분석 → 설계 → 구현 → 테스트 → 유지보수</p>\n</blockquote>\n<p>소프트웨어 개발 프로세스는 6단계(경우에 따라 7단계)입니다.</p>\n<p>알아봐야 할 계획 및 요구분석에 대해 살짝 알아보자면</p>\n<h3 id=\"계획-단계\" style=\"position:relative;\"><a href=\"#%EA%B3%84%ED%9A%8D-%EB%8B%A8%EA%B3%84\" aria-label=\"계획 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>계획 단계</h3>\n<ul>\n<li>개발 비용 산정</li>\n<li>일정 계획</li>\n<li>위험 관리</li>\n</ul>\n<h3 id=\"요구분석-단계\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EA%B5%AC%EB%B6%84%EC%84%9D-%EB%8B%A8%EA%B3%84\" aria-label=\"요구분석 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요구분석 단계</h3>\n<ul>\n<li>기존 시스템의 문제 파악 - 새로운 요구사항 도출 및 다이어그램 작성</li>\n<li>개발 방법론에 따른 표현 도구 - 구조적 방법론, 정보공학 방법론, 객체지향 방법론(UML의 유스케이스 다이어그램 등)</li>\n<li>최종 산출물 - 요구 분석 명세서</li>\n</ul>\n<h3 id=\"설계-단계\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EA%B3%84-%EB%8B%A8%EA%B3%84\" aria-label=\"설계 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설계 단계</h3>\n<ul>\n<li>분할과 정복, 추상화, 단계적 분해, 모듈화, 정보 은닉</li>\n<li>소프트웨어 아키텍처, 객체지향 설계</li>\n<li>아키텍처 스타일</li>\n<li>디자인 패턴</li>\n<li>모듈 평가 기준 - 응집도와 결합도</li>\n</ul>\n<h2 id=\"umlunified-modeling-language이란\" style=\"position:relative;\"><a href=\"#umlunified-modeling-language%EC%9D%B4%EB%9E%80\" aria-label=\"umlunified modeling language이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UML(Unified Modeling Language)이란?</h2>\n<p>UML은 시스템이 상호작용하는 측면, 시스템 전체 구조 측면, 컴포넌트 간의 관계 등을 시각적으로 볼 수 있게 나타낸 도면입니다.</p>\n<p>UML은 시스템 개발을 위한 시각적인 설계 표기를 제공하며, 객체 지향 시스템을 개발할 때 산출물을 명세화, 시각화, 문서화하는 데 사용합니다.</p>\n<p>그리고 개발하는 시스템을 이해하기 쉬운 형태로 표현하여 분석가, 설계자, 의뢰인이 효율적으로 의사소통을 할 수 있게 해줍니다.</p>\n<p>→ UML은 표준화된 통합 모델링 언어</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409911-9c257b40-133e-40ac-9638-82f71ab9a63b.png\" alt=\"111\"></p>\n<h3 id=\"uml이-제공하는-표준화된-다이어그램-종류\" style=\"position:relative;\"><a href=\"#uml%EC%9D%B4-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%ED%91%9C%EC%A4%80%ED%99%94%EB%90%9C-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8-%EC%A2%85%EB%A5%98\" aria-label=\"uml이 제공하는 표준화된 다이어그램 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UML이 제공하는 표준화된 다이어그램 종류</h3>\n<p>구조 다이어그램(Structural Diagram)</p>\n<ul>\n<li><strong>클래스 다이어그램(Class Diagram)</strong></li>\n<li>복합 구조 다이어그램</li>\n<li>객체 다이어그램</li>\n<li>배치 다이어그램</li>\n<li>컴포터는 다이어그램</li>\n<li>패키지 다이어그램</li>\n</ul>\n<p>행위 다이어그램(Behavioral Diagram)</p>\n<ul>\n<li>활동 다이어그램</li>\n<li>유스 케이스 다이어그램</li>\n<li>상태 머신 다이어그램</li>\n</ul>\n<p>상호작용 다이어그램(Interaction Diagram)</p>\n<ul>\n<li>순차 다이어그램</li>\n<li>통신 다이어그램</li>\n<li>타이밍 다이어그램</li>\n</ul>\n<p>이렇게 다양한 다이어그램이 있으나 클래스 다이어그램에 대해 알아보겠습니다.</p>\n<h3 id=\"uml의-특징\" style=\"position:relative;\"><a href=\"#uml%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"uml의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UML의 특징</h3>\n<ul>\n<li>시각화(Visualization) 언어이다.</li>\n<li>소프트웨어의 개념 모델을 시각적인 형태로 표현하며 명확히 정의된 표준화된 다이어그램을 제공하며 이를 이용해 오류 없는 원활한 의사소통이 가능합니다.</li>\n<li>명세화(Speccification) 언어이다.명세화에서 각 다이어그램의 기호는 의미를 담고 있으며 추상적이지만 고유의 특성을 갖고 있습니다.</li>\n<li>소프트웨어 개발 과정인 분석, 설계 단계의 각 과정에서 필요한 모델을 정확하고 안전하게 명세화하여 만들 수 있습니다.</li>\n<li>구축(Construction) 언어이다.UML로 설계된 모델을 프로그램 코드로 자동 변환할 수 있으며, 이미 구축된 소스 코드를 UML로 역변환하여 분석하는 역공학이 가능합니다.</li>\n<li>다양한 프로그래밍 언어로 표현 가능합니다.</li>\n<li>문서화(Documentation) 언어이다.</li>\n<li>StarUML, 투게더 등 케이스 툴을 이용해 설계한 내용을 자동으로 문서화 가능합니다.</li>\n</ul>\n<blockquote>\n<p>💡 개발하고자 하는 프로그램을 시각적으로 표현하는 것이며, 이때 의뢰자의 요구에 맞게 쉽게 수정해서 결과적으로 유지보수 기간을 줄여 생산성을 높일 수 있습니다.</p>\n</blockquote>\n<h3 id=\"모델링이-필요한-이유\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-label=\"모델링이 필요한 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델링이 필요한 이유</h3>\n<p>개인이 진행하는 프로젝트의 경우 모델링이 꼭 필요하지 않습니다.</p>\n<p>하지만, 대규모 프로젝트의 경우 모델링을 통해 보다 완벽하게 설계된 프로그램을 만들어야 유지보수가 용이합니다.</p>\n<h2 id=\"클래스-다이어그램class-diagram이란\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8class-diagram%EC%9D%B4%EB%9E%80\" aria-label=\"클래스 다이어그램class diagram이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 다이어그램(Class Diagram)이란?</h2>\n<p>소프트웨어의 기본 구성 단위인 시스템에서 사용하는 클래스를 정의합니다.</p>\n<p>클래스들이 서로 어떻게 연결되어 있고 어떤 역할을 하는지 다이어그램으로 표현합니다.</p>\n<h3 id=\"클래스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스</h3>\n<ul>\n<li>데이터(속성)와 메서드를 묶어 놓은 것</li>\n<li>세 칸의 직사각형 모양</li>\n<li>첫 번재 칸에는 클래스 이름</li>\n<li>두 번재 칸에는 클래스의 속성</li>\n<li>마지막 칸은 클래스가 제공하는 기능인 메서드를 나타냄</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409915-b0c5bcde-f74a-49fa-9229-2e57f731479e.png\" alt=\"222\"></p>\n<h3 id=\"클래스의-구성-요소\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C\" aria-label=\"클래스의 구성 요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스의 구성 요소</h3>\n<p>클래스는 클래스 이름, 속성, 메서드로 구성되어 있습니다.</p>\n<p>클래스</p>\n<ul>\n<li>공통의 속성, 메서드(오퍼레이션), 관계, 의미를 공유하는 객체 집합에 대한 기술</li>\n</ul>\n<p>속성</p>\n<ul>\n<li>클래스의 구조적 특성에 이름을 붙인 것</li>\n<li>구조적 특성에 해당하는 인스턴스가 보유할 수 있는 값의 범위를 기술</li>\n<li>영문 소문자로 시작함</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409920-53ae1b30-245e-4223-9920-dc3420bf9095.png\" alt=\"333\"></p>\n<h3 id=\"클래스-정리\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EB%A6%AC\" aria-label=\"클래스 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 정리</h3>\n<p>이름</p>\n<ul>\n<li>클래스는 다른 클래스와 구별되는 ‘유일한’ 이름을 가짐</li>\n<li>이름에 명사나 명사구를 사용하며 두 단어를 사용할 때는 붙여쓰되 각 단어의 첫 글자는 ‘대문자’로 씀</li>\n<li>복수형, 소유격, 형용사는 가급적 쓰지 않음</li>\n</ul>\n<p>속성</p>\n<ul>\n<li>클래스가 갖는 정적인 특성</li>\n<li>속성의 이름은 소문자로 나타내며 두 단어를 사용할 때는 두 번째 단어의 첫 글자는 ‘대문자’로 씀</li>\n</ul>\n<p>메서드</p>\n<ul>\n<li>클래스가 외부의 다른 객체에게 제공할 서비스와 기능</li>\n<li>외부 클래스는 메서드를 통해 해당 클래스에 접근할 수 있음</li>\n<li>외부에서 이 기능을 요구하는지에 따라 메서드로 도출할지 판단</li>\n</ul>\n<p>가시성</p>\n<ul>\n<li>속성과 메서드의 접근 권한을 지정하는 방식</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409921-af885a8c-1f26-4355-9349-31d66bdcb276.png\" alt=\"444\"></p>\n<h3 id=\"클래스-다이어그램의-예\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%98%88\" aria-label=\"클래스 다이어그램의 예 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 다이어그램의 예</h3>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409928-076d331b-768e-4003-a5d5-99e8f5e718e8.png\" alt=\"555\"></p>\n<ul>\n<li>학생은 여러 과목을 수강할 수 있습니다.</li>\n<li>학생은 하나의 학교에 소속되어 있습니다.</li>\n<li>교수는 하나의 학교에 소속되어 있습니다.</li>\n<li>교수 한 명은 여러 과목을 강의합니다.</li>\n<li>교수 한 명은 여러명의 학생을 상담합니다.</li>\n</ul>\n<h3 id=\"객체와-클래스-사이의-관계와-표현\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B4%80%EA%B3%84%EC%99%80-%ED%91%9C%ED%98%84\" aria-label=\"객체와 클래스 사이의 관계와 표현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체와 클래스 사이의 관계와 표현</h3>\n<p>연관 관계는 의존 관계와 마찬가지로 객체를 생성하는 관계입니다.</p>\n<p>그러나 연관 관계는 멤버 변수로 참조하고, 의존 관계는 메서드로 참조한다는 것이 다릅니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409930-bdaa9ed1-df1e-4c7b-b6d8-3e3f92abce06.png\" alt=\"666\"></p>\n<h3 id=\"uml-표기법\" style=\"position:relative;\"><a href=\"#uml-%ED%91%9C%EA%B8%B0%EB%B2%95\" aria-label=\"uml 표기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UML 표기법</h3>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409934-838caa72-afaf-472d-b712-71ddc7b010af.png\" alt=\"777\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186409935-ce1c6334-f889-4df1-88d0-385db48157ac.png\" alt=\"888\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186409937-bd049688-81d9-4992-9530-52cbcd4722ba.png\" alt=\"999\"></p>\n<h3 id=\"직접-작성해본-기초적인-자판기-클래스-다이어그램\" style=\"position:relative;\"><a href=\"#%EC%A7%81%EC%A0%91-%EC%9E%91%EC%84%B1%ED%95%B4%EB%B3%B8-%EA%B8%B0%EC%B4%88%EC%A0%81%EC%9D%B8-%EC%9E%90%ED%8C%90%EA%B8%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8\" aria-label=\"직접 작성해본 기초적인 자판기 클래스 다이어그램 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>직접 작성해본 기초적인 자판기 클래스 다이어그램</h3>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186409943-8f371f88-1e2e-425a-9821-2d86422ab0f0.png\" alt=\"101010\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186409944-ced18423-c575-48da-bd09-bcecae2a32a7.png\" alt=\"111111\"></p>\n<p>이런식으로 클래스 다이어그램으로 직접 지정한 관계들을 코드로 변환할 수 있습니다.</p>","frontmatter":{"date":"April 08, 2022","title":"[Tech-Talk] 클래스 다이어그램","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech8ClassGram/"}},"prev":{"id":"9e718ed5-d497-5392-9493-7d4f91ec8c49","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/srVhzwgO2xw\" title=\"테크톡🎤 젠킨스 - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411168-1028d032-fe47-43df-a6d7-e62c4f3d10a6.png\" alt=\"111\"></p>\n<h3 id=\"젠킨스란\" style=\"position:relative;\"><a href=\"#%EC%A0%A0%ED%82%A8%EC%8A%A4%EB%9E%80\" aria-label=\"젠킨스란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>젠킨스란?</h3>\n<p>소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴, 즉 CI(Continuous Integration) 툴 이라고 표현합니다.</p>\n<p>다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유영역에 있는 저장소에 빈번히 업로드함으로써 지속적 통합이 가능하도록 해주는 유용한 툴입니다.</p>\n<blockquote>\n<p>💡 모든 언어의 조합과 소스 코드 레포지토리에 대한 **지속적인 통합(Continuous integration, CI)**과 지속적 배포(continuous delivery, CD) 환경을 구축하기 위한 도구이다다. 빌드, 테스트, 배포 프로세스를 자동화하여 소프트웨어 품질과 개발 생산성을 높일 수 있다.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>웹사이트</th>\n<th>jenkins-ci.org</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>발표일</td>\n<td>2011년 2월 2일</td>\n</tr>\n<tr>\n<td>프로그래밍 언어</td>\n<td>Java</td>\n</tr>\n<tr>\n<td>최근 버전</td>\n<td>2.23.3</td>\n</tr>\n<tr>\n<td>운영체제</td>\n<td>크로스 플랫폼</td>\n</tr>\n<tr>\n<td>종류</td>\n<td>지속적 통합</td>\n</tr>\n<tr>\n<td>라이선스</td>\n<td>MIT</td>\n</tr>\n</tbody>\n</table>\n<p>젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방식이 일반적이었는데 특히 개발자들이 당일 작성한 소스들의 커밋이 모드 끝난 심야 시간대에 이러한 빌드가 타이머에 의해 집중적으로 진행됐습니다. 이를 nightly-build라 합니다.</p>\n<p>하지만, 젠킨스는 정기적인 빌드에서 한발 나아가 서브버전, Git 과 같은 버전관리시스템과 연동하여 소스의 커밋을 감지하면 자동적으로 자동화 테스트가 포함된 빌드가 작동되도록 설정할 수 있습니다.</p>\n<h3 id=\"젠킨스-장점\" style=\"position:relative;\"><a href=\"#%EC%A0%A0%ED%82%A8%EC%8A%A4-%EC%9E%A5%EC%A0%90\" aria-label=\"젠킨스 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>젠킨스 장점</h3>\n<p>개발중인 프로젝트에서 커밋은 매우 빈번히 일어나기 때문에 커밋 횟수만큼 빌드를 실행하는 것이 아닌 작업이 큐잉되어 실행될 차례를 기다립니다.</p>\n<p>코드의 변경과 함께 이뤄지는 이 같은 자동화된 빌드와 테스트 작업들은 다음과 같은 장점들이 있습니다.</p>\n<ul>\n<li>프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출</li>\n<li>자동화 테스트 수행</li>\n<li>정적 코드 분석에 의한 코딩 규약 준수여부 체크</li>\n<li>프로파일링 툴을 이용한 소스 변경에 따른 성능 변화 감시</li>\n<li>결합 테스트 환경에 대한 배포작업</li>\n<li>500여가지가 넘는 플러그인을 온라인으로 간단히 인스톨 할 수 있는 기능을 제공</li>\n<li>스크립트를 이용해 손쉽게 자신에게 필요한 기능을 추가 가능</li>\n</ul>\n<h3 id=\"각종-배치-작업의-간략화\" style=\"position:relative;\"><a href=\"#%EA%B0%81%EC%A2%85-%EB%B0%B0%EC%B9%98-%EC%9E%91%EC%97%85%EC%9D%98-%EA%B0%84%EB%9E%B5%ED%99%94\" aria-label=\"각종 배치 작업의 간략화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각종 배치 작업의 간략화</h3>\n<p>프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외에 DB셋업이나 환경설정, Deploy작업과 같은 단순 작업에 시간과 노력을 들이는 경우가 빈번합니다. 데이터베이스의 구축, 어플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 이전에 CLI로 실행되던 작업들이 젠킨스 덕분에 웹 인터페이스로 손쉽게 가능해졌습니다.</p>\n<h3 id=\"build-자동화의-확립\" style=\"position:relative;\"><a href=\"#build-%EC%9E%90%EB%8F%99%ED%99%94%EC%9D%98-%ED%99%95%EB%A6%BD\" aria-label=\"build 자동화의 확립 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Build 자동화의 확립</h3>\n<p>빌드 툴의 경우 Java는 maven과 gradle이 자리잡고 있으며, 이미 빌드 관리 툴을 이용해 프로젝트를 진행하고 있다면 젠킨스를 사용하지 않을 이유가 하나도 없습니다. 젠킨스와 연동해 빌드 자동화를 통하여 프로젝트 진행의 효율성을 높일 수 있기 때문입니다.</p>\n<h3 id=\"자동화-테스트\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%8F%99%ED%99%94-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"자동화 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자동화 테스트</h3>\n<p>젠킨스를 사용해야 하는 가장 큰 이유 중 하나이며, 사실상 자동화 테스트가 포함되지 않은 빌드는 CI자체가 불가능하다고 봐도 무방합니다. 젠킨스는 Subversion이나 Git과 같은 버전관리시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행하기 때문에 만약 개인이 미처 실시하지 못한 테스트가 있다 하여도 든든한 안전망이 되어줍니다. 제대로 테스트를 거치지 않은 코드를 커밋하게 되면 화난 젠킨스를 만날 수 있습니다.</p>\n<h3 id=\"코드-표준-준수여부-검사\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%ED%91%9C%EC%A4%80-%EC%A4%80%EC%88%98%EC%97%AC%EB%B6%80-%EA%B2%80%EC%82%AC\" aria-label=\"코드 표준 준수여부 검사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 표준 준수여부 검사</h3>\n<p>자동화 테스트와 마찬가지로 개인이 미처 실시하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여합니다.</p>\n<h3 id=\"빌드-파이프라인-구성\" style=\"position:relative;\"><a href=\"#%EB%B9%8C%EB%93%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%84%B1\" aria-label=\"빌드 파이프라인 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빌드 파이프라인 구성</h3>\n<p>2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따는 빌드 파이프라인 구성이 필요합니다. 예를 들면, 도메인 -> 서비스 -> UI와 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안됩니다. 젠킨스에서는 이러한 빌드 파이프라인의 구성을 간단히 할 수 있으며, 스크립트를 통해서 매우 복잡한 제어까지도 가능합니다.</p>\n<h1 id=\"연결된-화면\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0%EB%90%9C-%ED%99%94%EB%A9%B4\" aria-label=\"연결된 화면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결된 화면</h1>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411178-fbadcea5-4d1a-41fb-8213-7c320c12c285.png\" alt=\"222\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411179-a3f63d3d-60e9-40d6-9850-f110fc56fc71.png\" alt=\"333\"></p>\n<p>.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411181-0c07ac2f-bf9c-4c72-b103-c56513d4ec5b.png\" alt=\"444\"></p>\n<p>게다가 젠킨스의 장점으로는 Slack과의 연동으로 매번 젠킨스를 접속해 에러 유무를 판단하는 작업을 자동화해 협업툴인 Slack 메시지로 넘어오게 설정할 수 있습니다. 아래 사진은 젠킨스 결과 메시지입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186411184-2dc36600-f374-47ee-a3a4-bb9b07fe4c82.png\" alt=\"555\">\n<img src=\"https://user-images.githubusercontent.com/78959175/186411189-d3cc6893-6894-403a-b09d-5af525ea6c7f.png\" alt=\"666\"></p>","frontmatter":{"date":"May 20, 2022","title":"[Tech-Talk] 젠킨스(Jenkins)","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech10Jenkins/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":"hoonloper/hoonloper.github.io"}}}}},"pageContext":{"slug":"/modern-agile-team/tech9TestCode/","nextSlug":"/modern-agile-team/tech8ClassGram/","prevSlug":"/modern-agile-team/tech10Jenkins/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}