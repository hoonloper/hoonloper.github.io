{"componentChunkName":"component---src-templates-blog-template-js","path":"/modern-agile-team/tech2BigO/","result":{"data":{"cur":{"id":"c893beaf-0ff8-5764-ad57-7d2b97fc67ad","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/DbXRvWfqHCk\" title=\"테크톡🎤 시간복잡도, 공간복잡도 - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n## 빅-오(Big-O)는 무엇일까?\n<p>-> 간단하게 설명하면 알고리즘의 효율성을 나타내는 지표 혹은 언어입니다. Big-O를 확실히 이해하고 있어야 알고리즘을 구현할 때 큰 고비를 해결할 수 있습니다. 또한, Big-O에 대한 개념을 몰라 난처한 상황에 놓이거나 본인 코드의 개선점을 절대 찾지 못할 수도 있으니 꼭 이해하고 숙지했으면 합니다.</p>\n<h2 id=\"빅-오big-o는-무엇일까\" style=\"position:relative;\"><a href=\"#%EB%B9%85-%EC%98%A4big-o%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" aria-label=\"빅 오big o는 무엇일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빅-오(Big-O)는 무엇일까?</h2>\n<p>-> 간단하게 설명하면 알고리즘의 효율성을 나타내는 지표 혹은 언어입니다. Big-O를 확실히 이해하고 있어야 알고리즘을 구현할 때 큰 고비를 해결할 수 있습니다. 또한, Big-O에 대한 개념을 몰라 난처한 상황에 놓이거나 본인 코드의 개선점을 절대 찾지 못할 수도 있으니 꼭 이해하고 숙지했으면 합니다.</p>\n<h2 id=\"시간복잡도란\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%9E%80\" aria-label=\"시간복잡도란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간복잡도란?</h2>\n<p>-> 여러분들이 택배 기사라고 가정해 봅니다. 수많은 택배 물량을 해소하려면 택배 차량의 최대 적재량으로 배송하며 빠른 시간 내에 모든 가정에 배달을 완료해야 할 것입니다. 이 상황에서 택배의 물량이 감당하지 못할만큼 쏟아진다면 여러분들은 어떻게 할 것 같나요? 택배 차량의 수를 늘리든지 조금이라도 더 빨리 배송하면서 하나의 택배라도 더 배달하려고 할 것입니다. 여기서, 택배 차량의 적재량을 늘릴 수 있게 공간을 늘린다고 하거나 택배 차량의 성능을 업그레이드 또는 비행기로 운반한다면 먼 거리를 보다 빠른 속도로 더 많은 택배를 배송할 수 있을 것입니다.</p>\n<p>이것이 바로 점근적 <strong>실행 시간(Asymptotic runtime)</strong>, 또는 Big-O 시간에 대한 개념입니다.</p>\n<h3 id=\"1-택배-배송\" style=\"position:relative;\"><a href=\"#1-%ED%83%9D%EB%B0%B0-%EB%B0%B0%EC%86%A1\" aria-label=\"1 택배 배송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 택배 배송</h3>\n<p>O(n) - n이 배송해야 할 물품이라고 생각해봅시다. 택배 물량이 늘어나면 늘어날수록 배송 시간 또한 선형적으로 증가합니다.</p>\n<h3 id=\"2-비행기-배송-또는-택배-차량-성능-상승\" style=\"position:relative;\"><a href=\"#2-%EB%B9%84%ED%96%89%EA%B8%B0-%EB%B0%B0%EC%86%A1-%EB%98%90%EB%8A%94-%ED%83%9D%EB%B0%B0-%EC%B0%A8%EB%9F%89-%EC%84%B1%EB%8A%A5-%EC%83%81%EC%8A%B9\" aria-label=\"2 비행기 배송 또는 택배 차량 성능 상승 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 비행기 배송 또는 택배 차량 성능 상승</h3>\n<p>O(1) - 배송 물량에 상관없이 일정한 시간으로 배송 예정일에 맞춰 배송을 끝마칠 수 있습니다. 즉, 상수시간만큼 소요됩니다.</p>\n<p>여기서 선형식은 시간이 어떻게 흐르든 결국 상수를 뛰어넘게 됩니다. 이 외에도 다양한 실행 시간이 존재합니다.</p>\n<p>O(logN), O(NlogN), O(N), O(N^2), O(2^N) 등이 있으며 너비가 w미터이고 높이가 h미터인 울타리를 색칠하는 시간을 O(wh)로 표기할 수 있으며 p번의 페인트를 덧칠한다면 O(whp)의 시간이 소요됩니다.</p>\n<ul>\n<li><strong>Big-O</strong> : 시간의 상한을 나타냅니다. (최악의 경우)</li>\n<li><strong>Big-θ</strong> : 등가 개념 또는 하한을 나타냅니다. (최선의 경우)</li>\n<li><strong>Big-Ω</strong> : 빅오와 빅세타 둘 다 의미합니다. (평균의 경우)</li>\n</ul>\n<h2 id=\"최선의-경우-최악의-경우-평균적인-경우\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%84%A0%EC%9D%98-%EA%B2%BD%EC%9A%B0-%EC%B5%9C%EC%95%85%EC%9D%98-%EA%B2%BD%EC%9A%B0-%ED%8F%89%EA%B7%A0%EC%A0%81%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-label=\"최선의 경우 최악의 경우 평균적인 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최선의 경우, 최악의 경우, 평균적인 경우</h2>\n<p>-> 퀵 정렬을 예로들어 살펴보겠습니다. 퀵 정렬은 ‘축’이 되는 원소 하나를 무작위로 뽑은 뒤 이보다 작은 원소들은 앞에, 큰 원소들은 뒤에 놓이도록 원소의 위치를 바꿉니다. 그 결과 ‘부분 정렬’이 완성되고, 그 뒤 왼쪽과 오른쪽 부분을 이와 비슷한 방식으로 재귀적으로 정렬해 나갑니다.</p>\n<ul>\n<li>최선의 경우\n<ul>\n<li>만약 모든 원소가 동일하다면 퀵정렬은 평균적으로 한 차례만 순회하고 끝날 것입니다. [O(N)]</li>\n</ul>\n</li>\n<li>최악의 경우\n<ul>\n<li>배열에서 가장 큰 원소가 계속해서 축이 된다면 재귀 호출이 배열을 절반 크기의 부분 배열로 나누지 못하고 고작 하나 줄어든 크기의 부분 배열로 나누게 됩니다.[O(N^2)]</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>평균적인 경우\n<ul>\n<li>위와 같이 최선과 최악의 경우가 흔히 발생하는 것은 아닙니다. [O(NlogN)]</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"공간복잡도란\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%9E%80\" aria-label=\"공간복잡도란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공간복잡도란?</h2>\n<p>알고리즘에서는 시간뿐 아니라 메모리(혹은 공간) 또한 신경써야 합니다.</p>\n<p>공간복잡도는 시간 복잡도와 평행선을 달리는 개념입니다. 크기가 n인 배열을 만들고자 한다면 O(n)의 공간이 필요합니다. n x n 크기의 2차원 배열을 만들고자 한다면 O(n^2)의 공간이 필요합니다.</p>\n<p>재귀 호출에서 사용하는 스택 공간 또한 공간 복잡도 계산에 포함됩니다.</p>\n<h3 id=\"상수항은-무시\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%88%98%ED%95%AD%EC%9D%80-%EB%AC%B4%EC%8B%9C\" aria-label=\"상수항은 무시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상수항은 무시!</h3>\n<p>Big-O는 단순히 증가하는 비율을 나타내는 개념이므로 특수한 입력에 한해 O(N) 코드가 O(1) 코드보다 빠르게 동작하는 것은 가능성이 있습니다.</p>\n<p>이런 이유로 수행 시간에서 상수항을 무시합니다. 즉 O(2N)이든 O(64N)이든 O(N)으로 표기합니다.</p>\n<p>하지만, O(N)이 언제나 O(2N)보다 나은 것은 아닙니다.</p>\n<h3 id=\"지배적이지-않은-항은-무시\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EB%B0%B0%EC%A0%81%EC%9D%B4%EC%A7%80-%EC%95%8A%EC%9D%80-%ED%95%AD%EC%9D%80-%EB%AC%B4%EC%8B%9C\" aria-label=\"지배적이지 않은 항은 무시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지배적이지 않은 항은 무시!</h3>\n<p>O(N^2+N)과 같은 수식이 있을 때는 어떻게 해야 할까요? 두번째 N은 상수항은 아니지만 특별히 중요한 항도 아닙니다. O(N^2+N^2)은 O(N^2)가 됩니다. N^2항을 무시해도 된다면 그보다 작은 N항은 무시해도 됩니다.</p>\n<ul>\n<li>O(N^2+N)은 O(N^2)이 된다.</li>\n<li>O(N+logN)은 O(N)이 된다.</li>\n<li>O(5*2^N+1000N^100)은 O(2^N)이 된다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186401538-f546df5e-28e8-48bf-8736-bcd32bc32674.png\" alt=\"image\"></p>\n<p>위 그래프와 같이 O(N^2)은 O(N)보다 맣이 느리지만 O(2^N)이나 O(N!)보다는 느리지 않고, 최악의 경우보다 느린 경우는 생각보다 많습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>첫번째 코드입니다. 이 코드에서는 A의 일이 끝마쳐진뒤 B의 일을 수행합니다. 시간복잡도는 O(I+J)가 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>두번째 코드입니다. 이 코드에서는 A의 각 원소에 대해 B의 일을 수행합니다. 시간복잡도는 O(I*J)가 됩니다.</p>\n<p><strong>즉, 첫번째 코드의 형태라면 수행 시간을 더하는 형태이고, 두번째 코드의 형태라면 수행 시간을 곱해야 합니다.</strong></p>\n<h2 id=\"상환-시간\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%99%98-%EC%8B%9C%EA%B0%84\" aria-label=\"상환 시간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상환 시간</h2>\n<p>ArrayList(동적 가변크기 배열)는 배열의 역할을 함과 동시에 크기가 자유롭게 조절되는 자료 구조입니다.</p>\n<p>배열이 가득 차 있는 경우를 생각해보면 배열에 N개의 원소가 들어있을 때 새로운 원소를 삽입하려면 O(N)이 걸립니다. 크기가 2N인 배열을 새로 만들고 기존의 모든 원소를 새 배열로 복사해야 하기 때문입니다. 따라서 이 경우 삽입 연산은 O(N) 시간이 소요됩니다.</p>\n<p>하지만, 배열이 가득 차 있는 경우는 극히 드물기에 대다수의 경우에는 배열에 가용 공간이 존재하고 이때의 삽입 연산은 O(1)이 걸립니다.</p>\n<p>최악의 경우는 가끔 발생하지만 한번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 수행 시간을 분할 상환한다는 개념입니다.</p>\n<p>즉, 1에서 X까지 2배씩 증가하는 수열과 X에서 1까지 절반씩 감소하는 수열을 분할 상환해보면 결국 필요한 시간은 O(1)이다.</p>\n<h3 id=\"logn-수행-시간\" style=\"position:relative;\"><a href=\"#logn-%EC%88%98%ED%96%89-%EC%8B%9C%EA%B0%84\" aria-label=\"logn 수행 시간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>logN 수행 시간</h3>\n<p>이진 탐색을 생각해봅니다. 이진 탐색은 N개의 정렬된 원소가 들어있는 배열에서 원소 x를 찾을 때 사용됩니다.</p>\n<p>먼저 원소 x와 배열의 중간값을 비교합니다. <strong>‘x중간값’을 만족하면 이를 반환합니다. ‘x &#x3C; 중간값’일 때는 배열의 왼쪽부분을 재탐색하고 ‘x > 중간값’일 때는 배열의 오른쪽 부분을 재탐색합니다.</strong></p>\n<p>N을 절반씩 나누는 과정에서 몇 단계만에 1이 되는지에 따라 결정됩니다.</p>\n<p>즉, 2^k = N을 만족하는 k는 로그(log)입니다.</p>\n<p>2^4 = 16 → log16 = 4, logN = k → 2^k = N</p>\n<p>어떤 문제에서 원소의 개수가 절반씩 줄어든다면 그 문제의 수행 시간은 O(logN)이 될 가능성이 큽니다.</p>\n<p>같은 원리로, 균형 이진 탐색 트리에서 원소를 찾는 문제도 O(logN)입니다. 매 단계마다 원소의 대소를 비교한 뒤 왼쪽 혹은 오른쪽으로 내려갑니다. 각 단계에서 검색해야 할 노드의 개수가 절반씩 줄어들게 되므로, 문제 공간 또한 절반씩 줄어듭니다.</p>\n<h3 id=\"재귀적으로-수행-시간-구하기\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\"재귀적으로 수행 시간 구하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀적으로 수행 시간 구하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 코드를 보고 함수가 두번 호출되었으니 O(N^2)이라고 생각할 수 있는데 틀렸습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186401606-a7f766f4-8957-484e-9af0-c12a774b3134.png\" alt=\"image\"></p>\n<p>전체 노드의 개수는 2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^N (= 2^(N+1) -1)이 됩니다.</p>\n<p>여기서 다수의 호출로 이루어진 재귀 함수에서 수행 시간은 보통 O(분기(재호출)^깊이)로 표현됩니다.</p>\n<p>따라서, 위 수행 시간은 O(2^N)이 됩니다.</p>\n<p>이 알고리즘에서 공간복잡도는 O(N)이 될 것입니다. 전체 노드의 개숮는 O(2^N)이지만 특정 시각에 사용하는 공간의 크기는 O(N)입니다.</p>","excerpt":"-> 간단하게 설명하면 알고리즘의 효율성을 나타내는 지표 혹은 언어입니다. Big-O를 확실히 이해하고 있어야 알고리즘을 구현할 때 큰 고비를 해결할 수 있습니다. 또한, Big-O에 대한 개념을 몰라 난처한 상황에 놓이거나 본인 코드의 개선점을 절대 찾지 못할 수도 있으니 꼭 이해하고 숙지했으면 합니다. 빅-오(Big-O)는 무엇일까? -> 간단하게 설명하면 알고리즘의 효율성을 나타내는 지표 혹은 언어입니다. Big-O를 확실히 이해하고 있어야 알고리즘을 구현할 때 큰 고비를 해결할 수 있습니다. 또한, Big-O에 대한 개념을 몰라 난처한 상황에 놓이거나 본인 코드의 개선점을 절대 찾지 못할 수도 있으니 꼭 이해하고 숙지했으면 합니다. 시간복잡도란? -> 여러분들이 택배 기사라고 가정해 봅니다. 수많은 택배 물량을 해소하려면 택배 차량의 최대 적재량으로 배송하며 빠른 시간 내에 모든 가정에 배달을 완료해야 할 것입니다. 이 상황에서 택배의 물량이 감당하지 못할만큼 쏟아진다면 여…","frontmatter":{"date":"January 06, 2022","title":"[Tech-Talk] 시간복잡도, 공간복잡도","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/tech2BigO/"}},"next":null,"prev":{"id":"16154821-fa7c-5e46-9bdf-244fab27537e","html":"<p>⭐️ SELECT</p>\n<p>데이터를 조회할 때 사용하는 명령어입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-- datas 테이블에 있는 모든 데이터를 조회합니다.\nSELECT * FROM datas;\n\n-- datas 테이블 안에 있는 data1 컬럼 값을 조회합니다. data1뿐만 아니라 다른 컬럼도 추가로 조회할 수 있습니다.\nSELECT data1 FROM datas;\nSELECT data1, data2, data3 FROM datas;\n\n-- 테이블의 컬럼이 아닌 값도 선택할 수 있습니다.\nSELECT data1, 1, 'hi', NULL FROM datas;</code></pre></div>\n<p>*(asterisk)는 테이블의 모든 컬럼을 뜻합니다.</p>\n<p>원하는 데이터 가져오기[WHERE, ORDER BY, LIMIT, AS]</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-- WHERE을 사용해 구문 뒤에 조건을 붙여 원하는 데이터만 가져올 수 있습니다.\nSELECT * FROM datas WHERE dataID = 3;\nSELECT * FROM datas WHERE dataID &lt; 3;\n\n-- ORDER BY 구문을 사용해서 특정 컬럼을 기준으로 데이터를 정렬할 수 있습니다.\n-- ASC : 오름차순(default)\n-- DESC : 내림차순\nSELECT * FROM datas ORDER BY dataName;\nSELECT * FROM datas ORDER BY dataID ASC, dataName DESC;\n\n-- LIMIT {가져올 갯수} 또는 LIMIT {건너뛸 갯수}, {가져올 갯수}를 사용하여,\n-- 원하는 위치에서 원하는 만큼만 데이터를 가져올 수 있습니다.\nSELECT * FROM datas LIMIT 10;\nSELECT * FROM datas LIMIT 0, 10;\nSELECT * FROM datas LIMIT 30, 10;\n\n-- AS를 사용해서 컬럼명을 변경할 수 있습니다.\nSELECT dataID AS ID(또는 '아이디'), dataName AS NAME(또는 '이름'), Address AS ADDR(또는 '주소')\nFROM datas;</code></pre></div>\n<p>SELECT 명령어 전부 활용해보기</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT dataID AS '아이디', dataName AS '이름', City AS '도시', Country AS '국가'\nFROM datas\nWHERE City = 'London' OR Country = 'Mexico'\nORDER BY dataName\nLIMIT 0, 5;</code></pre></div>\n<p>자료 및 출처 : 얄코[<a href=\"https://www.yalco.kr/@sql/1-2/\">https://www.yalco.kr/</a>]</p>\n<p>사칙연산</p>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+, -, *, /</td>\n<td>(순서대로) 더하기, 빼기, 곱하기, 나누기</td>\n</tr>\n<tr>\n<td>%, MOD</td>\n<td>나머지</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT 1 + 2;\nSELECT 5 - 2.5 AS DIFFERENCE\nSELECT 3 * (2 + 4) / 2, 'Hello';\nSELECT 10 % 3;\n\n--문자열에 사칙연산을 할 경우 0으로 인식합니다.\nSELECT 'ABC' + 3;\nSELECT 'ABC' * 3;\n\n-- 숫자로 구성된 문자열은 숫자로 자동인식합니다.\nSELECT '1' + '002' * 3;\n\nSELECT OrderID + ProductID FROM OrderDetails;\nSELECT ProductName, Price / 2 AS HalfPrice FROM Products;</code></pre></div>\n<p>참/거짓 관련 연산자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT TRUE, FALSE;\nSELECT !TRUE, NOT 1, !FALSE, NOT FALSE;\n\n-- MySQL에서 TRUE는 1, FALSE는 0으로 저장됩니다.\nSELECT 0 = TRUE, 1 = TRUE, 0 = FALSE, 1 = FALSE;\nSELECT * FROM Customers WHERE TRUE;\nSELECT * FROM Customers WHERE FALSE;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IS</td>\n<td>양쪽 모두 TRUE 또는 FALSE</td>\n</tr>\n<tr>\n<td>IS NOT</td>\n<td>한쪽은 TRUE, 한쪽은 FALSE</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT TRUE IS TRUE;\nSELECT TRUE IS NOT FALSE;\nSELECT (TRUE IS FALSE) IS NOT TRUE;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AND, &#x26;&#x26;</td>\n<td>양쪽 모두 TRUE일 때만 TRUE</td>\n</tr>\n<tr>\n<td>OR, ||</td>\n<td>한쪽이 TRUE면 TRUE</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT TRUE AND FALSE, TRUE OR FALSE;\nSELECT 2 + 3 = 6 OR 2 * 3 = 6;\n\nSELECT * FROM Orders WHERE CustomerID = 15 AND EmployeeID = 4;\nSELECT * FROM Products WHERE ProductName = 'Tofu' OR CategoryID = 8;\nSELECT * FROM OrderDetails WHERE ProductID = 20 AND (OrderID = 10514 OR Quantity = 50;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>양쪽 값이 같음</td>\n</tr>\n<tr>\n<td>!=, &#x3C;></td>\n<td>양쪽 값이 다름</td>\n</tr>\n<tr>\n<td>>, &#x3C;</td>\n<td>(왼, 오) 값이 더 큼</td>\n</tr>\n<tr>\n<td>>=, &#x3C;=</td>\n<td>(왼, 오) 값이 같거나 더 큼</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT 1 = 1, !(1 &lt;> 1), NOT (1 &lt; 2), 1 > 0 IS NOT FALSE;\nSELECT 'A' = 'A', 'A' != 'B', 'A' &lt; 'B', 'A' > 'B';\nSELECT 'Apple' > 'Banana' OR 1 &lt; 2 IS TRUE;\n\n-- MySQL의 기본 사칙연산자는 대소문자 구분을 하지 않습니다.\nSELECT 'A' = 'a';\n\n-- 테이블의 컬럼이 아닌 값으로 선택\nSELECT ProductName, Price, Price > 20 AS EXPENSIVE FROM Products;\nSELECT ProductName, Price, NOT Price > 20 AS CHEAP FROM Products;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BETWEEN {MIN} AND {MAX}</td>\n<td>두 값 사이에 있음</td>\n</tr>\n<tr>\n<td>NOT BETWEEN {MIN} AND {MAX}</td>\n<td>두 값 사이가 아닌 곳에 있음</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT 5 BETWEEN 1 AND 10;\nSELECT 'banana' NOT BETWEEN 'Apple' AND 'camera';\n\nSELECT * FROM OrderDetails WHERE ProductID BETWEEN 1 AND 4;\nSELECT * FROM Customers WHERE CustomerName BETWEEN 'b' AND 'c';</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IN (…)</td>\n<td>괄호 안의 값들 가운데 있음</td>\n</tr>\n<tr>\n<td>NOT IN(…)</td>\n<td>괄호 안의 값들 가운데 없음</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT 1 + 2 IN (2, 3, 4)\nSELECT 'Hello' IN (1, TRUE, 'hello')\n\nSELECT * FROM Customers WHERE City IN ('Torino', 'Paris', 'Portland', 'Madrid')</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>LIKE ’… % …’</td>\n<td>0~N개 문자를 가진 패턴</td>\n</tr>\n<tr>\n<td>LIKE ’… _ …’</td>\n<td>_ 갯수 만큼의 문자를 가진 패턴</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  'HELLO' LIKE 'hel%',\n  'HELLO' LIKE 'H%',\n  'HELLO' LIKE 'H%O',\n  'HELLO' LIKE '%O',\n  'HELLO' LIKE '%HELLO%',\n  'HELLO' LIKE '%H',\n  'HELLO' LIKE 'L%'\n\nSELECT\n  'HELLO' LIKE 'HEL__',\n  'HELLO' LIKE 'h___O',\n  'HELLO' LIKE 'HE_LO',\n  'HELLO' LIKE '_____',\n  'HELLO' LIKE '_HELLO',\n  'HELLO' LIKE 'HEL_',\n  'HELLO' LIKE 'H_O'\n\nSELECT * FROM Employees WHERE Notes LIKE '%economics%'\n\nSELECT * FROM OrderDetails WHERE OrderID LIKE '1025_'</code></pre></div>\n<p>최종 정리</p>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>+</strong>, <strong>-</strong>, <strong>*</strong>, <strong>/</strong></td>\n<td>각각 더하기, 빼기, 곱하기, 나누기</td>\n</tr>\n<tr>\n<td><strong>%</strong>, <strong>MOD</strong></td>\n<td>나머지</td>\n</tr>\n<tr>\n<td><strong>IS</strong></td>\n<td>양쪽이 모두 TRUE 또는 FALSE</td>\n</tr>\n<tr>\n<td><strong>IS NOT</strong></td>\n<td>한쪽은 TRUE, 한쪽은 FALSE</td>\n</tr>\n<tr>\n<td><strong>AND</strong>, <strong>&#x26;&#x26;</strong></td>\n<td>양쪽이 모두 TRUE일 때만 TRUE</td>\n</tr>\n<tr>\n<td><strong>OR</strong>, <strong>||</strong></td>\n<td>한쪽은 TRUE면 TRUE</td>\n</tr>\n<tr>\n<td><strong>=</strong></td>\n<td>양쪽 값이 같음</td>\n</tr>\n<tr>\n<td><strong>!=</strong>, <strong>&#x3C;></strong></td>\n<td>양쪽 값이 다름</td>\n</tr>\n<tr>\n<td><strong>></strong>, <strong>&#x3C;</strong></td>\n<td>(왼쪽, 오른쪽) 값이 더 큼</td>\n</tr>\n<tr>\n<td><strong>>=</strong>, <strong>&#x3C;=</strong></td>\n<td>(왼쪽, 오른쪽) 값이 같거나 더 큼</td>\n</tr>\n<tr>\n<td><strong>BETWEEN</strong> {MIN} <strong>AND</strong> {MAX}</td>\n<td>두 값 사이에 있음</td>\n</tr>\n<tr>\n<td><strong>NOT BETWEEN</strong> {MIN} <strong>AND</strong> {MAX}</td>\n<td>두 값 사이가 아닌 곳에 있음</td>\n</tr>\n<tr>\n<td><strong>IN</strong> (…)</td>\n<td>괄호 안의 값들 가운데 있음</td>\n</tr>\n<tr>\n<td><strong>NOT IN</strong> (…)</td>\n<td>괄호 안의 값들 가운데 없음</td>\n</tr>\n<tr>\n<td><strong>LIKE</strong> ‘… <strong>%</strong> …’</td>\n<td>0~N개 문자를 가진 패턴</td>\n</tr>\n<tr>\n<td><strong>LIKE</strong> ‘… <strong>_</strong> …’</td>\n<td>_ 갯수만큼의 문자를 가진 패턴</td>\n</tr>\n</tbody>\n</table>\n<p>자료 및 출처 : 얄코[<a href=\"https://www.yalco.kr/\">https://www.yalco.kr/</a>]</p>\n<p>숫자 관련 함수들</p>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ROUND</strong></td>\n<td>반올림</td>\n</tr>\n<tr>\n<td><strong>CEIL</strong></td>\n<td>올림</td>\n</tr>\n<tr>\n<td><strong>FLOOR</strong></td>\n<td>내림</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT ROUND(0.5), CEIL(0.4), FLOOR(0.6);\n\nSELECT Price,ROUND(price), CEIL(price), FLOOR(price) FROM Products;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ABS</strong></td>\n<td>절대값</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT ABS(1), ABS(-1), ABS(3 - 10);\nSELECT * FROM OrderDetails WHERE ABS(Quantity - 10) &lt; 5;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>GREATEST</strong></td>\n<td>(괄호 안에서) 가장 큰 값</td>\n</tr>\n<tr>\n<td><strong>LEAST</strong></td>\n<td>(괄호 안에서) 가장 작은 값</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  GREATEST(1, 2, 3),\n  LEAST(1, 2, 3, 4, 5);\n\nSELECT OrderDetailID, ProductID, Quantity,\n  GREATEST(OrderDetailID, ProductID, Quantity),\n  LEAST(OrderDetailID, ProductID, Quantity)\nFROM OrderDetails;</code></pre></div>\n<p>💡 그룹 함수 - 조건에 따라 집계된 값을 가져옵니다.</p>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>MAX</strong></td>\n<td>가장 큰 값</td>\n</tr>\n<tr>\n<td><strong>MIN</strong></td>\n<td>가장 작은 값</td>\n</tr>\n<tr>\n<td><strong>COUNT</strong></td>\n<td>갯수 (NULL값 제외)</td>\n</tr>\n<tr>\n<td><strong>SUM</strong></td>\n<td>총합</td>\n</tr>\n<tr>\n<td><strong>AVG</strong></td>\n<td>평균 값</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  MAX(Quantity),\n  MIN(Quantity),\n  COUNT(Quantity),\n  SUM(Quantity),\n  AVG(Quantity)\nFROM OrderDetails\nWHERE OrderDetailID BETWEEN 20 AND 30;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>POW</strong>(A, B), <strong>POWER</strong>(A, B)</td>\n<td>A를 B만큼 제곱</td>\n</tr>\n<tr>\n<td><strong>SQRT</strong></td>\n<td>제곱근</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  POW(2, 3),\n  POWER(5, 2),\n  SQRT(16);\n\nSELECT Price, POW(Price, 1/2)\nFROM Products\nWHERE SQRT(Price) &lt; 4;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TRUNCATE</strong>(N, n)</td>\n<td>N을 소숫점 n자리까지 선택</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  TRUNCATE(1234.5678, 1),\n  TRUNCATE(1234.5678, 2),\n  TRUNCATE(1234.5678, 3),\n  TRUNCATE(1234.5678, -1),\n  TRUNCATE(1234.5678, -2),\n  TRUNCATE(1234.5678, -3);\n\nSELECT Price FROM Products\nWHERE TRUNCATE(Price, 0) = 12;</code></pre></div>\n<p>문자열 관련 함수들</p>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>UCASE</strong>, <strong>UPPER</strong></td>\n<td>모두 대문자로</td>\n</tr>\n<tr>\n<td><strong>LCASE</strong>, <strong>LOWER</strong></td>\n<td>모두 소문자로</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  UPPER('abcDEF'),\n  LOWER('abcDEF');\n\nSELECT\n  UCASE(CustomerName),\n  LCASE(ContactName)\nFROM Customers;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CONCAT</strong>(…)</td>\n<td>괄호 안의 내용 이어붙임</td>\n</tr>\n<tr>\n<td><strong>CONCAT_WS</strong>(S, …)</td>\n<td>괄호 안의 내용 S로 이어붙임</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT CONCAT('HELLO', ' ', 'THIS IS ', 2021)\nSELECT CONCAT_WS('-', 2021, 8, 15, 'AM')\nSELECT CONCAT('O-ID: ', OrderID) FROM Orders;\nSELECT CONCAT_WS(' ', FirstName, LastName) AS FullName\nFROM Employees;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>SUBSTR</strong>, <strong>SUBSTRING</strong></td>\n<td>주어진 값에 따라 문자열 자름</td>\n</tr>\n<tr>\n<td><strong>LEFT</strong></td>\n<td>왼쪽부터 N글자</td>\n</tr>\n<tr>\n<td><strong>RIGHT</strong></td>\n<td>오른쪽부터 N글자</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  SUBSTR('ABCDEFG', 3),\n  SUBSTR('ABCDEFG', 3, 2),\n  SUBSTR('ABCDEFG', -4),\n  SUBSTR('ABCDEFG', -4, 2);\n\nSELECT\n  LEFT('ABCDEFG', 3),\n  RIGHT('ABCDEFG', 3);\n\nSELECT\n  OrderDate,\n  LEFT(OrderDate, 4) AS Year,\n  SUBSTR(OrderDate, 6, 2) AS Month,\n  RIGHT(OrderDate, 2) AS Day\nFROM Orders;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>LENGTH</strong></td>\n<td>문자열의 바이트 길이</td>\n</tr>\n<tr>\n<td><strong>CHAR_LENGTH</strong>, <strong>CHARACTER_LEGNTH</strong></td>\n<td>문자열의 문자 길이</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  LENGTH('ABCDE'),\n  CHAR_LENGTH('ABCDE'),\n  CHARACTER_LENGTH('ABCDE');\n\n-- w3wchool 사이트에서는 한글이 제대로 동작하지 않습니다.\nSELECT\n  LENGTH('안녕하세요'), -- 15\n  CHAR_LENGTH('안녕하세요'), -- 5\n  CHARACTER_LENGTH('안녕하세요'); -- 5</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>TRIM</strong></td>\n<td>양쪽 공백 제거</td>\n</tr>\n<tr>\n<td><strong>LTRIM</strong></td>\n<td>왼쪽 공백 제거</td>\n</tr>\n<tr>\n<td><strong>RTRIM</strong></td>\n<td>오른쪽 공백 제거</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  CONCAT('|', ' HELLO ', '|'),\n  CONCAT('|', LTRIM(' HELLO '), '|'),\n  CONCAT('|', RTRIM(' HELLO '), '|'),\n  CONCAT('|', TRIM(' HELLO '), '|');\n\nSELECT * FROM Categories\nWHERE CategoryName = ' Beverages '\n\nSELECT * FROM Categories\nWHERE CategoryName = TRIM(' Beverages ')</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>LPAD</strong>(S, N, P)</td>\n<td>S가 N글자가 될 때까지 P를 이어붙임</td>\n</tr>\n<tr>\n<td><strong>RPAD</strong>(S, N, P)</td>\n<td>S가 N글자가 될 때까지 P를 이어붙임</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  LPAD('ABC', 5, '-'),\n  RPAD('ABC', 5, '-');\n\nSELECT\n  LPAD(SupplierID, 5, 0),\n  RPAD(Price, 6, 0)\nFROM Products;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>REPLACE(S, A, B)</strong></td>\n<td>S중 A를 B로 변경</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT REPLACE('맥도날드에서 맥도날드 햄버거를 먹었다.', '맥도날드', '버거킹');\n\nSELECT REPLACE(Description, ', ', ' and ')\nFROM Categories;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>INSTR</strong>(S, s)</td>\n<td>S중 s의 첫 위치 반환, 없을 시 0</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  INSTR('ABCDE', 'ABC'),\n  INSTR('ABCDE', 'BCDE'),\n  INSTR('ABCDE', 'C'),\n  INSTR('ABCDE', 'DE'),\n  INSTR('ABCDE', 'F');\n\nSELECT * FROM Customers\nWHERE INSTR(CustomerName, ' ') BETWEEN 1 AND 6;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CAST</strong>(A, T)</td>\n<td>A를 T 자료형으로 변환</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT '01' = '1', CONVERT('01', DECIMAL) = CONVERT('1', DECIMAL);</code></pre></div>\n<p>시간/날짜 관련 함수들</p>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CURRENT_DATE</strong>, <strong>CURDATE</strong></td>\n<td>현재 날짜 반환</td>\n</tr>\n<tr>\n<td><strong>CURRENT_TIME</strong>, <strong>CURTIME</strong></td>\n<td>현재 시간 반환</td>\n</tr>\n<tr>\n<td><strong>CURRENT_TIMESTAMP</strong>, <strong>NOW</strong></td>\n<td>현재 시간과 날짜 반환</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT CURDATE(), CURTIME(), NOW();</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DATE</td>\n<td>문자열에 따라 날짜 생성</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>문자열에 따라 시간 생성</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  '2021-6-1' = '2021-06-01',\n  DATE('2021-6-1') = DATE('2021-06-01'),\n  '1:2:3' = '01:02:03',\n  TIME('1:2:3') = TIME('01:02:03');\n\nSELECT\n  '2021-6-1 1:2:3' = '2021-06-01 01:02:03',\n  DATE('2021-6-1 1:2:3') = DATE('2021-06-01 01:02:03'),\n  TIME('2021-6-1 1:2:3') = TIME('2021-06-01 01:02:03'),\n  DATE('2021-6-1 1:2:3') = TIME('2021-06-01 01:02:03'),\n  DATE('2021-6-1') = DATE('2021-06-01 01:02:03'),\n  TIME('2021-6-1 1:2:3') = TIME('01:02:03');\n\nSELECT * FROM Orders\nWHERE OrderDate BETWEEN DATE('1997-1-1') AND DATE('1997-1-31');</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>YEAR</strong></td>\n<td>주어진 DATETIME값의 년도 반환</td>\n</tr>\n<tr>\n<td><strong>MONTHNAME</strong></td>\n<td>주어진 DATETIME값의 월(영문) 반환</td>\n</tr>\n<tr>\n<td><strong>MONTH</strong></td>\n<td>주어진 DATETIME값의 월 반환</td>\n</tr>\n<tr>\n<td><strong>WEEKDAY</strong></td>\n<td>주어진 DATETIME값의 요일값 반환(월요일: 0)</td>\n</tr>\n<tr>\n<td><strong>DAYNAME</strong></td>\n<td>주어진 DATETIME값의 요일명 반환</td>\n</tr>\n<tr>\n<td><strong>DAYOFMONTH</strong>, <strong>DAY</strong></td>\n<td>주어진 DATETIME값의 날짜(일) 반환</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  OrderDate,\n  YEAR(OrderDate) AS YEAR,\n  MONTHNAME(OrderDate) AS MONTHNAME,\n  MONTH(OrderDate) AS MONTH,\n  WEEKDAY(OrderDate) AS WEEKDAY,\n  DAYNAME(OrderDate) AS DAYNAME,\n  DAY(OrderDate) AS DAY\nFROM Orders;\n\nSELECT\n  OrderDate,\n  CONCAT(\n    CONCAT_WS(\n      '/',\n      YEAR(OrderDate), MONTH(OrderDate), DAY(OrderDate)\n    ),\n    ' ',\n    UPPER(LEFT(DAYNAME(OrderDate), 3))\n  )\nFROM Orders;\n\nSELECT * FROM Orders\nWHERE WEEKDAY(OrderDate) = 0;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>HOUR</strong></td>\n<td>주어진 DATETIME의 시 반환</td>\n</tr>\n<tr>\n<td><strong>MINUTE</strong></td>\n<td>주어진 DATETIME의 분 반환</td>\n</tr>\n<tr>\n<td><strong>SECOND</strong></td>\n<td>주어진 DATETIME의 초 반환</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW());</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ADDDATE</strong>, <strong>DATE_ADD</strong></td>\n<td>시간/날짜 더하기</td>\n</tr>\n<tr>\n<td><strong>SUBDATE</strong>, <strong>DATE_SUB</strong></td>\n<td>시간/날짜 빼기</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  ADDDATE('2021-06-20', INTERVAL 1 YEAR),\n  ADDDATE('2021-06-20', INTERVAL -2 MONTH),\n  ADDDATE('2021-06-20', INTERVAL 3 WEEK),\n  ADDDATE('2021-06-20', INTERVAL -4 DAY),\n  ADDDATE('2021-06-20', INTERVAL -5 MINUTE),\n  ADDDATE('2021-06-20 13:01:12', INTERVAL 6 SECOND);\n\nSELECT\n  OrderDate,\n  ADDDATE(OrderDate, INTERVAL 1 YEAR),\n  ADDDATE(OrderDate, INTERVAL -2 MONTH),\n  ADDDATE(OrderDate, INTERVAL 3 WEEK),\n  ADDDATE(OrderDate, INTERVAL -4 DAY),\n  ADDDATE(OrderDate, INTERVAL -5 MINUTE)\nFROM Orders;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>DATE_DIFF</strong></td>\n<td>두 시간/날짜 간 일수차</td>\n</tr>\n<tr>\n<td><strong>TIME_DIFF</strong></td>\n<td>두 시간/날짜 간 시간차</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  OrderDate,\n  NOW(),\n  DATEDIFF(OrderDate, NOW())\nFROM Orders;\n\nSELECT TIMEDIFF('2021-06-21 15:20:35', '2021-06-21 16:34:41');\n\nSELECT * FROM Orders\nWHERE ABS(DATEDIFF(OrderDate, '1996-10-10')) &lt; 5;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>LAST_DAY</strong></td>\n<td>해당 달의 마지막 날짜</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  OrderDate,\n  LAST_DAY(OrderDate),\n  DAY(LAST_DAY(OrderDate)),\n  DATEDIFF(LAST_DAY(OrderDate), OrderDate)\nFROM Orders;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DATE_FORMAT</td>\n<td>시간/날짜를 지정한 형식으로 반환</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>형식</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>%Y</strong></td>\n<td>년도 4자리</td>\n</tr>\n<tr>\n<td><strong>%y</strong></td>\n<td>년도 2자리</td>\n</tr>\n<tr>\n<td><strong>%M</strong></td>\n<td>월 영문</td>\n</tr>\n<tr>\n<td><strong>%m</strong></td>\n<td>월 숫자</td>\n</tr>\n<tr>\n<td><strong>%D</strong></td>\n<td>일 영문(1st, 2nd, 3rd…)</td>\n</tr>\n<tr>\n<td><strong>%d</strong>, <strong>%e</strong></td>\n<td>일 숫자 (01 ~ 31)</td>\n</tr>\n<tr>\n<td><strong>%T</strong></td>\n<td>hh:mm:ss</td>\n</tr>\n<tr>\n<td><strong>%r</strong></td>\n<td>hh:mm:ss AM/PM</td>\n</tr>\n<tr>\n<td><strong>%H</strong>, <strong>%k</strong></td>\n<td>시 (~23)</td>\n</tr>\n<tr>\n<td><strong>%h</strong>, <strong>%l</strong></td>\n<td>시 (~12)</td>\n</tr>\n<tr>\n<td><strong>%i</strong></td>\n<td>분</td>\n</tr>\n<tr>\n<td><strong>%S</strong>, <strong>%s</strong></td>\n<td>초</td>\n</tr>\n<tr>\n<td><strong>%p</strong></td>\n<td>AM/PM</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  DATE_FORMAT(NOW(), '%M %D, %Y %T'),\n  DATE_FORMAT(NOW(), '%y-%m-%d %h:%i:%s %p'),\n  DATE_FORMAT(NOW(), '%Y년 %m월 %d일 %p %h시 %i분 %s초');\n\nSELECT REPLACE(\n  REPLACE(\n    DATE_FORMAT(NOW(), '%Y년 %m월 %d일 %p %h시 %i분 %초'),\n    'AM', '오전'\n  ),\n  'PM', '오후'\n)</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>STR _ TO _ DATE</strong>(S, F)</td>\n<td>S를 F형식으로 해석하여 시간/날짜 생성</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  DATEDIFF(\n    STR_TO_DATE('2021-06-04 07:48:52', '%Y-%m-%d %T'),\n    STR_TO_DATE('2021-06-01 12:30:05', '%Y-%m-%d %T')\n  ),\n  TIMEDIFF(\n    STR_TO_DATE('2021-06-04 07:48:52', '%Y-%m-%d %T'),\n    STR_TO_DATE('2021-06-01 12:30:05', '%Y-%m-%d %T')\n  );\n\nSELECT\n  OrderDate,\n  DATEDIFF(\n    STR_TO_DATE('1997-01-01 13:24:35', '%Y-%m-%d %T'),\n    OrderDate\n  ),\n  TIMEDIFF(\n    STR_TO_DATE('1997-01-01 13:24:35', '%Y-%m-%d %T'),\n    STR_TO_DATE(CONCAT(OrderDate, ' ', '00:00:00'), '%Y-%m-%d %T')\n  )\nFROM Orders;</code></pre></div>\n<p>기타 함수들</p>\n<table>\n<thead>\n<tr>\n<th>형식</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>IF</strong>(조건, T, F)</td>\n<td>조건이 참이라면 T, 거짓이면 F 반환</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT IF (1 > 2, '1는 2보다 크다.', '1은 2보다 작다.');\n\n-- 💡 보다 복잡한 조건은 CASE문을 사용합니다.\nSELECT\nCASE\n  WHEN -1 > 0 THEN '-1은 양수다.'\n  WHEN -1 = 0 THEN '-1은 0이다.'\n  ELSE '-1은 음수다.'\nEND;\n\nSELECT\n  Price,\n  IF (Price > 30, 'Expensive', 'Cheap'),\n  CASE\n    WHEN Price &lt; 20 THEN '저가'\n    WHEN Price BETWEEN 20 AND 30 THEN '일반'\n    ELSE '고가'\n  END\nFROM Products;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>형식</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>IFNULL</strong>(A, B)</td>\n<td>A가 NULL일 시 B 출력</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT IFNULL('A', 'B'), IFNULL(NULL, 'B');</code></pre></div>\n<p>자료 및 출처 : 얄코[<a href=\"https://www.yalco.kr/\">https://www.yalco.kr/</a>]</p>\n<p>GROUP BY - 조건에 따라 집계된 값을 가져옵니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT Country FROM Customers\nGROUP BY Country;\n\nSELECT CategoryID FROM Products\nGROUP BY CategoryID;\n\n-- 여러 컬럼을 기준으로 그룹화할 수도 있습니다.\nSELECT\n  Country, City,\n  CONCAT_WS(', ', City, Country)\nFROM Customers\nGROUP BY Country, City;</code></pre></div>\n<p>그룹 함수 활용하기</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  COUNT(*), OrderDate\nFROM Orders\nGROUP BY OrderDate;\n\nSELECT\n  ProductID,\n  SUM(Quantity) AS QuantitySum\nFROM OrderDetails\nGROUP BY ProductID\nORDER BY QuantitySum DESC;\n\nSELECT\n  CategoryID,\n  MAX(Price) AS MaxPrice,\n  MIN(Price) AS MinPrice,\n  TRUNCATE((MAX(Price) + MIN(Price)) / 2, 2) AS MedianPrice,\n  TRUNCATE(AVG(Price), 2) AS AveragePrice\nFROM Products\nGROUP BY CategoryID;\n\nSELECT\n  CONCAT_WS(', ', City, Country) AS Location,\n  COUNT(CustomerID)\nFROM Customers\nGROUP BY Country, City;</code></pre></div>\n<ul>\n<li>⚠️ ORDER BY 와는 함께 사용될 수 없습니다.</li>\n</ul>\n<p>HAVING - 그룹화된 데이터 걸러내기</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n  Country, COUNT(*) AS Count\nFROM Suppliers\nGROUP BY Country\nHAVING Count >= 3;\n\n-- 💡WHERE은 그룹하기 전 데이터, HAVING은 그룹 후 집계에 사용합니다.\nSELECT\n  COUNT(*) AS Count, OrderDate\nFROM Orders\nWHERE OrderDate > DATE('1996-12-31')\nGROUP BY OrderDate\nHAVING Count > 2;\n\nSELECT\n  CategoryID,\n  MAX(Price) AS MaxPrice,\n  MIN(Price) AS MinPrice,\n  TRUNCATE((MAX(Price) + MIN(Price)) / 2, 2) AS MedianPrice,\n  TRUNCATE(AVG(Price), 2) AS AveragePrice\nFROM Products\nWHERE CategoryID > 2\nGROUP BY CategoryID\nHAVING\n  AveragePrice BETWEEN 20 AND 30\n  AND MedianPrice &lt; 40;</code></pre></div>\n<p>DISTINCT - 중복된 값들을 제거합니다.</p>\n<p>- GROUP BY와 달리 집계 함수가 사용되지 않습니다.</p>\n<p>- GROUP BY와 달리 정렬하지 않으므로 더 빠릅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT DISTINCT CategoryID\nFROM Products;\n-- 위의 GROUP BY를 사용한 쿼리와 결과 비교\n\nSELECT COUNT DISTINCT CategoryId\nFROM Products;\n\nSELECT DISTINCT Country\nFROM Customers\nORDER BY Country;\n\nSELECT DISTINCT Country, City\nFROM Customers\nORDER BY Country, City;\n\n--💡GROUP BY와 DISTINCT 함께 활용하기\nSELECT\n  Country,\n  COUNT(DISTINCT CITY)\nFROM Customers\nGROUP BY Country;</code></pre></div>","frontmatter":{"date":"January 12, 2022","title":"[MySQL] 기초 SQL문","categories":"CS","author":"hoonloper","emoji":"💾"},"fields":{"slug":"/cs/mysql/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/modern-agile-team/tech2BigO/","nextSlug":"","prevSlug":"/cs/mysql/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}