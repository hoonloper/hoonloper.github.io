{"componentChunkName":"component---src-templates-blog-template-js","path":"/modern-agile-team/","result":{"data":{"cur":{"id":"1359b708-20b5-5a2d-9bb8-cb2d6b6db0e4","html":"<p>comming soon…</p>","excerpt":"comming soon…","frontmatter":{"date":"August 23, 2022","title":"[경험] SW 개발 동아리 Modern-Agile","categories":"경험","author":"hoonloper","emoji":"🧢"},"fields":{"slug":"/modern-agile-team/"}},"next":{"id":"d6b47a14-5574-56f1-8c1d-7a17c1f7cb17","html":"<iframe width=\"720\" height=\"420\" src=\"https://www.youtube.com/embed/wMXXdj6E444\" title=\"테크톡🎤 Refresh Token Flow - 정용훈(3기)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p>인증 관련해서 아주 중요한 Refresh Token에 대해 알아보도록 하겠습니다.</p>\n<p>이 게시글을 방문한 분들은 JWT(Json Web Token)에 대한 지식이 있다고 생각하고 가볍게 짚고 넘어가겠습니다.</p>\n<aside>\n🔎 JWT가 무엇인지 모른다면 인터넷에 많은 정보들이 공유되어 있으니 확인하고 오신다면 더 유용한 정보가 될 수 있습니다.\n</aside>\n<h2 id=\"jwt란-\" style=\"position:relative;\"><a href=\"#jwt%EB%9E%80-\" aria-label=\"jwt란  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT란 ?</h2>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186412429-50eb402d-2a14-4973-8871-27bf59d0dcda.png\" alt=\"Untitled\"></p>\n<p>JWT는 Json Web Token의 약어로, JSON 형식의 데이터를 암호화해 저장하는 토큰이며 다음과 같이 세 부분으로 구성됩니다.</p>\n<ul>\n<li>헤더(header): 토큰 종류와 해시 알고리즘 정보</li>\n<li>페이로드(payload): 토큰의 내용물이 인코딩된 부분</li>\n<li>시그니처(signature): 일련의 문자열, 시그니처를 통해 토큰이 변조되었는지 여부를 확인</li>\n</ul>\n<h3 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>간편합니다. 세션/쿠키는 별도의 저장소의 관리가 필요합니다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다. 이는 Stateless 한 서버를 만드는 입장에서는 큰 강점입니다. 여기서 Stateless는 어떠한 별도의 저장소도 사용하지 않는, 즉 상태를 저장하지 않는 것을 의미합니다. 이는 서버를 확장하거나 유지,보수하는데 유리합니다.</li>\n<li>확장성이 뛰어납니다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능합니다. 예를 들어 Facebook 로그인, Google 로그인 등은 모두 토큰을 기반으로 인증을 합니다. 이에 선택적으로 이름이나 이메일 등을 받을 수 있는 권한도 받을 수 있습니다.  여기까지의 글만 봤을 때는 JWT가 세션/쿠키 방식보다 더 효율적으로 보입니다. 하지만 JWT도 단점들이 존재합니다.</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h3>\n<ul>\n<li>이미 발급된 JWT에 대해서는 돌이킬 수 없습니다. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 됩니다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능합니다. 따라서 악의적인 사용자는 유효기간이 지나기 전까지 신나게 정보들을 털어갈 수 있습니다. -> 해결책기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급합니다. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있습니다. 이는 다음 포스팅에 나올 Oauth2에 더 자세히 다루도록 하겠습니다.</li>\n<li>Payload 정보가 제한적입니다. 위에서 언급했다시피 Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있습니다. (세션/쿠키 방식에서는 유저의 정보가 전부 서버의 저장소에 안전하게 보관됩니다) 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없습니다.</li>\n<li>JWT의 길이입니다. 세션/쿠키 방식에 비해 JWT의 길이는 깁니다. 따라서 인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생하게 됩니다.</li>\n</ul>\n<h2 id=\"access-token--refresh-token\" style=\"position:relative;\"><a href=\"#access-token--refresh-token\" aria-label=\"access token  refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token &#x26; Refresh Token</h2>\n<h3 id=\"access-token\" style=\"position:relative;\"><a href=\"#access-token\" aria-label=\"access token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token</h3>\n<p>인증을 위한 JWT 입니다. 하지만 제 3자에게 탈취당할 경우 보안에 취약하기 때문에 보안을 위해 유효기간을 매우 짧게 가져갑니다. Access Token은 유효기간이 짧기 때문에 인증이 빈번히 일어난다는 단점이 있습니다.</p>\n<h3 id=\"refresh-token\" style=\"position:relative;\"><a href=\"#refresh-token\" aria-label=\"refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refresh Token</h3>\n<p>Access Token과 동일하게 인증을 위한 JWT 입니다. 하지만 유효 기간이 짧은 Access Token을 보완하기 위해 사용되기에 상대적으로 유효 기간이 깁니다. 그리고 Access Token의 유효 기간이 만료되었을 경우 새로 발급해주는 키가 됩니다.</p>\n<h2 id=\"access-token-refresh-token-인증-과정nestjs\" style=\"position:relative;\"><a href=\"#access-token-refresh-token-%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95nestjs\" aria-label=\"access token refresh token 인증 과정nestjs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Access Token + Refresh Token 인증 과정(Nest.js)</strong></h2>\n<p>우선 그림으로 먼저 확인 후 실제 작성한 코드로 어떻게 발급이 되는지 과정을 살펴보겠습니다!</p>\n<p><img src=\"https://user-images.githubusercontent.com/78959175/186412425-b42bc8f4-419e-41f5-bfde-c04926582344.png\" alt=\"Untitled 1\"></p>\n<aside>\n🔎 코드 작성은 인터넷에 수많은 자료가 있어 생략하고 흐름을 중점으로 봐주시면 되겠습니다.\n</aside>\n<p><strong>로그인 코드입니다.</strong></p>\n<p>accessToken 및 refreshToken을 발급받은 것을 알 수 있습니다.</p>\n<img width=\"693\" alt=\"스크린샷_2022-07-14_오전_11 30 34\" src=\"https://user-images.githubusercontent.com/78959175/186412389-3e9825d4-209c-49c3-9c8a-bdc4c142e8f7.png\">\n<img width=\"700\" alt=\"스크린샷_2022-07-14_오전_11 31 07\" src=\"https://user-images.githubusercontent.com/78959175/186412392-d0b234dc-9ee4-411d-910b-ca87a90c8713.png\">\n<p>각각의 토큰 발급 코드입니다. 유저의 정보를 payload에 담아 발급하며, 발급된 토큰은 유저 DB에 업데이트 해줍니다.</p>\n<img width=\"957\" alt=\"스크린샷_2022-07-14_오전_11 24 21\" src=\"https://user-images.githubusercontent.com/78959175/186412373-85777a35-b0ce-4be3-b074-86f544de8c7b.png\">\n<p>Postman을 이용해 요청을 보내면 정상적으로 accessToken과 refreshToken이 발급되는 것을 알 수 있습니다.</p>\n<img width=\"265\" alt=\"스크린샷_2022-07-14_오전_11 31 50\" src=\"https://user-images.githubusercontent.com/78959175/186412399-df7dd810-590d-4512-831a-fa7f8f0e9765.png\">\n<p>DB 데이터를 확인해봐도 정상적으로 Refresh Token이 저장된 것을 확인할 수 있습니다.</p>\n<p>그럼 발급받은 AccessToken으로 정상적인 요청이 되는지 확인해보겠습니다!</p>\n<p>테스트를 위해 급하게 작성한 코드라 흐름 위주로 설명할게요!\n<img width=\"903\" alt=\"스크린샷_2022-07-14_오전_11 47 25\" src=\"https://user-images.githubusercontent.com/78959175/186412402-defcffd8-9b23-4759-9f02-662f32e47279.png\"></p>\n<p>새로 발급한 토큰입니다. 해당 accessToken을 POST 요청에 실어서 보내겠습니다.</p>\n<img width=\"878\" alt=\"스크린샷_2022-07-14_오전_11 48 10\" src=\"https://user-images.githubusercontent.com/78959175/186412406-c3862188-6a05-460e-864b-3ee00699b6d8.png\">\n<p>Postman에 Authorization Bearer Token 인풋박스에 토큰을 입력해준 후 요청을 보내면!</p>\n<img width=\"359\" alt=\"스크린샷_2022-07-14_오전_11 48 47\" src=\"https://user-images.githubusercontent.com/78959175/186412411-0ce50d48-2218-4747-998d-6a4e5ee56085.png\">\n<p>쨘~!! 이렇게 성공을하게 됩니다. 그럼 토큰을 어떻게 확인하는지 보겠습니다.</p>\n<img width=\"636\" alt=\"스크린샷_2022-07-14_오전_11 49 48\" src=\"https://user-images.githubusercontent.com/78959175/186412414-a514ff77-3624-4f85-89ef-1dd270dee977.png\">\n<p>JWT 전략 코드입니다. BearerToken 값을 읽어 해독한 값이 validate에 payload 매개변수로 들어갑니다. 해당 매개변수에서 email을 추출해 DB에 있는 데이터인지 확인 후 중요한 정보인 salt는 구조분해할당으로 제외하고 user값을 리턴합니다. 인증이 되지 않을 경우 RefreshToken 인증 코드는 이따가 추가하겠습니다.</p>\n<img width=\"469\" alt=\"스크린샷_2022-07-14_오전_11 51 37\" src=\"https://user-images.githubusercontent.com/78959175/186412419-8a3ea316-342b-4f72-a431-96cc51a08cec.png\">\n<p>해당 유저값을 콘솔에 찍어보면 정상적으로 데이터 확인이 가능합니다!</p>","frontmatter":{"date":"July 15, 2022","title":"[Tech-Talk] Refresh Token","categories":"테크톡","author":"hoonloper","emoji":"🎙"},"fields":{"slug":"/modern-agile-team/teck12RefreshToken/"}},"prev":{"id":"734cd2b6-4d3a-5161-8ae2-6f5ba6fe20c0","html":"<p>comming soon…</p>","frontmatter":{"date":"August 31, 2022","title":"[프로젝트] Mohae(모두의 해결사) - 재능 나눔 플랫폼","categories":"프로젝트","author":"hoonloper","emoji":"🌈"},"fields":{"slug":"/modern-agile-team/mohae/"}},"site":{"siteMetadata":{"siteUrl":"https://hoonloper.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/modern-agile-team/","nextSlug":"/modern-agile-team/teck12RefreshToken/","prevSlug":"/modern-agile-team/mohae/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}